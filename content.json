{"meta":{"title":"Philographer's Blog","subtitle":null,"description":null,"author":"Philographer","url":"https://philographer.github.io"},"pages":[{"title":"All categories","date":"2017-01-08T02:21:57.000Z","updated":"2018-03-08T05:00:57.728Z","comments":true,"path":"categories/index.html","permalink":"https://philographer.github.io/categories/index.html","excerpt":"","text":""},{"title":"All tags","date":"2017-01-08T02:19:46.000Z","updated":"2018-03-08T05:00:57.729Z","comments":true,"path":"tags/index.html","permalink":"https://philographer.github.io/tags/index.html","excerpt":"","text":""},{"title":"About","date":"2017-01-08T02:22:02.000Z","updated":"2018-09-03T02:11:55.257Z","comments":true,"path":"about/index.html","permalink":"https://philographer.github.io/about/index.html","excerpt":"","text":"유호균 (Yu Ho Gyun)안녕하세요. Philographer 개발 블로그의 유호균입니다.현재 인하대학교 컴퓨터공학과 4학년에 재학중이며 기술로서는 Web과 DevOps, SRE 그리고 사회 문제 해결에 관심이 많습니다.이 블로그에서는 전공과 개발, 그리고 기술과 후기를 중심으로 경험을 공유하려고 합니다. Junior Developer Email: yoohoogun114@naver.com Github LinkedIn Blog Facebook Technical Experience 2018.7 - 2018.8 (2 mos) NAVER Corporation ; Site Reliability Engineer Intern Project: Moerae, Server layer and topology visualization Project Domain: Site Reliability Engineering, Search Server Web frontend (Angular v2) Backend API Server(Django, Apache) Automation Script(Node.js) 2016.1 - 2018.2 (1 y 8 mos) Team Mondrian ; Software Engineer Project: QCMANAGER, 서울대학교 융합과학 기술대학원 연구용 프로젝트 Being, InBody Wear on the App Store, InBody Wear - Google Play, 서울시 생활인구 데이터 시각화: Demo, 서울시 생활인구 데이터 시각화: 동영상 Domain: Health Care, Geo-Location, Cloud Hybrid application(Ionic v1, v2, React native) Web frontend (Angular v1, v2) Backend API Server (Node.js, Express, Sequelize) 2016.2 - 2016.4 (2 mos) 주) APST; 단기 아르바이트, Back-End Developer Project: Homepage Renewal Project Deploy on AWS EC2(Ruby on Rails) Mailing service(Mailgun) 2015.6-2015.9 (3 mos) 인천지방법원; 청년인턴 민사집행과 기타집행계 사무보조, 전자화 보조 담당 Tech Stack Philographer | StackShare Education 2012.02 - 2019.02(Expected) BSc, Computer Science and Engineering; Inha University third year (South Korea) Computer Science, Communication Skill 2016.06 - 2017.06 Software Maesto 7th; MISP(Ministry of Science, ICT and Future Planning) Cloud, OpenStack, Project Managing, OpenCV, Architecture, Front-End, Back-End Astronaut Project Futsal Manager Project, Video Experience 2017.02 ~ 2018.02 수도권 대학생 경상,디자인,공학 융합 동아리, 경디공; 7th 홍보부 부원 Project: 혼그리, Can You Feel My Heartbeat? 2017.08 ~ 2018.02 AWS User Group 대학생 서포터즈, AWSKRUG 공식 대학생 서포터 그룹; 1th Developer Project: 세미나 스피커, 커뮤니티 활동 2015.12 - 2017.02 전국 대학생 연합 동아리, Nexters; 8th Developer Project: Wazap IOS Version, 미세몬 2015.09 - 2016.12 NGO, Code For Incheon; Organizer Project: Share your light, 화장실을 찾아줘, Dosim) DDP 전시: 2016 Maker Festival DDP 전시: 2016 공유서울 페스티벌 2015.06-2015.09 전국 대학생 연합 동아리, Like Lion(멋쟁이 사자처럼); 3th Developer Project: 인하 미식회 2012.02 - 2013.02 교내 프로그래밍 동아리 NETers; 10th developer Project: Dolphin Manager, Dolphin MP3 Player Press KBS 9시 뉴스 - 2014. 06. 13 제1연평해전 15주년… NLL 지키는 ‘서해 수호자’들 중앙일보 - 2016. 08. 13 가깝고 깨끗한 화장실 어디있지? 전국 1만개 위치 한눈에 인천인 - 2016.01.07 프로그래밍으로 다른 세상을 꿈꾸는 활동가들 더피알 - 2016. 12. 12 시빅해킹, 사회 속으로 인셉션 - 더피알 연수신문 2016. 01. 19 ‘시민들을 위한 사회’ 실현 꿈꾸는 ‘코드 포 인천’ - 연수신문 데이터넷 - 2016. 05. 02 “도시정전 재난, 이웃 연결로 돌파” - 데이터넷 EPNC - 2016. 05. 03 아트센터 ‘나비’ 주관 ‘시빅해킹 해카톤’ 성료 - EP&amp;C News Prized ArtCenter Nabi Civic hackerthon 2016 1등 (대상) MK News - “착한 시빅 해커가 도시를 구하죠” 대학생 연합 동아리 해커톤 Unithon 2017 4th 2등 (최우수상) 생활밀착형 핀테크 챗봇 “돈톡” 서비스 소개 생활밀착형 핀테크 챗봇 “돈톡” 발표영상 Open Source Contribution Fastlane (IOS, Android Automation Cli Tools) 문서 컨트리뷰트 Update README.md file for missing other fastlane tools link Updated Broken links React Native (A framework for building native apps using React) 문서 컨트리뷰트 Docs Remove references to Travis VS Code (Visual Studio Code Text editor) 문서 컨트리뷰트 Update ReleaseNotes.html by philographer AWS 한국 사용자 모임: 문서 번역, 세미나 자료 공유 awskrug/ausg-seminar-2018 awskrug/unithon-serverless-2018 Seminar Speaker Code Across 2016 @Incheon: 시빅해킹의 예시 행사 Link 시빅해킹의 예시 AWS KRUG University Support Group 2017: 초보자를 위한 AWS 뿌시기 행사 Link 팀플 과제를 여행하는 히치하이커를 위한 안내서 with AWS C9, AWS Elastic Beanstalk Link Unithon 6th AWS: Serverless Hands On Lab 행사 Link AWS를 활용한 Serverless 백엔드 구성 AWS Summit 2018: Serverless로 이미지 크롤링 프로토타입 개발기 행사 Link Serverless로 이미지 크롤링 프로토타입 개발기 Moto Everyone has their own philosophy. So you can make your own History."}],"posts":[{"title":"취업 후기 1-취업 준비편","slug":"job-search-1","date":"2018-09-03T02:20:49.000Z","updated":"2018-09-06T12:03:20.944Z","comments":true,"path":"2018/09/03/job-search-1/","link":"","permalink":"https://philographer.github.io/2018/09/03/job-search-1/","excerpt":"","text":"개요단군 이래로 취업이 가장 어려운 때인 바로 지금, 운이 좋게도 졸업 이전에 취업을 끝마치고 HR(Human Resources)과 입사 일정 조율을 하면서 쉬고 있던 도중 문득 대학교 졸업 및 취업 에 관한 경험담을 써야겠다고 마음을 먹었다. 본래 사람이란 나태한 동물 인지라… 집에서 쓰기는 어려울 것으로 생각했다. 그래서 전날 아침에 조조 영화를 일부러 예매한 후, 보고 나서 더욱 심심할 때 즈음 카페에 나와서 몇 글자 적어본다. 대학교 입학, 고삐 풀린 망아지 1학년물론 모두가 힘들게 대학교에 입학했겠지만, 나에게는 그 기억이 무척 강하게 남아있다. 왜냐하면 부모님 항상 나에게 “대학만 가라. 그때까지는 공부에 집중하고 대학 가면 네가 놀고 싶은 만큼 놀아라” 라고 말씀하시곤 하셨다. 나는 부모님의 말씀을 아주 잘 듣는 효자이므로 인하대학교에 입학해서는 정말 마음껏 놀았다. 늦게 들어오면 부모님이 걱정 하실까 봐 아예 밤을 새우고 아침 일찍 집에 들어갔으며, 몸을 못 가눌 만큼 술을 진탕 먹고 집에 다 들어와 현관문에 엎어지며 입술이 찢어져 응급실에 실려갈만큼!!! 질령나게 놀아버렸다. 당연하게도 열심히 놀았던 만큼 성적은 나를 배신하지 않았다. 가장 장학금을 받기 쉽다던 1학년 1학기, 2학기 모두 평점이 채 3이 채 되지 못했다. 1학년 2학기 성적표를 받아보고, 지금 이 타이밍이 바로 군대로 도망갈 타이밍이란 걸 직감하고 바로 해군에 자원입대하게 되었다. 군생활해군에서 고속정 을 타며 먹고, 자는 생활을 했었다. 항해하고 정박하는 특성상 통신실을 지키거나, 현문(배의 입구)에서 혼자 당직을 서는 시간이 매우 많았었다. 새벽 &amp; 밤에 혼자서 할 일이 무엇이 있을까… ”혼자 멍때리는 시간”을 무척 많이 가졌다. 밤바다를 바라보며 “제대 후 하고 싶은 일들, 앞으로의 미래”에 대해서 종이에 많이 끄적거렸던 것 같다. 이렇게 혼자 시간을 보내는 시간이 많으니, 당연하게도 스스로에 대해서 많은 고민도 해 보고, 제대해서는 1학년처럼 마냥 놀면서 시간을 보내면 안 된다고 생각했다. 그렇게 많은 고민과 생각으로 제대하게 되었다. PS. 이 무렵, 우연히 연평해전이라는 영화가 주목받아 제1연평해전 15주년…승전 잇는 ‘서해 수호자’들 KBS에 인터뷰가 나가기도 했다. 제대 이후, 정신차린 2학년제대하며 코딩이란 코딩은 다 까먹어 버리고 2학년 1학기로 빠르게 복학하게 되었다. 복학했을 무렵에는, 여자 동기들은 취준생이기도 하고 남자 동기들은 아직 군대에 있는 친구들이 대부분이어서 같이 놀 사람도 많이 없었다. 시간이 없는 대학생이 혼자 술을 먹겠는가, 혼자 놀겠는가. 할 게 없으니 공부라도 해야지 하는 생각에 군대버프를 받아서 2학년 1학기에는 성적 우수자로 장학금을 받기도 했다. 우연히 2학년 1학기에 친구와 웹 프로그래밍 수업을 듣게 되었다. 전공 선택인 과목이라 듣지 않아도 되었지만, 그냥 코딩이 재밌어 보여서 수강하게 되었다. HTML5, CSS, Javascript, Apache, Tomcat, JSP 등을 배웠는데 혼자 개인 블로그를 만드는 것이 최종 프로젝트이자 한 학기에서 가장 큰 과제였다. 뭔가 계속 기능을 더 붙이고 싶어서 새벽까지 붙들고 기능을 추가하느라 안간힘을 썼던 기억이 많이 난다. 2학년 2학기가 끝나갈 무렵, 인터넷에서 멋쟁이사자처럼 의 모집 글을 보게 되었다. 비 전공자와 함께하는, 만들고자 하는 서비스를 직접 프로그래밍하는 동아리 를 모토로 하는 동아리였는데 당시의 내 실력은 비전공자와 다름이 없었기에 무식하고 용감하게 지원하게 되었다. 복학 후 얼마나 심심했는지 멋쟁이사자처럼에서 Ruby On Rails를 가지고 공강시간에 혼밥하는 학생들을 모아서 함께 밥을 먹는 프라이빗 소셜 다이닝 서비스 인하미식회 를 런칭하기도 했다. 서비스는 교내 커뮤니티에서 이슈가 되면서 적지않은 관심을 가지게 되기도 하였으나 혼자 개발, 운영, CS, QA 모든 일을 할 수 없다는 것을 깨닫고 서비스를 종료하게 되었지만 직접 서비스 출시를 통해 학교 수업보다 많은 것을 느끼고 배웠다. 대외 활동, 그리고 질풍의 3학년멋쟁이사자처럼을 시작으로, 대외활동에 재미를 붙이더니 3학년에는 수도권 대학생 디자이너, 개발자 IT 연합동아리인 NEXTERS를 거쳐서 도제식 멘토링을 해주고, 창업을 지원해주는 SW Maestro 활동도 하게되었다. 무언가 하나의 기점을 출발해서 연쇄적으로 이어진 듯이 동아리&amp;활동을 찾고, 가입하고, 활동하게 되었다. 그리고 이 무렵에CODE FOR INCHEON 이란 도시문제 해결을 목적으로 한 NGO(Non-Governmental Organization) 활동도 하게 되었다. 이런저런 대외 동아리&amp;활동을 하다 보니, 여러 가지 프로젝트들을 개발할 기회도 생겼고 자연스럽게 교육, 스마트시티, O2O등 의 도메인 지식에 대해서 접할 기회도 있어서 유익했다. 활동들이 쌓이다 보니, CODE FOR INCHEON에서 같이 활동하던 오거나이저 분이 운영하시는 스타트업인 Team Mondrian에 같이 일해보자는 제안도 받았었다. 휴학했을때는 풀타임으로 일하고, 학교에 다니면서는 파트타임으로 일하며 본의 아니게 중고신입 같은 경력이 쌓이게 되었다. 3학년 때 가장 많이 기억에 나는 활동은 SW Maestro였다. 매달 나오는 지원금 100만원이 경제적 생활에 매우 큰 도움이 되기도 하였고, 현업에 종사하시는 멘토님의 실무적 프로젝트를 진행하며 개발 외적으로도 프로젝트 리딩, 기획, 퍼블릭 스피킹, 방법론(애자일) 등에서도 배울 기회가 있었던 게 성장에 큰 밑거름이었다. 정리, 그리고 4학년4학년이 되니, 1학년 때 말아먹었던 학점을 복구하느라 고생했던 게 생각난다. 1학년 과정을 들으면서 본의 아니게 양학을 해버렸고 학점을 3.5로 겨우 복구하는 데 성공했다. 이 무렵 서버사이드, 그리고 AWS에 관심이 생겨서 AUSG활동을 하기도 했고, 서울에 가는 활동들에 지쳐서 집 주변인 인천에서 모임이 이뤄지는 경상&amp;디자인&amp;공학 연합 동아리 경디공 에서 전시, 강의들을 하면서 활동을 했다. 4학년엔 주로 개발보다는, 이력서와 포트폴리오를 정비하고 다듬는 작업들, 어딘가에 가서 발표하는 일들을 많이 진행했다. 졸업 전 내가 해왔던 결과물들을 재정비할 수 있고 되돌아볼 수 있는 시간이 있어서 한층 더 발전한다는 느낌이 들었다. 마무리하며그렇게 모든 활동과 대학생활이 끝나가는 시점인 4학년 1학기의 기말고사 즈음, 남들과 비슷하게 여러 가지 인턴 자리를 알아보다가 우연히 좋은 기회로 Naver에 인턴을 진행하기도 했다. 이제 4학년 2학기를 맞이하지만 웹강을 하나 들으면서 졸업할 수 있는 학점을 갖춰놓았기 때문에 별 이변이 없는 한 무탈하게 졸업하지 않을까 생각한다. 회고록을 적으면서, 이력서를 수정할 때면 “과거에 나는 정말 치열하게 살았구나” 라는 생각이 문득 든다. 그 당시엔 무척 힘들지는 않고 재미로 했었지만 그런 재미있는 활동들이 오늘의 나를 이룬 성장의 밑거름인 활동들인 것 같다. 글을 마무리 할 때 즈음, 내가 적는 다이어리에 이런 문장이 떠올라 이 말을 인용하며 글을 마무리한다. 처음에는 도대체 “왜” 하냐고 물을 것이고나중에는 도대체 “어떻게” 해낸 거냐고 물을 것이다.","categories":[{"name":"Retrospect","slug":"retrospect","permalink":"https://philographer.github.io/categories/retrospect/"},{"name":"Personal","slug":"retrospect/personal","permalink":"https://philographer.github.io/categories/retrospect/personal/"}],"tags":[{"name":"후기","slug":"후기","permalink":"https://philographer.github.io/tags/후기/"}]},{"title":"Flex의 사용방법","slug":"flex","date":"2018-04-22T06:34:46.000Z","updated":"2018-04-22T06:57:00.192Z","comments":true,"path":"2018/04/22/flex/","link":"","permalink":"https://philographer.github.io/2018/04/22/flex/","excerpt":"","text":"개요학교 컴파일러 과제를 진행하다가 Flex를 사용해 볼 기회가 있었다. 이론 수업을 듣다 보면 어느 정도 이해가 가기는 하지만, 본래 프로그래밍이란게 백문이 불여일타 이기 때문에 직접 작성해 보고 언제 쓸 수 있을지는 모르겠지만 기록으로 남겨두어야겠다는 생각이 들어서 블로그 아티클을 작성해본다. lex란?Flex에 대하여 말하기 이전에, Lex에 대해서 이해해야 한다. Lex란 Lexical Analyzer Generator이다. 이 말인즉슨, 어떠한 규칙에 따라서 Input Stream으로 들어온 Source Code를 미리 정의된 문법 규칙에 따라서 Tokenize해 주는 것 Lexical을 말한다. 다시 말하면 Lexical Analyzer의 주 역할은 다음과 같다.Lexical Analyzer의 역할: Source Code -&gt; Token으로 Tokenize해 준다. flex란?그렇다면 flex란 무엇일까? Flex는 Fast Lexical Analyzer Generator 란 것으로 Lex의 Open-Source 버전이라고 생각하면 된다. flex 설치하기필자의 환경은 Mac이므로 Mac 기준으로 설명하겠다.1$ brew install flex flex 사용하기기본적인 Lex 파일의 구조는 다음과 같다.12345678910111213141516171819/* FileName: lex.l */%&#123;/* C Header Include, Define */%&#125;/* regexp definitions */%%/* Translation Rules */%%/* C Code *//***Already Defined Variablesyyval = Lexeme Beginyytexr = Pointer To Lexeme beginyyleng = Length of Lexeme***/ 그러면 예제 코드를 작성해 보도록 하자. 아래 프로그램은 In-fix -&gt; Post-Fix 변환하는 코드이다. 예를들어 1+2+3을 입력하면 12+3+으로 변환해 준다.1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/* FileName: lex.l */%&#123;/* C Header Include, Define */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#define NUMBER 256 // 숫자#define IDENTIFIER 257 // 변수#define OPERATOR 258 // 덧셈, 뺄셈 연산자#define BUFSIZE 100 // 버퍼 사이즈, 배열 크기#define EOL 100 // 엔드 오브 라인%&#125;/* regexp definitions */num ([0-9]*[.])?([0-9]+)([E][-]?[0-9]+)?EOL \\n%%/* Translation Rules */&#123;num&#125; &#123; return NUMBER; &#125;[a-zA-Z0-9]+ &#123; return IDENTIFIER; &#125;[+,-] &#123; return OPERATOR; &#125;&#123;EOL&#125; &#123;return EOL;&#125;%%/* C Code */intmain () &#123; char operatorStack[BUFSIZE]; // 연산자 스택 int operatStackTopIdx = -1; // 스택의 Top Index int token; while ((token = yylex()) != EOL) &#123; // 토큰이 끝이라면 종료 switch (token) &#123; case NUMBER: printf(\"%s \", yytext); // 숫자는 바로바로 출력 break; case OPERATOR: if(operatStackTopIdx == -1) &#123; // 연산자는 스택이 비어있으면 넣고, operatorStack[++operatStackTopIdx] = yytext[0]; &#125; else &#123; // 스택이 비어있지 않으면 안에 있는것을 빼서 출력하고, 방금 받은 연산자는 새로 넣는다. printf(\"%c \", operatorStack[operatStackTopIdx--]); &#125; break; case IDENTIFIER: // printf(\"IDENTIFIER: %s, LENGTH:%d\\n\", yytext, yyleng); break; default: printf(\"Error: %s not recognized\\n\", yytext); &#125; &#125; while(operatStackTopIdx &gt; -1) &#123; // 스택이 비어있을 때 까지, 남은 연산자 출력 printf(\"%c \", operatorStack[operatStackTopIdx--]); &#125; printf(\"\\n\");&#125; 위의 파일을 lex.l 이라고 저장한 후에 다음과 같이 실행할 수 있다.12345$ flex hello.l # lex를 이용해 .yy.c 파일 생성$ gcc lex.yy.c -ll # gcc를 이용해 -ll 옵션을 주고 컴파일$ ./a.out # 실행파일 실행# 실행 파일의 내용은 in-fix인 1+2+3을 입력하면# post-fix인 12+3+으로 변환해 준다. 정리Lex, Flex에 대해서 알아보고 실제 Flex를 이용할 때 어떤 명령어를 사용해보고 정리해 보았다. 사실 Lexical Analyzer나 Parser 또는 Compiler를 직접 만들어서 내가 쓸 수 있을지는 모르겠지만, 정리해 둔다면 언젠가 후배가 물어본다거나 할 때 쓸 수 있지 않을까.","categories":[{"name":"tip","slug":"tip","permalink":"https://philographer.github.io/categories/tip/"}],"tags":[{"name":"tip","slug":"tip","permalink":"https://philographer.github.io/tags/tip/"}]},{"title":"Team Mondrian 퇴사 후기","slug":"retire-mondrian","date":"2018-03-18T05:00:35.000Z","updated":"2018-03-18T05:11:40.000Z","comments":true,"path":"2018/03/18/retire-mondrian/","link":"","permalink":"https://philographer.github.io/2018/03/18/retire-mondrian/","excerpt":"","text":"개요드디어 미루고 미뤄왔던 후기 시리즈의 마지막인 근무했던 스타트업의 퇴사 후기를 적게 된다. 퇴사는 2월 20일부로 퇴사하였는데 학교에 다니고, 전시회 준비, 커뮤니티 활동을 하면서 적었던 후기에 밀려 밀려 마지막에 퇴사 후기를 적게 되었다. 팀 소개Team Mondrian은 대한민국의 스타트업으로 도시 시각화, 헬스케어, 데이터 사이언스, 컨설팅, 중규모 SI를 하는 회사이다. 회사의 멤버는 유수 대학 석박사출신 엔지니어들로 이루어져 있다. 합류2015년도 즈음, 제대 후에 할 일이 없어 여러 가지 대학생 모임 활동에 전전하고 있었다. 그러던 중, 심심해서 페이스북을 보고 있었는데 집앞에 Code For Incheon이란 모임이 열리고 있었다. 마침 집도 코앞이기 때문에 잠깐 나갔는데 어찌어찌 정규 멤버로 합류하기도 하고, 운영자와 같이 모임의 Organizer를 하게 되었다. 여러 가지 도시문제 해결을 위한 프로젝트를 기획하기도 하고, 매주 자신이 준비한 자유주제로 발표를 하는 세션도 있었기 때문에 흥미롭게 진행하기도 했었다. 그러던 중 모임의 다른 Organizer가 간단한 외주 프로젝트를 진행하는 게 어떠냐는 제안을 시작으로 팀에 합류하게 되었다. 팀의 문화완전 원격 근무를 지향하고 있는 팀이다. 해외에서는 Remote Work를 심심찮게 볼 수 있지만, 국내 문화에서는 아직 이르다는 평가로 도입이 늦춰지고 있는 문화이다. 팀에서는 Slack, GitHub, Google Drive, Google 행아웃 등의 도구로 원격에서 소통하며 1주에 월, 수, 금요일 1시간 정도 정기회의 세션을 가지며 서로 협업한다. 처음에 근무를 시작했을 때 너무너무 멋지다는 생각이 들었다. 아직 정식 출퇴근은 해본 경험은 없지만 매일 출근 시간 넘치는 인파들 속에서 등교하기 힘들었던 경험을 하지 않게 되어서 행복했다. 원경 근무의 장점완전 원격 근무의 장점은 오전, 오후, 야간에 진행해야 할 일들을 편히 할 수 있어서 매우 만족도가 높았다. 예를 들어 점심에 환전 등의 업무로 은행에 가야 할 때, 직장인들이 많은 점심시간을 피해서 아침 일찍 가거나 병원 예약을 내가 원하는 시간에 할 수 있어서 매우 편했다. 가장 좋은 점은 바로 내 생산성을 높일 수 있어서 좋았다. 원격근무를 한참 할 때는 내가 가장 코딩하기 좋아하는 시간인 이른 아침에 가장 좋고 많은 코드를 적어낼 수 있었으며 일하기 싫은 밥 먹고 난 이후 점심에는 1~2시간씩 낮잠을 잘 수 있었다. 그리고 다시 생산성이 매우 높아진 상태로 업무에 돌입할 수 있으며 점심에 까먹은 1~2시간은 조용한 12시 이후에 다시 보충했다. 그리고 저녁 시간은 야근 없이 친구들이나 여자친구, 가족들과 시간을 보낼 수 있었다. 물론 일이 많았을 때도 저녁 시간에 놀 수 있었지만 12시 이후에 다시 컴퓨터에 앉아서 새벽 늦게까지 야근하는 불상사가 일어지기도 했다. 원격 근무의 단점원격 근무의 장점은 출근을 하지 않는다이지만, 최대의 단점은 퇴근도 하지 않는다.이다. 한참 일이 바쁠 때면 침대에서 일어나 출근인 상태로, 침대에 누우면서 퇴근을 한 달 정도 반복했던 적도 있었다. 또 다른 단점은 초창기 팀원들의 커뮤니케이션이 쉽지 않았다. “슬랙, 행아웃, 스크린 히어로, 팀뷰어” 등 협업을 위한 툴들이 많이 생겼지만, 화상채팅만 가지고 회의에서 상대방의 진짜 의미나 제스처 분위기 를 보기 어렵기 때문에 아이디어 회의나 팀의 방향과 문화를 정하는 중대한 사항을 논할때는 원격 협업 툴이 큰 도움이 되지 않았다. 마지막 단점은 자기관리였다. 출근과 퇴근 시간이 정해져 있지 않으므로 일과 삶이 구분되지 않은 워커 홀릭으로 지내거나 일을 하지 않아도 월급을 받는 월급 도둑이거나 삶이 둘 중에 하나로 변질되기 쉽다. 이런 두 가지 타입 사이에서 줄타기하듯 위태위태 중간을 유지하는 것이 어려웠다. Lessons learned 자기관리처음에는 전력투구하여서 워커 홀릭으로 몇달간 지냈다. 그렇게 지내다 보니 건강도 악화하며 체력도 약해지고 눈도 아프더니 몇 주간 쉬니 월급 도둑이 되어있었다. 원격근무 초기에는 이런 두 가지 타입을 몇 번씩 반복하니 나름의 노하우를 습득하였다. 아주 간단한 방법인데 바로 계획을 세우고 지킨다는 것이다. 아침에는 8시 고정된 시간에 운동하고, 점심엔 주기적으로 3~5시에 낮잠을 자고 5시에는 일어나자마자 업무를 저녁 먹기 전까지 진행하며 자기 전 1시간은 업무 마무리로 쓴다 같은 계획이었다. 상당히 단순한 타임테이블 이지만, 세상에서 가장 지키기 어려운게 Todo-list가 아니라 Time-table이었다. 이를 고수하는데 큰 노력이 들었다. 그리고 자기 자신에게 투자하는 개발 장비, 온라인 강의 등에는 아끼지 않고 돈을 쏟아부었다. (그래서 지금은 집에 아이맥 5k로 글을 쓰고 있다 ㅋㅋ) 마지막으로 건강관리인데, 건강이 악화되고 회복하는 과정을 여러번 거치다 보니 내 몸에 대해서 알게 되었다. 어느 정도가 한계치이고 어느 정도에 쉬어줘야 하는지 알았기 때문에 생산성을 어느 타이밍에 어떤 목적으로 늘릴 수 있는지 터득하게 되었다. 자율 출근 &amp; 미팅스타트업에서 가장 어려운 건 바로 회의였다. 현재 회사가 정확히 어느 길로 가는지 모르는 중에 회의한다는 것은 매우 어려웠다. 회사가 작기 때문에 나 같은 인턴이라도 개인의 의사결정이 회사의 방향에 매우 큰 영향을 미칠 수 있으므로 신중에 신중히 처리해야 했다. 그런데 이런 상황에서의 원격 회의는 독이다. 따라서 결국에는 자율적으로 오피스에 일주일에 몇 번씩 출근하는 문화가 만들어지게 되었다. 사수에게서 배우는 키워드 &amp; 아키텍쳐 &amp; 코드 스트럭쳐회사는 학교가 아니다. 초창기에는 과다한 의욕으로 사수에게 이것저것을 캐묻고는 했었는데 개인의 호기심을 채우면서 회사에 생산성에는 악영향을 끼친다는 것을 깨달았다. 따라서 그 후로부터는 사수에게 효과적으로 질문하는 방법을 알게 되었다. 뿐만 아니라 사수에게서 문제점의 키워드를 알아내고 스스로 공부하는 습관을 들였다. 사수는 사수이지 선생님이 아니기 때문에 적당한 키워드를 알아낸다면 스스로 공부하고 블로그에 글을 쓰던, 개인 메모장에 적던, 필기하던, 코드를 짜던 하는 방법으로 자가학습하는 방법을 깨달았다. 마지막으로는 팀원들의 코드와 주석을 보고 배우는 습관을 기르게 되었다. 주석이 없는 코드더라도 자세히, 몇 번씩 들여다보면 이 사람이 무슨 생각으로 코드를 적었는지 알 수 있었기 때문에 신기하고 재미있었다. 스타트업의 문화 &amp; 비전 &amp; 인사이트사실 이 팀에 들어오기까지 스타트업에 대해서는 문외한이었다. 하지만 본인이 스타트업 판 한 가운데가 있으므로 관심을 가지지 않으려야 안 가질 수가 없었다. 아무것도 모른 채로 들어왔을 때 스타트업은 매우 멋져 보이고 유망해 보였지만, 내가 경험했던 세계는 약육강식의 세계가 따로 없을 정도로 힘들고 척박한 곳이었다. 물론 우리 회사의 배경이나 문화는 좋았지만 스타트업 커뮤니티에 참여하면서 느끼고 배웠던 점은 스타트업의 오너를 하는 것은 참으로 어렵고 험난한 길이라는 것을 느꼈다. 스타트업의 완전 원격 근무, 뛰어난 멤버들의 비전과 인사이트를 사회 초년생이 배워가기에는 스타트업 근무 경험이 더할 나위 없이 좋았다. 퇴사 이유짧게 말하면 학업 &amp; 학점. 길게 말하면 취업준비 로 말할 수 있을 것 같다. 1년 휴학 기간은 공부와 일을 동시에 하는 데 문제가 크게 없었다. 하지만 학교에 다니던 중 파트타임 인턴으로 일을 하다 보니 학점이 크게 좋지 못했다. 따라서 졸업하기 전에 원하는 학점으로 졸업하기 위해서는 학교에 매진해야 했다. 그리고 스타트업에서 일해봤으니, 이제는 더욱 큰 기업에서 일을 해보고 싶은 개인적인 욕구가 생겼다. 아무래도 이리저리 떠돌면서 내가 원하는 게 뭔지 찾아가려는 내 특성 때문이 아닐까. 큰 곳에서 일해보면 그 다음에는 중견기업인가…! 마치며가장 마지막에 쓰는 후기 시리즈이기도 하고, 미뤄왔던 글을 써 내려가니 홀가분하기도 하다. 지금은 학교에 다니면서 시간도 나서 이런 글을 쓰고는 하는데, 직접 일을 해보니 이런 글 쓸 시간을 내는 것 조차 쉽지 않겠다는 생각이 든다. 앞으로는 더욱더 자기관리, 경력관리에 매진해서 좋은 기업에 취직을 목표로 취준생 생활을 보내야겠다는 마음가짐으로 글을 마친다.","categories":[{"name":"Retrospect","slug":"retrospect","permalink":"https://philographer.github.io/categories/retrospect/"},{"name":"Personal","slug":"retrospect/personal","permalink":"https://philographer.github.io/categories/retrospect/personal/"}],"tags":[]},{"title":"Can You Feel My Heartbeat? 프로젝트 후기","slug":"mdtconv2","date":"2018-03-12T03:09:48.000Z","updated":"2018-03-12T09:51:08.490Z","comments":true,"path":"2018/03/12/mdtconv2/","link":"","permalink":"https://philographer.github.io/2018/03/12/mdtconv2/","excerpt":"","text":"개요요즘 활동이나 프로젝트 후기를 쓰면서 프로젝트 포트폴리오를 정리하고 있다. 따라서 이번 경디공 활동에서 진행했고, 신도림역에서 전시했던 작품에 대해서도 역시 후기를 써보려고 한다. What To Make팀원은 재료공학과 팀원 1명, 디자인학부 1명, 컴퓨터공학과 1명으로 팀이 꾸려졌다. 전시회의 주제는 감성 &amp; 빛으로 잡혔기 때문에 범위 안에서 우리 팀의 주제를 선정해야 했다. 열띤 토론 끝에 심장박동을 가지고 게임이든 뭔가를 해보자는 쪽으로 결론이 잡혔다. 처음에는 심장박동을 가지고 바이오피드백 게임 을 만드는 건 어떨까 생각했었다. 그런데 우리가 사용 가능한 예산 내에서는 라즈베리 파이, 아두이노 등의 저가형 보드가 전부이며 왜 게임을 만들어야 하는가? 에 대한 해답을 우리 팀 내부에서도 찾지 못했다. 그러던중, 생각난 것이 심장박동 이었다. 심장박동은 알게 모르게 우리의 감성, 감정을 대변하는 도구이며 심장박동 센서를 통하여 수치화 및 분석을 할 수 있다. 따라서 우리는 심장박동을 가지고 무언가 한다면 재미있겠다는 생각이 들었다. 심장박동이란 내가 주체로 나오는 데이터이기도 하지만, 이것을 자신이 고스란히 보기는 어렵다. 따라서 우리는 이런 감성을 대변하는 심장박동 을 제 3자의 입장에서 표현하여 다시 본인에게 보여준다는 것을 가닥으로 프로젝트 주제를 잡았다. How To Make우선 팀원 당 할당된 예산이 많지 않았다. 약 15만 원 정도로 아래의 3가지 모듈들을 모두 대여하거나 구매해야 했다. 높은 밝기를 영사할 수 있는 프로젝터 3개 프로그래밍 가능한 보드 &amp; 심장박동 센서 &amp; LED &amp; 각종 모터, 센서들 심장박동 센서 및 보드의 거치가 가능한 아크릴 재료비 및 재단 비 “프로젝터”와 “아크릴”은 고정비용으로 나갈 수 있으니 재료비를 최대한 아끼려면 “프로그래밍 가능한 보드 &amp; 센서”에서 최대한 비용을 아껴야 했으므로 저가형 보드인 Arduino와 Rasberry Pi3 에 대하여 주로 알아보았다. 처음 라즈베리 파이 보드와 심장박동 센서를 구매해서 사용해보니 생각보다 정확도가 높지 않았다. 내가 너무 저가형 센서에 많은 것을 기대했던 것인가 걱정도 들었다. pulsesensor.com 에서 판매하는 정품 센서는 2만 원 중반대의 가격이었지만 내가 구매한 것은 4-5천 원 정도의 심장박동 센서 였다. SW/HW Architecture 라즈베리파이 를 이용한 센서 값 수집부 AWS EC2 환경에서 Node.js와 Socket.io를 이용한 data proxy server Chrome 브라우져의 Syphoner을 이용한 동영상 스트리밍 및 Madmapper (Projection Tool) 3대의 Projector 와 1대의 Bluetooth Speaker 를 이용한 Output Result Postmortem포스트모템은 영어로 “사후 시행하는 검시” 이며 프로젝트에서는 끝난 일에 대한 분석과 재검토를 말한다. 소프트웨어를 총괄적으로 한 세트를 구성해서 프로젝트를 진행해본 경험은 몇 번 있었지만, 하드웨어까지 합쳐서 구성해본 경험은 처음이었다. 처음에는 라즈베리 파이의 구조와 동작 원리, 전압 전류 저항 등을 이해하느라 어려웠지만, 인터넷에 있는 cheatsheet 같은 것들을 보고 youtube에서 튜토리얼을 보면서 연결하는 방법을 익혔다. 전시중 하드웨어 부분에서 심박센서 -&gt; 진동의 피드백이 역으로 진동 -&gt; 심박센서 의 센서값으로 인식되어 어려움이 있었다. 전시 후반부에서는 진동모터를 제거하고 전시를 진행하였다. 사실 소프트웨어, 하드웨어는 내가 전담해서 만들었지만 보이는 부분이 컸던 Projection과 아크릴로 손수 제작했던 case 의 부분이 생각보다 퀄리티 있어서 완성도가 높았던 프로젝트로 기억할 수 있을 것 같다. 단순히 재미로 시작했던 프로젝트였는데 전시를 진행하면서 이 전시물을 왜 만들었고, 사람들이 직접 체험하면서 재미있어하는 모습을 보면서 나도 흥미를 많이 느끼고 배웠던 프로젝트였다.","categories":[{"name":"Retrospect","slug":"retrospect","permalink":"https://philographer.github.io/categories/retrospect/"},{"name":"Project","slug":"retrospect/project","permalink":"https://philographer.github.io/categories/retrospect/project/"}],"tags":[{"name":"경디공","slug":"경디공","permalink":"https://philographer.github.io/tags/경디공/"}]},{"title":"경디공 3기 활동 마무리 후기","slug":"mdtconv","date":"2018-03-08T05:01:15.000Z","updated":"2018-03-08T14:15:20.000Z","comments":true,"path":"2018/03/08/mdtconv/","link":"","permalink":"https://philographer.github.io/2018/03/08/mdtconv/","excerpt":"","text":"개요2017년 3월 휴학하고 SW Maestro활동과 스타트업 프로젝트 마무리를 진행하면서 점점 가용 시간이 늘어났다. 그래서 남는 내 에너지를 어디에 쏟을 수 있을까 고민하던 찰나 학교 커뮤니티인 인하광장에서 경디공 이라는 대학생 연합 동아리를 발견했다. 조금 재미있는 점은 원래 연합동아리의 경우 같은 전공이나 공학+디자인의 조합으로 좀 더 자신의 전공에 심화한 활동들을 하는 게 대부분인데 이 동아리는 전공 융합 이라는 키워드를 필두로 활동을 진행한다는 게 독특했다. 나도 기술을 어차피 회사 일을 하거나 다른 커뮤니티, 그도 아니라면 개인적으로 독학할 수 있으니 시야를 넓히고자 이 동아리에 지원하게 되었다. 서류 평가여느 동아리 활동들처럼 두 가지를 통과하면 활동을 할 수 있게 된다. 지원자가 채워야 할 항목은 다음과 같았다. 질문1: 자신을 3가지 단어로 표현한다면? (Ex, 여신, 주당, 4차원 + 간단한 설명도 함께 작성해주세요)답변: Geek: Geek이란 무언가에 빠져있는 엉뚱한 괴짜라는 뜻입니다. 무언가에 골똘히 빠져있는 것을 좋아합니다. 주로 대상은 컴퓨터지만, 다른 것에도 관심이 많습니다.즉흥: 즉흥적으로 무언가를 하거나 먹는 것을 좋아합니다.Choicer: 잘 찍고 고르는데 일가견이 있습니다. 메뉴 선정 등등. 위의 답변은 자소설닷컴 에 기록이 남아있는 것을 그대로 가져왔다. 1년이 지난 다음 봐도 나를 잘 설명한 글 같다. 하지만 바뀐 예명 Philographer에 대한 설명이 없는 게 아쉽다. 다음에 지원할 땐 조금 바뀐 단어들이 들어갈 듯 (ex. 철학) 질문2: 본인이 이것만은 자신있다! 또는 이런 프로그램도 다룰 줄 안다! 하는 장점이 있다면 무엇인가요? (Ex, 발표를 잘한다, ppt를 잘 만든다, 포토샵 및 3d 프로그램 사용가능하다 등)답변: 홈페이지 만들기, 어플리케이션 제작, 서버 프로그래밍이 가능하다!(단, 디자이너가 디자인을 만들어 주는대로만 가능… 개인의 예술 감각은 전무합니다 ^~^) 짧게 적어서 제출했다. 한창 SW Maestro 과정을 마무리해서 그런지 대충 적은 감이 없지 않다. 질문3: 본인 전공 외 관심 있는 분야는 무엇인가요?답변: 주로 웹이나, 어플리케이션을 만들다 보니 디자인 분야에 관심이 많습니다.(UI, UX)컴퓨터 앞에만 앉아있다 보니 운동량 부족에 시달립니다. 살기위해 운동에도 관심이 많습니다. 이 항목은 저 당시에는 프론트엔드를 한창 열심히 하고 있었기 때문에 저렇게 적었나 보다. 지금은 인프라&amp;백엔드&amp;DevOps 쪽에 더 많은 관심이 있다. 질문4: 경디공을 통해 이루고 싶은 것 또는 기대하는 것은 무엇인가요?답변: 첫 번째로, 대학생 신분일 때 ‘대학생만’할 수 있는 활동에 관심이 많습니다. 경디공의 활동을 전부 찾아보지는 못했지만, 블로그, 페이스북을 봤을 때 개인의 취미를 나누거나 축제에 참여하는 모습을 보았습니다. 돈이 되지 않지만 재미있어 보이는 일을 단순히 재미로 시작하는 일들은 오로지 대학생 때만 할 수 있다고 생각합니다. 이런 재미있는 활동들을 하고싶습니다. 두 번째로, 커뮤니케이션 능력을 기르는데 힘쓰는 편입니다. 개인의 전공 능력도 중요하지만, 그만큼 의사소통 능력을 늘리고 협업하는 것도 중요하다고 생각합니다. 이러한 협업은 같은 전공을 가진 사람들끼리만 하는 것이 아니라, 다분야의 사람들과 직접 부딪히며 늘려야 한다고 생각합니다. 경디공 사람들과 함께 공모전에 참가하거나, 내부 활동들을 하면서 커뮤니케이션 능력을 기르고 싶습니다. 세 번째로, 인천에서 네트워크를 많이 꾸려가고 싶습니다. 인천에서 대학교에 다니고 있지만, 개인적으로 학교에 집중하기보다는 주로 외부 활동을 하고 있습니다. 그러다 보니, 인천지역의 친구도 많이 없고, 공대생의 특성상 친구들은 거의 공돌이뿐입니다. 다양한 분야의 멋진 재능을 가진 친구들을 경디공에서 만나고 싶습니다. 지금에서야 말할 수 있지만 세 번째 항목이 가장 큰 이유였다. 스타트업 활동과 소프트웨어 마에스트로 활동이 서울에서 이루어지고 있었으므로 왕복 2~3시간이 매일같이 사라지고 있었다. 따라서 이동시간을 최소한 줄이고 알찬 대학생 활동을 하고 싶기 때문에 지원했었다. 질문5: 무엇보다 협업과 적극적인 참여가 중요한 곳입니다. 협업할 때 있었던 트러블과 그것을 극복한 에피소드가 있다면? (Ex, 수업, 아르바이트 등) 없었다면 팀 내에 무임승차하는 인원이 있다면 어떻게 행동하시겠습니까?답변: 프리라이더가 팀원 중 있을 때, 크게 두 가지 경우가 있습니다.1.본인이 팀장으로 있을 경우, 2. 본인이 팀원으로 있을 경우.팀장으로 있는 경우라면, 팀원에게 역할을 정확히 할당합니다. 프리라이더가 프리라이딩을 할 수 있는 이유 중 하나는, 자신이 프리라이딩을 해도 팀에서 티가 나지 않기 때문입니다. 이를 방지하기 위해 팀원에게 프로젝트의 중요한 역할을 할당하고 이를 지속해서 관리하며 책임감을 느끼도록 유도합니다. 팀원으로 있는 경우라면, 우선 팀장에게 말합니다. 그렇게 해서 팀장이 팀원과 조율을 하게 되는데 만약 잘 안 된다면 팀원과 개인적으로 이야기해서 어떻게든 설득하는 편입니다. 현재 팀의 상황, 계속되는 팀원의 무임승차로 현재 팀에게 나타나고 있는 문제점, 이로 인한 프로젝트의 결과 등을 말해가며 설득합니다. 개인적인 경험으로, 정확한 역할 할당과 설득에도 불구하고 끝까지 프리라이딩을 하는 팀원이 있었는데 아주 곤혹스러웠습니다. 프리라이더를 태우고서라도 프로젝트는 성공적으로 완성되어야 합니다. 최악의 경우에는, 프리라이더를 제외하고 나머지 팀원들의 결속과 책임감을 유도하여 프로젝트를 완성하려고 노력하는 편입니다. 프리라이더에 대한 해결책 질문은 다른 기업 자소서나 동아리 자소서에서도 많이 적어봤고, 실제로도 겪어봤던 항목이었다. 따라서 솔직한 내 생각과 팀장으로서의 나의 경험을 풀어내었다. 면접 평가면접은 경인 지역 대학생 활동답게 인천대에서 이루어졌다. 집에서 인천대까지는 약 40분 정도 소요되었기 때문에 미리 집에서 출발하여 지각하지 않고 도착하였다. 면접평가는 크게 두 단계로 진행되었다. 하나는 나와 같은 면접자 1명이 팀원으로, 랜덤주제가 적힌 종이쪽지를 2개 뽑는다. 그리고 팀원과 상의하여 그 2가지 주제를 합친 아이템에 대하여 5분간 피칭하는 방식이다. 이전에는 경험해 보지 못한 새로운 방식이었다. 내 경우에는 환경 + 유아의 주제를 골랐다. 아이디어에 대하여 논의할 제한된 시간이 10분~15분밖에 되지 않아서 빠르게 가닥을 잡고 나갔다. 아이들의 옷은 아이가 금방 자라서 금방 쓸모없어지는 경우가 많다. 따라서 아이들 옷을 서로 포인트를 가지고 서로 물물교환을 하는 앱을 빠르게 기획하여 피칭하였다. 활동첫 활동은 자신의 학과에서 어떤 것을 배우는지 소개하는 시간이었다. 내 경우는 “컴퓨터공학” 이란 학과에서 처음에는 “컴퓨터 공학 입문” 과목부터 시작해 구조, 알고리즘, 프로그래밍 등 여러 가지를 배우며 진로로는 어느 방면이 있다 정도로 소개했었다. 처음에는 사실 3기밖에 안 된 활동이라 탄탄한 커리큘럼이나 여러 가지 시스템을 기대하지는 않았지만, 동아리가 매우 난해하였다…. 왜냐하면, 한가지 전공도 아니고 경상, 디자인, 공학이 서로 섞여 있을 뿐만 아니라 경상 쪽은 경영, 경제, 무역학부의 학생이 있었고 디자인도 영상 디자인, 도시 디자인, 제품 디자인의 분야가 있고 공학도 전기, 전자, 컴퓨터, 인프라, 재료, 화학, 보안, 컴퓨터 등 매우 다양한 전공의 학생들이 모여있었기 때문에 프로젝트를 하더라도 서로 무엇을 해야 하는지 모르는 경우가 다반사였다. 하지만 점차 매주 진행하는 전공&amp;취미 스터디를 진행하면서 서로에 대해서 적응하기 시작했다. 커뮤니케이션이 부족한 공대 친구들은 PPT와 팀플레이 지식이 많은 경상 친구들에게 대화하는 방법을 습득했고, 경상 친구들은 기술에 관해서 관심을 가지기 시작했다. 디자인 친구들은 자신들이 상상하던 디자인이 기술적으로는 어떤 문제점이나 실제로 제품으로 판매했을 때는 어떤 이득과 손해가 있을지를 서로가 서로에게 배워나가는 장이 되었다. 지금 다시 후기를 적다 보니 조금 부끄러운 순간도 있었다. 동아리 시작 초기에 갈피를 못 잡아갈 때쯤 많은 인원이 동아리를 나갔다. 아무래도 갈피를 못 잡고 있는 이 동아리를 계속 해야 하는지 이유를 알지 못하는 학생들이 많이 나갔던 것 같다. 나 역시도 나갈지 말지 고민을 하던 그 학생들 중 하나였다. 내가 나가지 않았던 건, 그냥 중간에 포기하고 소위 말하는 “탈주”를 하기 싫었다. 그래서 이 동아리에 의미 부여를 하기 시작했다. 왜 내가 지원했고, 뭘 내가 이 동아리에서 얻어갈 수 있는지를 다시 돌이켜 보니 중간에 그만두기보다는 끝까지 해내야겠다는 생각이 들었다. 그리고 팀의 프로젝트에서 팀장의역할 맡았다. 내가 스스로 도망가지 못하도록 묶어놓는 역할이 되었으므로 책임감과 참여도를 올릴 수 있었다. 전시 전공융합 동아리에서는 마지막 끝나기 전 최종 활동으로 전시 프로젝트를 준비한다. 회비나 지원금을 모아서 전시장소를 대관, 컨셉이나 주제를 잡고 자기들이 원하는 프로젝트로 일반인들에게 오픈되는 전시를 진행한다. 이번 프로젝트의 전시 주제는 우리를 빛나게 하는 것들 이었다. 우리 팀에는 운영진이 각 전공이 잘 섞이도록 팀이 짜여있게 되었다. 경영학과 학생, 디자인학부 학생, 컴퓨터공학 학생 2명, 재료공학과 학생 1명으로 팀이 구성되었다. 그중에서 컴퓨터 하는 친구와 경영을 공부하는 친구는 게임을 만들고 싶다고 해서 팀을 작게 “바이오 피드백 게임”으로 분할했다. 그리고 남은 디자인, 컴퓨터(me), 재료공학 학생은 “심박 시각화” 프로젝트를 시작하기로 했다. 우리가 정한 시놉시스는 다음과 같다. 인간의 감정이란 눈으로 보이지 않는다. 그 때문에 사람들은 서로의 감정을 몸짓, 행동, 말 등으로 표현하며 이해하려고 한다.우리는 이런 감정의 스스로 표현의 매체가 시각적으로 눈으로 표현되면 좋겠다는 생각을 했다. 인간의 감정은 심박 수를 통하여 드러난다. 화나거나 흥분할 땐 빨라지고, 차분한 상태에서는 정적인 심박 수를 유지한다. 우리는 감정을 심장박동과 같이 여기고 시각, 청각, 촉각적으로 느낄 수 있도록 작품을 구상하였다. 이렇게 탄생한 작품은 다음과 같다. 보다 더 기술적인 내용은 추후 블로그 글로 설명할 것이다. 심박 시각화 전시회 walk-through 후기심심함에서 시작했으나 끝날 때는 많은 것을 느꼈다. SW Maestro 과정처럼 엄격한 심사기준에 맞춰서 들어오는 활동이 아니기도 하거니와 한가지(컴퓨터) 전공을 가진 친구를 만나는 게 아니라 정말 다양한 전공의 친구들을 만날 수 있다는 게 가장 큰 장점이었다. 처음 활동을 시작할 때는 이렇게 많은 전공의 학생들을 모아두니 어디에 쓰려나…. 걱정이 많았다. 아직 학생이기 때문에 각 분야에 전문성을 출중하게 가지고 있는 것도 아니기 때문에 정체성이 모호했다. 하지만 점차 활동을 진행함에 따라서 여러 가지 크고 작은 프로젝트와 스터디를 진행하니 컴퓨터 공부만 했을 때보다 넓은 시야가 보이게 되었다. 경상 입장에서는, 디자인 입장에서는, 그리고 또 다른 공학 입장에서는 이라는 서로 다른 피드백들을 주고받으니 더욱 아이디어가 creative 해지는 것을 많이 느꼈다. 이 활동이 끝났을 때 다시 나에게 한번 물어봤다. 1년 전 이 활동을 하기 전보다 나는 성장했을까?물론이다. 라고 대답할 수 있을 것 같다. 내가 보지 못했던 새로운 시야를 열어준 경디공을 후배들에게도 추천해주고 싶다라는 이야기로 글을 마친다.","categories":[{"name":"Retrospect","slug":"retrospect","permalink":"https://philographer.github.io/categories/retrospect/"},{"name":"Personal","slug":"retrospect/personal","permalink":"https://philographer.github.io/categories/retrospect/personal/"}],"tags":[{"name":"경디공","slug":"경디공","permalink":"https://philographer.github.io/tags/경디공/"}]},{"title":"Talent X 1기 합격 후기","slug":"talentx","date":"2018-03-06T01:32:22.000Z","updated":"2018-03-08T05:00:57.712Z","comments":true,"path":"2018/03/06/talentx/","link":"","permalink":"https://philographer.github.io/2018/03/06/talentx/","excerpt":"","text":"개요어느덧 이런저런 활동과 학생 생활을 지나 보내니 4학년이 되었다. 어느새 주변 사람들은 나에게 “취준생”이란 타이틀을 부여하기 시작했다. 듣다 보니 나도 “아…. 이제 슬슬 취업준비 해야지”라는 생각도 들었다. 서류평가사실 대학교 생활을 하면서 무언가…. 고통스럽게 감내하기보다는 내가 하고 싶었던 활동들을 찾아 나섰다. 그래서 더욱 돈이 되지 않고, 대학생들만 할 수 있는 활동들에 치중해서 활동했던 것 같다. 물론 재미도 좋지만 스스로 생각하기에도 이번 년 가장 중요한 목표는 취업이라고 결론을 내렸다. 이러던 와중에 Facebook에서 Talent X 의 1기를 모집한다는 소식을 보게 되었다. Logo를 보다 보니 무척 어디선가 본듯한 느낌이 들었다. 바로 Team Mondrian에 재직했을 때 스타트업 다국적 조직역량 강화 프로그램에 선정되어서 TalentX. Traitify 라는 프로그램의 주관으로 보였다. Traitify는 자신이 선호하는 그림을 선택하다 보면 자신의 성향을 알려주는 성격검사 같은 사이트로 기억한다. UI/UX가 매우 매끄러워서 재미있다는 경험을 남겨줬던 것으로 기억한다. 홈페이지를 자세히 살펴보니 인재 기획사라는 표현이 눈에 띄었다. 나도 여기 소속되면 연예 기획사 연습생 이 되는 건가!홈페이지를 죽 둘러보니 합격하면 무료로 취업 관련 컨설팅을 제공하는 것 같았다. 자소서 첨삭, 모의 면접 이런 것들은 학교 취업준비센터에서도 해줄 수 있는 항목이라 별로 눈에 띄지 않았는데 퍼스널 브랜딩, 기업 인터뷰 연결 , 개인 프로필 리디자인 이라는 항목이 눈에 띄어서 지원하게 되었다. 지원서를 작성하니 크게 다른 항목은 없었고, 개인의 스킬지수 평가와 포트폴리오(Github). 그리고 대외활동 &amp; 인턴 경험을 묻는 항목도 있었다. 꽤 대외활동치고는 빡빡하게 정보를 입력받는 게 신기했다. 그리고 개인의 역량지수(조직 적응, 팀워크, 우선 순위화) 등을 받는 항목도 있었다. 모든 항목을 채워서 지원을 완료하고, 회사의 뒷조사(?)를 시작했다. 왜 이 회사는 무료로 나 같은 취준생에게 컨설팅해준다는 것일까? 무슨 관계인지는 모르겠지만 내가 예전 개인성향검사를 했던 traitify와 관련이 있는 회사이고 한국 소개 홈페이지를 보니 커리어 컨설팅을 해주는 회사로 보였다. 결국에 취업 준비생들과 기업들을 연결해 주어서 커미션을 받는 헤드헌팅 하는 회사로 느껴졌다. 조금 다른 점은 기존의 개인 헤드헌터가 personal 하게 연락을 돌리는 것이 아니라 개인 성향 검사, 데이터 에 기반을 둔 기업 추천이 차별점으로 보였다. 서류평가 결과 퇴사 전 해야 할 일들을 정신없이 마무리하던 도중에 서류합격 메일을 받았다. 추가로 서류에 합격했으니 면접날을 정했는데 참석이 가능하냐는 유선상 연락도 함께 받았다. 2월 초에 재직하고 있던 회사의 퇴사 준비로 워낙 바빴기 때문에 따로 면접준비를 해서 면접에 가야겠다는 생각은 하지 못했다. 인성 면접 1분 자기소개를 해주세요. 짧은 자기소개를 하라고 어느 정도 예상은 했는데 1분(30초였는지 기억이 나지 않는다.) 자기소개를 하라고 하는데 시간제한을 주셔서 조금 당황했다. 그렇지만 이름과 학교, 주로 했던 활동들(시빅해킹, 문제해결, 커뮤니티)에 대해서 간략히 설명하며 이야기를 풀어나갔다. 자신이 활동했던 활동들에 대해서 자세히 설명해주세요. CODE FOR INCHEON 이란 시빅해킹 커뮤니티에서 Organizer로 활동했던 경험과 AWSKRUG - AWS 한국사용자모임 공개 그룹 에서 활동했던 경험을 주로 풀어서 설명하였다. 커뮤니티와 사회 문제해결이라는 키워드로 화제를 풀어나갔다. 자신이 가장 관심 있는 분야에 관해서 설명해주세요. 가장 관심 있는 분야는 Back-end Cloud &amp; Infra라고 설명했다. 다음에 왜 Front-end 경력이 대부분인데 왜 Back-End &amp; Infra 에 관심이 많냐고 물어봤을 때 스타트업에 있을 때 대규모 인프라를 운영해본 경험이 없어서 그 부분이 하고 싶다고 대답했다. 기술면접 프로젝트를 진행할 때 사용해본 방법론에 관해서 설명해주세요SW Maestro 에서 프로젝트를 진행할 때 멘토님의 지도하에 Agile Scrum 방법론을 사용해 보았고 실제로 이 방법론을 통해 프로젝트를 진행하며 느꼈던 장단점에 대하여 설명했다. 애자일 스크럼은 내가 느껴보기에 방법론보다는 개발 문화에 가까웠고 DNS 스푸핑이란 무엇인가?DNS의 개념과 DNS 스니핑은 알지만, 스푸핑은 알지 못해서 솔직히 바로 모른다고 답변했다. 면접이 끝나고 질문시간에 추가로 이 주제에 관해서 물어보았다. 자신이 가장 자신 있는 기술에 관해서 설명해주세요.아무래도 스타트업에 재직 중인 기간동안 웹&amp;앱 프론트를 했으니 JS를 말로 풀어내는 데 유리하다고 생각했다. JS의 역사와 변천 과정, 현재의 생태계에 관해서 설명했다.그리고 React와 React Native 를 Production Level 까지 다루어 보았으니 프론트엔드 라이브러리 위주로 설명했다. 내 생각대로 React와 Jquery의 차이부터 이야기를 쭉 끌어가다가 내 앞의 면접관이 4명 모두 기술진이 아니라 인사, 경영도 함께 있다는 것을 깨달음과 동시에 이야기를 점차 마무리 지었다. 페이퍼 코딩테스트개략적으로 설명하자면 영어로 된 문제를 손 코딩으로 시험을 치렀다. 문제는 여느 judge 사이트에서 쉽게 볼 수 있는 문제로 특별한 알고리즘이나 전형적인 알고리즘의 주제에 속했던 것은 아니고, 미리 정해진 기능을 수행하는 간단한 function을 만들라고 하는 느낌의 string 문제였다.영문이지만 이해하기 쉬웠고 문제도 난도가 높지 않았다. 그런데…. 주어진 문제를 결론적으로 풀지 못했다. 문제도 이해가 갔고, 어찌 도는지도 알겠는데 내가 생각한 알고리즘으로는 Input을 넣었을 때 문제에 주어지는 output이 나오지 않았다. 중간중간 궁금한 걸 물어보라고 하시길래 내가 생각하는 알고리즘을 물어봤지만 결국 답을 내지 못했다. 추후에 어떤 방식으로 푸냐고 물었던 질문에는 내가 생각하는 알고리즘을 설명하다 보니 작게 주의사항, ETC 에 쓰여 있는 영어를 잘못 해석해서 답을 내지 못했던 것을 발견했다. 앞으로는 이런 세부사항을 놓치지 말아야겠다…! 질문시간모든 면접에서는 질문시간이 주어진다. 학교에서 스타트업 관련 수업을 들을 때 교수님이 이 질문시간을 잘 활용하는 것이 면접의 필살기라고 말해주셨다. 코딩테스트를 통과하지 못했는데 치명적인가?그렇게 크게 중요하지 않다. 푸는 방법을 보려고 하는 것이다. 기술면접 시간에 DNS 스푸핑이란 무엇인가를 대답 못 했는데 이것도 당락에 지장이 있는가?신입의 입장에서는 정확한 대답을 바라고 했던 질문은 아니다. 어려운 질문을 내고 어디까지 아는지를 보고 싶었다. 그런데 단칼에 모른다. 보다는 어느 정도 아는 부분 만큼은 대답하는 게 좋고 다음에 이 부분에 알아야겠다. 라고 대답하는 것이 좋다. 그리고 모르는 것을 모른다고 솔직히 말하는 것도 좋은 능력이라는 평가를 해주셨다. 그래서 바로 센스있게 집에 가서 블로그 포스팅으로 DNS 스푸핑에 대해서 올리겠다고 말했다! Traitify를 해봤는데 TalentX랑은 무슨 관련이 있는가?미국 실리콘밸리에 있을때 같이 co-work 한 회사이다. 성격 분석 &amp; 직업추천에 대하여 co-work 하였다. TalentX 1기를 모집하는데 전에 1, 2기수의 supporters 프로그램 모집을 봤다. 무슨 차이인가?앞서 모집했던 사람들은 blog, Facebook 등의 홍보 운영인력들이었다. 이번 모집이 진짜 자신들이 취업을 시키려는 첫 기수이다. 위에도 여러 잡다한, 아니면 내가 TalentX 회사나 프로그램에 대하여 미리 조사했던 것들에 대해서 질문들을 쏟아냈다. 왜냐면 코딩테스트와 기술면접의 질문을 잘 대답을 못 했기 때문에 질문시간에 점수를 따내려고 노력했다. 면접 결과사실 면접이 끝나고 집에 오면서 내내 코딩테스트에 합격하지 못해서 떨어졌다고 생각했다. 그리고 보안에 대해서도 개발자의 기본 보안지식 수준으로 공부해야겠다고 마음을 먹었다. 그렇게 불합격을 생각하고 있었는데…. 운이 좋게도 최종 합격하게 되었다! 앞으로의 내 커리어 컨설팅에 대해서 기대하며 아티클을 마친다.","categories":[{"name":"Retrospect","slug":"retrospect","permalink":"https://philographer.github.io/categories/retrospect/"},{"name":"Personal","slug":"retrospect/personal","permalink":"https://philographer.github.io/categories/retrospect/personal/"}],"tags":[{"name":"retrospect","slug":"retrospect","permalink":"https://philographer.github.io/tags/retrospect/"}]},{"title":".DS_Store 파일을 git에 포함시키지 않기","slug":"gitignore-ds-store","date":"2018-02-16T10:31:33.000Z","updated":"2018-03-08T05:00:57.707Z","comments":true,"path":"2018/02/16/gitignore-ds-store/","link":"","permalink":"https://philographer.github.io/2018/02/16/gitignore-ds-store/","excerpt":"","text":"문제점MacOS 환경에서 매번 프로젝트를 만들고 repository를 커밋할때 .gitignore를 제대로 만들지 않으면 .DS_Store가 딸려서 올라간다. 문득 쉬는 시간에 이걸 해결할 방법은 없는지 궁금해졌다. 해결방법이미 .DS_Store가 커밋되었다면 다음 명령어를 사용한다. .DS_Store를 찾아서 0번째 인자로 받고 이를 $ git rm하는 명령어이다.1find . -name .DS_Store -print0 | xargs -0 git rm --ignore-unmatch 모든 repository에서 제거하고 싶을 때는 다음의 명령어를 사용한다. DS_Store가 상위 폴더에 있을 때나 이름이 ._.DS_Store 일 때도 포함하지 않을 수 있다.12345$ echo \".DS_Store\" &gt;&gt; ~/.gitignore_global$ echo \"._.DS_Store\" &gt;&gt; ~/.gitignore_global$ echo \"**/.DS_Store\" &gt;&gt; ~/.gitignore_global$ echo \"**/._.DS_Store\" &gt;&gt; ~/.gitignore_global$ git config --global core.excludesfile ~/.gitignore_global 고찰조금 예상하기는 했지만 역시나 global에 .gitignore를 추가하는 명령어가 있었다. 생각해보면 $ git add를 할 때 current_directory의 .gitignore을 읽기도 하지만 ~/.gitignore_global도 읽는구나 예측해볼 수 있다. 출처: .gitignore all the .DS_Store files in every folder and subfolder - Stack Overflow검색어: ignore ds_store global","categories":[{"name":"tip","slug":"tip","permalink":"https://philographer.github.io/categories/tip/"}],"tags":[{"name":"-tip","slug":"tip","permalink":"https://philographer.github.io/tags/tip/"}]},{"title":"Bash에서 Visual Studio Code 열기","slug":"vscode-open-bash","date":"2018-02-15T14:56:26.000Z","updated":"2018-03-08T05:00:57.723Z","comments":true,"path":"2018/02/15/vscode-open-bash/","link":"","permalink":"https://philographer.github.io/2018/02/15/vscode-open-bash/","excerpt":"","text":"개요원래 본인은 Jetbrains의 열렬한 추종자이므로 Webstorm을 애정하면서 쓰고있다. 그런데 요즘따라 Visual Studio Code 가 점점 좋아지고 있다.왜냐하면 VScode로 간간히 편집할 일이 있다. 예를들자면 매우 큰 csv파일을 열어볼때나 Line수가 매우 긴 프로젝트의 경우는 가벼운 VScode가 더 간편하기 때문이다. 문제점간단한 JS파일을 수정하다가, 문득 Bash에서 vs code project을 열 수 있으면 무척 편하지 않을까? 생각했다. 해결방법 VS Code에서 Command + Shift + P Shell Command : Install code in PATH 검색 후 선택 bash에서 $ code . 를 타이핑하면 현재 경로를 VScode가 열어준다. 고찰그렇다면 Webstorm에도 이런 기능이 있지 않을까? 이걸 모르고 살았다니… macos - Run / Open VSCode from Mac Terminal - Stack Overflow검색 키워드: vscode bash open","categories":[{"name":"tip","slug":"tip","permalink":"https://philographer.github.io/categories/tip/"}],"tags":[{"name":"tip","slug":"tip","permalink":"https://philographer.github.io/tags/tip/"}]},{"title":"Fastlane, CircleCI를 이용하여 React Native DevOps 도입기 (4)","slug":"circleci-rn4","date":"2018-02-15T10:38:28.000Z","updated":"2018-03-08T05:00:57.706Z","comments":true,"path":"2018/02/15/circleci-rn4/","link":"","permalink":"https://philographer.github.io/2018/02/15/circleci-rn4/","excerpt":"","text":"1. 개요우리는 지금까지 Fastlane, CircleCI를 이용하여 React Native DevOps 도입기 (1) Fastlane, CircleCI를 이용하여 React Native DevOps 도입기 (2) Fastlane, CircleCI를 이용하여 React Native DevOps 도입기 (3)을 거쳐서 iOS, Android 모두 구성을 마쳤다. 이제 앞에서 진행했던 JS Test-&gt; Native Test -&gt; Beta Test Deploy 과정을 모두 자동화해보자. 2. package.json에 Script 추가하기DevOpsForRN/package.json에 beta script를 추가되어 있는지 확인한다.12345\"scripts\": &#123; \"start\": \"node node_modules/react-native/local-cli/cli.js start\", \"test\": \"jest\", \"beta\": \"cd ios &amp;&amp; fastlane increase_build_number_and_push_to_beta\" # 변경 &#125;, 3. Fastlane Slack Notify 추가하기모든 작업이 완료되었을 때 Slack으로 Notification을 받기 위한 설정은 다음과 같다.DevOpsForRN/ios/fastlane/Fastfile 파일의 beta lane 에 slack 부분을 추가한다.slack(슬랙), incoming webhooks 을 사용해보자. - seotory의 블로그 아티클이 도움이 될 수 있다.123456789101112 lane :beta do desc &quot;TesfFlight for IOS&quot; ... ... slack( slack_url: &quot;https://hooks.slack.com/services/*******/********/******************&quot; channel: &quot;dev&quot;, message: &quot;Successfully uploaded a fastlane beta release&quot; ) end ... end 4. 작성한 내용 검증하기위 설정이 올바르게 되어있으면 다음의 커맨드를 입력하였을 때 ios의 빌드 넘버를 변경하고 git의 beta branch에 변경내용을 push한다.1$ npm run deploy 우리가 설정한 테스트 -&gt; 빌드 -&gt; 베타 배포의 과정이 완료되었다면 다음과 같은 화면을 볼 수 있다. ETC: S3 Static Hosting으로 보여주기s3-bucket-listing 플러그인을 이용하면 S3 대시보드에 직접 접속하지 않아도 Static Website Hosting처럼 S3의 내용을 표시할 수 있다.Demo: S3 Bucket Listing Generator ETC: Build Error혹시나 CircleCI에서 다음과 같은 에러로 빌드가 되지 않는 경우도 있다.12345678bundle: Done writing bundle output:app:bundleReleaseJsAndAssets FAILEDFAILURE: Build failed with an exception.* What went wrong:Execution failed for task ':app:bundleReleaseJsAndAssets'.&gt; Process 'command 'node'' finished with non-zero exit value 137 해결방법: 이유는 모르겠지만 첫 번들링이 실행이 안되는 경우도 있는 것 같다. 해결방법은 첫 번들링을 로컬에서 실행해주고 remote로 올려서 CircleCI가 overwrite하게 하는 방법이다.123456$ mkdir android/app/src/main/assets$ react-native bundle --platform android --dev false --entry-file index.js --bundle-output android/app/src/main/assets/index.android.bundle --assets-dest android/app/src/main/res/$ git add --all$ git commit -m 'Added bundle.android.js'$ git push origin master$ npm run beta Ref: https://github.com/facebook/react-native/issues/11696 자동화된 과정들 정리React Naitve의 Beta Testing을 자동화 하기 위하여 지금까지 작성한 내용은 다음과 같다. $ npm run deploy 커맨드를 입력한다 (Developer) IOS Project의 Build Number를 1 증가시킨다. (Fastlane local) Git의 beta Branch에 코드를 push한다. (Fastlane local) Github이 Webhook을 통해 CircleCI가 beta Branch에 코드가 커밋된 사실을 알아챈다. (Github) CircleCI가 beta Branch에 대하여 JS Test -&gt; ios, android 각각 빌드 -&gt; Native 테스트 -&gt; 배포의 과정을 실행한다. (CircleCI) ios의 경우 미리 지정한 사용자에게 TestFlight가 전송된다. (Fasltnae on CircleCI) Android의 경우 미리 지정한 S3 Bucket에 Release APK가 업로드된다. (Fasltnae on CircleCI) Slack Message를 미리 지정한 채널에 전송한다. (Fasltnae on CircleCI)따라서 일련의 과정을 그려보면 다음과 동일하다. 데모 프로젝트아래 Github에는 지금까지 적용했던 모든 사항들이 적용되어 있다. 혹시 세부적인 세팅이 궁금하다면 참조하자.https://github.com/philographer/DevOpsForRN 마무리하며지금까지 FaceBook의 하이브리드 앱 프레임워크인 React Native의 CI/CD Flow를 구축해 보았다. 이용자의 Needs가 점점 다양해지면서 비즈니스 또한 그 기대에 부응하기 위하여 발 빠르게 움직여야 하는 시대가 되었다. 이에 따라서 개발자들 또한 여러 가지 Unit/integration test, beta test, build 들을 자동화하지 않고는 고객들의 요구사항을 맞출 수 없는 상황에 이르렀다. 보다 품질이 보증되는 소프트웨어를 만들기 위한 노력은 소프트웨어 생태계가 발전하면서 만약, 팀의 누군가 한 명이 자발적으로 이런 DevOps에 관심을 가지고 자동화를 한 번만 잘 적용해 놓는다면 팀 모두의 생산성과 코드의 품질을 높일 수 있다. 이제는 DevOps에 대하여 깊이 있게 알지 못하더라도, 여러 가지 좋은 서비스가 시장에 많이 나와 있으므로 작은 비용의 유료 Plan이나 Open Source 잘 조합하여 적용한다면 팀에게도 생산성과 코드 품질에 큰 도움이 되지 않을까 생각한다.","categories":[{"name":"DevOps","slug":"devops","permalink":"https://philographer.github.io/categories/devops/"}],"tags":[{"name":"DevOps","slug":"devops","permalink":"https://philographer.github.io/tags/devops/"}]},{"title":"Fastlane, CircleCI를 이용하여 React Native DevOps 도입기 (3)","slug":"circleci-rn3","date":"2018-02-15T10:38:26.000Z","updated":"2018-03-08T05:00:57.705Z","comments":true,"path":"2018/02/15/circleci-rn3/","link":"","permalink":"https://philographer.github.io/2018/02/15/circleci-rn3/","excerpt":"","text":"1. React Native 프로젝트에서 Fastlane을 사용하기(Android 편)이제 ios를 모두 구성하였으니, android를 구성해보자. Android의 경우는 beta 배포로서 Fabric Beta도 가능하지만, 이 가이드에서는 간편함을 위해 AWS S3를 사용해본다. DevOpsForRN/android/fastlane/Fastfile 경로에 다음과 같이 작성한다.아래 내용은 Setup - fastlane docs 가이드를 따라 하면 동일하게 구성할 수 있다. 1234567891011121314151617181920212223242526272829303132333435# This file contains the fastlane.tools configuration# You can find the documentation at https://docs.fastlane.tools## For a list of all available actions, check out## https://docs.fastlane.tools/actions## Uncomment the line if you want fastlane to automatically update itself# update_fastlanedefault_platform(:android)platform :android do desc &quot;Runs all the tests&quot; lane :test do gradle(task: &quot;test&quot;, flags: &quot;--no-daemon -x bundleReleaseJsAndAssets&quot;) end desc &quot;Submit a new Beta Build to Crashlytics Beta&quot; lane :beta do gradle(task: &quot;assembleRelease&quot;, flags: &quot;--no-daemon -x bundleReleaseJsAndAssets&quot;) # crashlytics # sh &quot;your_script.sh&quot; # You can also use other beta testing services here end desc &quot;Deploy a new version to the Google Play&quot; lane :deploy do gradle(task: &quot;assembleRelease&quot;) upload_to_play_store endend 마찬가지로 DevOpsForRN/android/fastlane/Appfile 의 경로에도 다음과 같이 작성한다. 이 부분도 fastlane android 공식 가이드 문서에 따르면 동일하다. 12json_key_file &quot;&quot; # Path to the json secret file - Follow https://docs.fastlane.tools/actions/supply/#setup to get onepackage_name &quot;com.devopsforrn&quot; # e.g. com.krausefx.app Android의 경우에는 release apk를 만드는데 Code Signing 필요하다. 다음의 링크를 참조하여 Code Signing을 진행한다.android - How to create a release signed apk file using Gradle? - Stack Overflow 2. Gradle 시간별로 빌드추후에, 빌드된 apk가 S3에 쌓이는데, 모두 같은 이름이라면 덮어씌워 질 수 있으므로 Gradle이 빌드되었을때 apk의 시간대별로 생성되도록 하면 구별하는데 동무을 줄 수 있다. 이와같은 기능을 사용하려면 다음의 내용을 따라해보자. DevOpsForRN/app/build.gradle 파일의 내용을 다음의 내용으로 수정한다. 1234567891011121314151617181920212223......applicationVariants.all &#123; variant -&gt; variant.outputs.each &#123; output -&gt; // For each separate APK per architecture, set a unique version code as described here: // http://tools.android.com/tech-docs/new-build-system/user-guide/apk-splits def versionCodes = [&quot;armeabi-v7a&quot;:1, &quot;x86&quot;:2] def abi = output.getFilter(OutputFile.ABI) if (abi != null) &#123; // null for the universal-debug, universal-release variants output.versionCodeOverride = versionCodes.get(abi) * 1048576 + defaultConfig.versionCode &#125; // 시간별로 빌드하는 부분을 추가 def formattedDate = new Date().format(&apos;yyyy-MM-dd-HH-mm-ss&apos;) def newName = output.outputFile.name newName = newName.replace(&quot;-release&quot;, &quot;-release&quot; + formattedDate) output.outputFile = new File(output.outputFile.parent, newName) &#125; &#125;...... 위와같이 작성하면 ./gradlew assembleRelease 와 같은 커맨드를 입력했을때app-release2018-02-15-12-26-58-signed.apk 의 파일을 얻을 수 있으므로 시간대별로 apk를 언제 빌드했는지 알 수 있다. 3. AWS의 devops-react-native Bucket 만들기다음의 문서를 따라하여 devops-react-native라는 이름의 버킷을 만든다.https://docs.aws.amazon.com/ko_kr/AmazonS3/latest/gsg/CreatingABucket.html 4. AWS CLI 설치후 aws s3 sync기본적으로 CircleCI가 실행하는 Docker Image인 circleci/node:8 에는 awscli가 설치되어 있지 않다. 따라서 아래 내용 중 beta-deploy-android에 반드시 awscli를 설치하는 내용이 들어가야 한다. DevOpsForRN/.circleci/config.yml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117# .circleci/config.yml# To Validate your config.yml then use this cli.# `$ circleci config validate -c .circleci/config.yml`version: 2jobs: build: working_directory: ~/project docker: - image: circleci/node:8 steps: - checkout - run: yarn - run: yarn run test - persist_to_workspace: root: ~/project paths: - node_modules - store_test_results: path: ~/project/junit.xml beta-deploy-ios: working_directory: ~/project/ios macos: xcode: &quot;9.0&quot; steps: - checkout: path: ~/project - attach_workspace: at: ~/project - run: bundle update fastlane - run: bundle exec fastlane beta beta-deploy-android: working_directory: ~/project/android docker: - image: circleci/android:api-27-node8-alpha steps: - checkout: path: ~/project - attach_workspace: at: ~/project - run: bundle update fastlane - run: bundle exec fastlane beta - run: sudo apt-get update &amp;&amp; sudo apt-get install -y awscli # AWS CLI Install - run: aws s3 sync app/build/outputs s3://devops-react-native/ android: working_directory: ~/project/android docker: - image: circleci/android:api-27-node8-alpha steps: - checkout: path: ~/project - attach_workspace: at: ~/project - run: bundle install --path vendor/bundle - persist_to_workspace: root: ~/project paths: - android - run: bundle exec fastlane test - store_test_results: path: ~/project/android/reports ios: macos: xcode: &quot;9.0&quot; working_directory: ~/project/ios environment: FL_OUTPUT_DIR: ~/project/output shell: /bin/bash --login -o pipefail steps: - checkout: path: ~/project - run: name: Set Ruby Version command: echo &quot;ruby-2.4&quot; &gt; ~/.ruby-version # Not using a workspace here as Node and Yarn versions # differ between the macOS image and the Docker containers above. - run: yarn - run: bundle install --path vendor/bundle - persist_to_workspace: root: ~/project paths: - ios - run: bundle exec fastlane test - store_artifacts: path: ~/project/output - store_test_results: path: ~/project/output/scanworkflows: version: 2 node-android-ios: jobs: - build - android: requires: - build - beta-deploy-android: filters: branches: only: - beta requires: - android - ios: requires: - build - beta-deploy-ios: filters: branches: only: - beta requires: - ios 5. CircleCI Env Variable AWS Permisson 설정AWS CLI가 실행되기 위해서는 권한과 인증이 필요하다.AWS IAM 의 Access-Key와 Secret-Key를 아래와 같이 설정한다. AWS Region 설정AWS CLI가 실행되기 위해서는 기본적으로 region이 설정되어 있어야 한다.AWS_DEFAULT_REGION를 ap-northeast-2로 설정이 필요하다. 6. Next Fastlane, CircleCI를 이용하여 React Native DevOps 도입기 (4)","categories":[{"name":"DevOps","slug":"devops","permalink":"https://philographer.github.io/categories/devops/"}],"tags":[{"name":"DevOps","slug":"devops","permalink":"https://philographer.github.io/tags/devops/"}]},{"title":"Fastlane, CircleCI를 이용하여 React Native DevOps 도입기 (2)","slug":"circleci-rn2","date":"2018-02-15T10:38:24.000Z","updated":"2018-03-08T05:00:57.705Z","comments":true,"path":"2018/02/15/circleci-rn2/","link":"","permalink":"https://philographer.github.io/2018/02/15/circleci-rn2/","excerpt":"","text":"React Native 프로젝트에서 Fastlane을 사용하기 (IOS편) 아래 내용은 Getting Started · React Native 에 따라서 기본 환경을 구성했다는 전제 하에 진행됩니다. React Native Project 만들기 우선 샘플 프로젝트를 하나 만들도록 한다. 주의할 점은 create-react-native-app로 만들지 말아야 한다는 것이다. crna로 프로젝트를 만들면 expo로 동작하는 데 이용하면, 네이티브 프로젝트를 만들고 Native Code를 Testing 하는 것이 불가능하다. 아래 명령어로, project를 init한다.12$ react-native init DevOpsForRN # Native Project Initialize$ cd DevOpsForRN Fastlane을 Native Project Directory 에서 사용하기 아래 서술하는 내용은 공식 문서와 동일하다.IOS Setup - fastlane docsAndroid Setup - fastlane docs 우선 fastlane을 사용하기 위해서는 글로벌로 설치를 해야 한다. 123456789# Using RubyGems$ sudo gem install fastlane -NV$ sudo gem install bundler# 위 명령어가 실행 불가능 하다면 대안으로 아래 명령어를 실행한다.# Alternatively using Homebrew$ brew cask install fastlane$ sudo gem install bundler 첫 번째로 ios 폴더에 들어가서 초기화를 진행한다. 12$ cd ios # DevOpsForRN/ios$ fastlane init # 초기화 다음과 같이 어느 걸 하고 싶으냐고 나올 텐데 우리는 여러 가지 일들을 manual하고 싶으니 4번을 선택한다. 123456[13:48:34]: What would you like to use fastlane for?1. 📸 Automate screenshots2. 👩‍✈️ Automate beta distribution to TestFlight3. 🚀 Automate App Store distribution4. 🛠 Manual setup - manually setup your project to automate$ 4 명령어를 치고나면 DevOpsForRN/ios/fastlane/Appfile -&gt; 프로젝트나 account config(app_identifier, apple_id) DevOpsForRN/ios/fastlane/Fastfile -&gt; 실제 돌릴 명령어들을 정의 DevOpsForRN /ios/fastlane/Readme -&gt; 설명서, lane을 추가할때 자동으로 변경됨 DevOpsForRN /ios/fastlane/report.xml -&gt; fastlane 명령어를 돌릴때마다 변경되는 report 문서 실제로는 Appfile 은 정해진 계정, bundle identifier등을 맨 처음 한번만 정의하면 되고 Fastfile의 경우는 lane(작업들의 집합)을 정의할 때만 수정하면 된다.다음 빌드로 넘어가기 전에, 한 가지를 짚고 가야 한다. IOS 에서는 Code Signing이라는 개념이 굉장히 중요하다. Code Signing을 하지 않으면 Beta testing service에 올리거나, App Store에 Deploy 할 수 없다.Fastlane에는 3가지 signing 방법이 있다. Fastlane의 3가지 Signing Match -&gt; private key와 certificates를 git에 암호화하여 보관하고, 이를 가지고 signing하는 방법 Cert and Sigh -&gt; private key와 certificates를 local에서 가지고 있고, 이를 signing하는 방법 Manual -&gt; Apple Developer Portal에서 .p12, .cer, . mobileprovision을 직접 signing 하는 방법 1번 방법(Match)이 암호화된 인증서를 git에 올리는 게 다소 이상할 수 있지만 이 방식은 생각보다 안전하고, 새로운 팀 멤버가 들어올 경우 아니면 새로운 개발 장비를 세팅 할때도 쉽고 간편하므로 1번 방법**으로 선택했다.Code Signing에 대하여 더 자세히 이해하고 싶다면 Code Signing Guide for Teams 문서를 참조하자. Apple Developer Portal에서 Bundle Identifier 생성 Apple Developer Portal 에서 bundle identifier를 만든다 좌측 탭에서 Identifiers -&gt; App IDs 우측 상단에 + 버튼 클릭 앱 이름을 입력 com.teammondrian.devopsrn 와 같은 당신이 만들 identifier 입력 Done을 클릭 Fastlane 설정 파일 수정다음은 match - fastlane docs 을 따라 하는 내용과 동일하다 첫번째로 private key와 certificate를 담을 Github Repository를 새로 하나 생성한다. 주의할 점이 하나 있는데 민감한 정보를 담기 때문에 Private Repository 로 만들어야 한다. 1234567# DevOpsForRN/ios 폴더에서 진행한다.$ fastlane match init# 명령어를 입력하고, 방금전 만든 github-repo주소를 넣는다.$ fastlane match appstore# 애플 아이디와 비밀번호를 묻는다.# 이전에 만든 `com.teammondrian.devopsrn` 와 같은 identifier를 입력한다# passphrase -&gt; 파일들을 암호화할 비밀번호를 입력한다. (자기가 만들 비밀번호) 그러면 DevOpsForRN/ios/fastlane/Matchfile이 만들어 지는데, 다음과 동일하도록 수정한다. type &quot;development&quot; 를 type &quot;appstore&quot; 로 수정한다. app_identifier [&quot;com.teammondrian.devopsrn&quot;]에서 com.teammondrian.devopsrn 를 당신의 Bundle Identifier로 변경한 후 추가한다. username &quot;yoohoogun114@naver.com&quot; 와 같이 이메일을 당신의 Apple ID로 변경후 추가한다. 123456789git_url &quot;https://github.com/philographer/create-react-bootstrap-match.git&quot; # 당신이 생성한 git repo의 주소를 입력type &quot;appstore&quot; # 기본값은 development이지만, appstore로 수정한다. appstore, adhoc, enterprise or development가 될 수 있다.app_identifier [&quot;com.teammondrian.devopsrn&quot;] # 당신이 생성한 bundle identifier 입력username &quot;yoohoogun114@naver.com&quot; # 당신의 apple id로 수정# For all available options run `fastlane match --help`# Remove the # in the beginning of the line to enable the other options DevOpsForRN/ios/fastlane/Fastfile 도 파일이 다음과 동일하도록 수정한다. 아래 부분에서, &quot;com.teammondrian.devopsrn” 로 되어 있는 부분을 당신의 Bundle Identifier로 변경한다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849# This file contains the fastlane.tools configuration# You can find the documentation at https://docs.fastlane.tools## For a list of all available actions, check out## https://docs.fastlane.tools/actions## Uncomment the line if you want fastlane to automatically update itself# update_fastlanedefault_platform(:ios)platform :ios do desc \"Build and run tests\" lane :test do scan(scheme: \"DevOpsForRN\") end lane :beta do desc \"TesfFlight for IOS\" # Circle CI does not create new code signing certificates or provisioning profiles. sync_code_signing(type: \"appstore\", readonly: true, app_identifier: \"com.teammondrian.devopsrn\") # Bundle Identifier를 아까 만든 값으로 치환한다. # see code signing guide for more information, readonly because of CircleCI build_app(scheme: \"DevOpsForRN\") upload_to_testflight(skip_waiting_for_build_processing: true) # slack( # slack_url: \"https://hooks.slack.com/services/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\" # channel: \"dev\", # message: \"Successfully uploaded a fastlane beta release\" # ) endendlane :increase_build_number_and_push_to_beta do |values| # Increment the build number (not the version number) # Providing the xcodeproj is optional increment_build_number(xcodeproj: \"DevOpsForRN.xcodeproj\") # Commit the version bump commit_version_bump(xcodeproj: \"DevOpsForRN.xcodeproj\", force: true) # Add a git tag for this build. This will automatically # use an appropriate git tag name add_git_tag # Push the new commit and tag back to your git remote push_to_git_remote( remote_branch: \"beta\", # optional, default is set to local_branch force: true, # optional, default: false )end DevOpsForRN/ios/fastlane/Appfile 도 파일이 다음과 동일하도록 수정한다. app_identifier &quot;com.teammondrian.com&quot; 에서 com.teammondrian.com 부분을 당신의 Bundle Identifier 로 변경 후 추가한다. apple_id &quot;yoohoogun114@naver.com&quot; 와 같이 이메일을 당신의 Apple ID로 변경후 추가한다. 12345app_identifier &quot;com.teammondrian.com&quot; # The bundle identifier of your appapple_id &quot;yoohoogun114@naver.com&quot; # Your Apple email address# For more information about the Appfile, see:# https://docs.fastlane.tools/advanced/#appfile IOS의 경우, TestFlight에 올리려면 Image Assets 들을 올려야 한다. 테스트 용도이므로, Free vector icons 에서 자기가 원하는 이미지를 선택하고 Use Asset Catalog를 클릭하고 필요한 Aseets들을 집어넣는다.작성자는 Asset Catalog Creator Pro 를 사용하였지만, 인터넷에서 다른 Asset Generator를 사용해도 무관하다. Itunse-Connect 앱 등록 iTunes Connect에 로그인 나의 앱 -&gt; + 버튼 -&gt; 신규 앱 플랫폼 -&gt; ios 체크 나머지 내용들을 채우고, 번들 ID 는 이전에 Developer Portal에서 만든 Bundle Identifier를 선택한다. Fastlane on the CircleCI이제 대망의 CircleCI와 Fastlane을 연동할 차례이다. 이를 위해서는 Continuous Integration - fastlane docs 문서를 따라해보자. DevOpsForRN/ios/fastlane/Fastfile 경로에 다음과 같이 추가하자. 1234567891011# DevOpsForRN/ios/fastlane/Fastfile...platform :ios do before_all do setup_circle_ci end desc &quot;Build and run tests&quot;...end DevOpsForRN/ios/fastlane/Fastfile 의 완성된 내용은 다음과 같다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253# This file contains the fastlane.tools configuration# You can find the documentation at https://docs.fastlane.tools## For a list of all available actions, check out## https://docs.fastlane.tools/actions## Uncomment the line if you want fastlane to automatically update itself# update_fastlanedefault_platform(:ios)platform :ios do before_all do setup_circle_ci end desc &quot;Build and run tests&quot; lane :test do scan end lane :beta do desc &quot;TesfFlight for IOS&quot; # Circle CI does not create new code signing certificates or provisioning profiles. sync_code_signing(type: &quot;appstore&quot;, readonly: true, app_identifier: &quot;com.teammondrian.devopsrn&quot;) # Bundle Identifier를 아까 만든 값으로 치환한다. # see code signing guide for more information, readonly because of CircleCI build_app(scheme: &quot;DevOpsForRN&quot;) upload_to_testflight(skip_waiting_for_build_processing: true) # slack( # slack_url: &quot;https://hooks.slack.com/services/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&quot; # channel: &quot;dev&quot;, # message: &quot;Successfully uploaded a fastlane beta release&quot; # ) endendlane :increase_build_number_and_push_to_beta do |values| # Increment the build number (not the version number) # Providing the xcodeproj is optional increment_build_number(xcodeproj: &quot;DevOpsForRN.xcodeproj&quot;) # Commit the version bump commit_version_bump(xcodeproj: &quot;DevOpsForRN.xcodeproj&quot;, force: true) # Add a git tag for this build. This will automatically # use an appropriate git tag name add_git_tag # Push the new commit and tag back to your git remote push_to_git_remote( remote_branch: &quot;beta&quot;, # optional, default is set to local_branch force: true, # optional, default: false )end DevOpsForRN 폴더 안에 .circleci라는 디렉토리를 만든다. DevOpsForRN/.circleci/config.yml 에는 다음의 내용을 추가하자123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475# .circleci/config.yml# To Validate your config.yml then use this cli.# `$ circleci config validate -c .circleci/config.yml`version: 2jobs: build: working_directory: ~/project docker: - image: circleci/node:8 steps: - checkout - run: yarn - run: yarn run test - persist_to_workspace: root: ~/project paths: - node_modules - store_test_results: path: ~/project/junit.xml beta-deploy-ios: working_directory: ~/project/ios macos: xcode: &quot;9.0&quot; steps: - checkout: path: ~/project - attach_workspace: at: ~/project - run: bundle update fastlane - run: bundle exec fastlane beta ios: macos: xcode: &quot;9.0&quot; working_directory: ~/project/ios environment: FL_OUTPUT_DIR: ~/project/output shell: /bin/bash --login -o pipefail steps: - checkout: path: ~/project - run: name: Set Ruby Version command: echo &quot;ruby-2.4&quot; &gt; ~/.ruby-version # Not using a workspace here as Node and Yarn versions # differ between the macOS image and the Docker containers above. - run: yarn - run: bundle install --path vendor/bundle - persist_to_workspace: root: ~/project paths: - ios - run: bundle exec fastlane test - store_artifacts: path: ~/project/output - store_test_results: path: ~/project/output/scanworkflows: version: 2 node-android-ios: jobs: - build - ios: requires: - build - beta-deploy-ios: filters: branches: only: - beta requires: - ios CircleCI에서 Code Signing, Fastlane Match를 이용하기 위해서는 다소 많은 초기 작업이 필요하다. 다음 문서를 따라 하면 일련의 초기화, key setting 작업을 완료할 수 있다. Setting Up Code Signing for iOS Projects - CircleCI Github에 프로젝트 모두 올리기Github Repository를 새로 하나 생성한다. 123456# DevOpsForRN/ 디렉토리에서 진행한다.$ git init$ git remote add origin https://github.com/philographer/DevOpsForRN.git # 자신의 repo 주소로 변경하기$ git add --all$ git commit -m \"first commit\"$ git push -u origin master CircleCI의 Project를 생성한다. CircleCI - Dashboard 접속 MacOS 빌드는 유료이므로, 무료 플랜을 선택한다. 좌측 Settings -&gt; MacOS Plan -&gt; Trial Plan Click 좌측 Project 탭 클릭 -&gt; Add Project 클릭 방금 만든 Github Repo의 오른쪽에 Setup Project 버튼을 클릭 OS는 macOS 선택 Start Build 버튼 선택 Work-Flow 탭으로 이동되는데, 자세히 보려면 빌드 이름을 누르면 된다. 다음과 같이 보이면 성공이다. CircleCI의 Project Setting -&gt; Environment Variables -&gt; Add Variable 을 클릭하고, 다음의 환경변수들을 추가한다.MATCH_PASSWORD: 아까 만든 match pass phrase 입력FASTLANE_USER: Apple ID 입력 (ex. `yoohoogun114@naver.com)FASTLANE_PASSWORD`: Apple PW 입력 CircleCI의 Project Setting -&gt; Checkout SSH Keys -&gt; Add Deploy Key 버튼 또는 Create and add … user key 버튼을 클릭한다.그렇다면 후에 CI에서 debug 해야 할 ssh-key를 자동으로 vm에 미리 넣어준다. 따라서 미리 지정해둔 계정에서는 ci vm에 접근할 수 있다. Trigger Script 작성 DevOpsForRN/package.json 파일을 다음과 같이 수정한다 scripts에 native-test 추가 scripts에 beta 추가 12345678910111213141516171819202122232425&#123; \"name\": \"DevOpsForRN\", \"version\": \"0.0.1\", \"private\": true, \"scripts\": &#123; \"start\": \"node node_modules/react-native/local-cli/cli.js start\", \"test\": \"jest\", \"native-test\": \"tools/run_native_test.sh\", # 추가 \"beta\": \"tools/run_beta_deploy.sh\", # 변경 &#125;, \"dependencies\": &#123; \"react\": \"16.2.0\", \"react-native\": \"0.52.1\", \"react-native-fabric\": \"^0.5.1\" &#125;, \"devDependencies\": &#123; \"babel-jest\": \"22.1.0\", \"babel-preset-react-native\": \"4.0.0\", \"jest\": \"22.1.4\", \"react-test-renderer\": \"16.2.0\" &#125;, \"jest\": &#123; \"preset\": \"react-native\" &#125;&#125; Shell Script 작성하기 DevOpsForRN/tools 디렉토리를 생성한다 DevOpsForRN/tools/run_beta_deploy.sh 파일을 생성하고, 다음의 내용을 작성한다. 1234#!/usr/bin/env bashcd iosfastlane increase_build_number_and_push_to_beta DevOpsForRN/tools/run_native_test.sh 파일을 생성하고, 다음의 내용을 작성한다. 1234#!/usr/bin/env bashcd iosfastlane test 작성한 후, 권한을 부여한다 12$ chmod +x run_beta_deploy.sh$ chmod +x run_beta_deploy.sh Xcode Signing 설정 fastlane에서 사용할 인증서를 선택한다. TestFlight에 사용자 초대 iTunes Connect 에 접속 나의 앱 -&gt; 자신이 이전에 만들었던 앱 클릭 TestFlight 탭 클릭 테스터 및 그룹 -&gt; Itunes Connect 사용자 클릭 버튼 누르고, 사용자 초대 초대한 사용자의 이메일에서 초대 수락 암호화 앱 내 추가 기능 암호화 탭의 지침에 따른다. 작성한 내용 검증하기다음의 스크립트를 실행했을 때, Circle CI에서 work-flow가 올바르게 실행되나 지켜본다.12# DevOps/ 디렉토리에서$ npm run beta CircleCI Dashboard 접속 다음과 같이 JS Test -&gt; IOS Native Test -&gt; TestFlight Deploy가 성공했는지 확인 Next Fastlane, CircleCI를 이용하여 React Native DevOps 도입기 (3) Fastlane, CircleCI를 이용하여 React Native DevOps 도입기 (4) Referencematch is-this-secure? - fastlane docsGitHub - CircleCI-Public/circleci-demo-react-native: A demo React Native project that’s building on CircleCI 2.0 with Workflows.fastlane for React Native iOS &amp; Android app DevOps – React Native Training – Mediumcircleci-demo-workflows/config.yml at workspace-forwarding · CircleCI-Public/circleci-demo-workflows · GitHub","categories":[{"name":"DevOps","slug":"devops","permalink":"https://philographer.github.io/categories/devops/"}],"tags":[{"name":"DevOps","slug":"devops","permalink":"https://philographer.github.io/tags/devops/"}]},{"title":"Fastlane, CircleCI를 이용하여 React Native DevOps 도입기 (1)","slug":"circleci-rn1","date":"2018-02-15T10:38:23.000Z","updated":"2018-03-08T05:00:57.705Z","comments":true,"path":"2018/02/15/circleci-rn1/","link":"","permalink":"https://philographer.github.io/2018/02/15/circleci-rn1/","excerpt":"","text":"1. 개요 사내 프로젝트를 진행하면서 React Native 앱을 개발하게 되었는데, 앱이 점점 덩치가 커지더니 코드 라인 수가 몇만 라인을 돌파할 즈음 CI/CD 프로세스 없이는 도저히 프로젝트 진행이 불가능하다고 느껴졌다. -(너무 늦게 도입했다는 생각이..)-예를 들자면 다음의 경우에 개발자의 Context Switching이 많이 일어나고 개발자의 생산성이 떨어지는 문제가 있었다. 클라이언트가 “중간 배포 버전을 보고 싶다” 라고 하면 중간 배포 버전을 만들기 위해 Production Build를 하고, 배포 서버에 APK를 올리거나 TestFlight에 업로드 해야할 경우 코딩을 진행할 수 없음. 라이브러리가 업데이트 되었을 때 build가 깨질 경우 어느 라이브러리가 문제인지 디버그해야 함. 코드를 수정했는데, 메인 페이지가 rendering이 제대로 되지 않을 경우 앱 내로 진입할 수 없음. 디버그해야 함. 최종 수정 버전을 Android Play Store, IOS APP Store에 업로드 해야하는 경우, 코딩을 할 수 없음. Reat Native의 경우 IOS, Android Project가 각각 나오기 때문에, 테스트를 따로 진행해야 함. 위의 문제들은 모두 CI(Continuous Integration), CD(Continuous Deploy) Process를 잘 정립하면 해결되는 문제라고 판단하고 다음의 Flow를 설계해보았다. 2. What to Make따라서 결론적으로 만들고 싶은 프로세스는 다음과 같았다. 개발자가 각 용도에 맞는 branch에 코드를 커밋한다 Github은 web hook을 이용하여 CI/CD Tool에 이를 알린다. CI/CD 툴은 Android, IOS를 각각 테스트하며 테스트 배포앱을 결과물로 제공한다 Slack에는 테스트 결과, 테스트 배포 앱 링크를 제공한다. 이러한 flow에 알맞는 CI / CD, Automation 기술 스택들을 선정하기 위해 여러 가지 후보군을 선정해 보았다. 3. Jenkins Vs Travis Vs CircleCI 초창기에는 이전에 사용해 보았던 Jenkins를 고려하였으나 자체 보유하고 있는 서버에 올리거나 클라우드에 올려야 하기 때문에 서버 관리 비용(돈+노력)이 필요하고 Jenkins의 복잡한 Configuration 때문에 생기는 높은 Learning Curved가 필요하며 결정적인 이유로 MacOS에서 Xcode Build를 해야하기 때문에 MacOS가 필요하는 등 여러가지 이유로 선택지에서 제외하였다. 그다음 선택지는 Travis 였는데 CircleCI 와 많은 고민을 거쳤다. 사실 두 가지 모두 성숙한 서비스이기 때문에 무엇을 선택해도 크게 다르지 않다는 생각을 가지고 있었다. 따라서 이미 사용해봤던 Travis를 도입하려던 찰나 FaceBook의 React Native 프로젝트인 facebook/react-native 는 어떤 CI Tool을 사용하고 있나 궁금해졌다. 확인해 본 결과 FaceBook이 사용하고 있는 Tool은 CircleCI 였다.그렇다면 왜 CircleCI를 사용했을까? React Naitve의 프로젝트 커밋 히스토리를 찾아보니 이전에는 Travis와 CircleCI를 둘다 사용했었고, 점차 Travis -&gt; CircleCI로 Migration하는 커밋들이 늘어났다. 이유는 빌드 속도 때문으로 보인다.CI Tool들은 직접 컨택을 하지 않는 이상 과금이 총 빌드 시간과 관련이 있다. 따라서 빌드시간이 적으면 적을수록 과금 정책이 싼 plan을 선택할 수 있기 때문에 빌드 속도, 시간은 무척 중요하다. -물론 개발자가 오랜 빌드를 기다리기 싫은 이유도 있고- 관련 커밋: Migrate Travis over to Circle by grabbou · Pull Request #16354 · facebook/react-native · GitHub 4. CI/CD Tool 로서의 선택: CircleCI따라서 우리도 React Native의 프로젝트처럼 과거의 문제를 답습하지 않기 위하여 히스토리를 뒤져보다가 CircieCI를 선택하였고 2.0 Docs - CircleCI부터 차례대로 진행하였다. 프로젝트를 진행하였을 때는 MacOS가 CircleCI 1.0만 가능했었는데 2018년 1월부터 CircleCI 2.0도 지원하기 때문에 아티클을 쓰는 겸사겸사 아래에서 1.0 -&gt; 2.0 Migration을 진행해보기로 한다. 5. Fastlane Vs Appium VS Bitrise사실 세 가지 툴들은 동일한 카테고리에 있는 경쟁대상은 아니다.Fastlane은 App Automation Tool을 담당하는 오픈소스이고 무료Appium은 App Test의 목적으로 사용은 오픈소스이며 무료Bitrise은 CI/CD Tool 서비스이며 유료 우리가 만들려고 하는 CI/CD Architecture에서 위의 3가지 툴들에게 기대하는 근본적인 역할은 다음 세 가지다. 기능이 풍부하고 쉬우며 관리를 줄일 수 있는 좋은 툴이라면 얼마든지 비용을 지급할 수 있다. 다만 많은 기능을 쓰지 않는다면 스타트업은 비싼 플랜이나, 정기적인 과금을 지출하기에는 까다로움이 있다. 따라서 웬만하면 무료여야 한다. -&gt; Fastlane, Appium CI 위에서 테스트와 배포에 도움을 주어야 한다. -&gt; Fastlane, Appium, Bitrise(자체 CI Tool) 생태계가 성숙 돼 있고 건강하며, 활성화가 아직도 진행 중어야 한다. 이는 곧 레퍼런스가 풍부함을 의미한다. -&gt; Fastlane (Star 수가 가장 많고, 검색결과가 많음) 세가지 모두가 비교대상인 대체재 라기보다는, 어느정도의 역할을 상대방이 보완해 줄 수 있는 보완재의 성격을 가지고 있다. Bitrise 같은 경우에는 Fastlane 과 궁합이 좋다는 외국 커뮤니티의 글이나 fastlane 진영에 글들이 많아서 잠깐 고려하기도 했으나 CircleCI가 Bitrise를 대체할 수 있으니, 이미 CircleCI를 선택하려고 마음을 먹었다면 1,2,3번의 조건을 모두 만족하는 Fastlane 진영으로 마음을 굳혔다. Britise는 Mobile을 타겟으로 나온 서비스이기 때문에 CircleCI 보다는 목적이 더 명확하다고 할 수 있다. 하지만 우리 팀은 앱만 만드는 것이 아니기 때문에 보다 범용적인 CI Tool인 CircleCI, Fastlane를 선택하지만 Mobile first 전략을 취하고 있는 스타트업이라면 Bitrise도 충분히 고려할 만하다. 6. Automation Tool 로서의 선택: Fastlanefastlane이란 툴은 Application의 Automation에 필요한 기능을 담고 있는 툴이다. 예를 들자면, $ fastlane beta 라는 명령어를 친면 Build Number를 증가시키고 앱을 빌드하고 TestFlight에 업로드하고 Slack에 메시지를 보낸다. 이런 일련의 과정들을 간단한 CLI 명령어 한줄로 대신 수행해주며 아래와 같은 간단한 ruby 문법으로 행동을 정의할 수 있다.123456lane :beta do increment_build_number build_app upload_to_testflight slackend Next Fastlane, CircleCI를 이용하여 React Native DevOps 도입기 (2) Fastlane, CircleCI를 이용하여 React Native DevOps 도입기 (3) Fastlane, CircleCI를 이용하여 React Native DevOps 도입기 (4)","categories":[{"name":"DevOps","slug":"devops","permalink":"https://philographer.github.io/categories/devops/"}],"tags":[{"name":"DevOps","slug":"devops","permalink":"https://philographer.github.io/tags/devops/"}]},{"title":"초보자를 위한 AWS 뿌시기 AUSG 세미나 후기","slug":"ausg-seminar","date":"2018-01-30T03:37:50.000Z","updated":"2018-03-08T05:00:57.696Z","comments":true,"path":"2018/01/30/ausg-seminar/","link":"","permalink":"https://philographer.github.io/2018/01/30/ausg-seminar/","excerpt":"","text":"개요세미나 또는 단순 PPT 발표 등은 여러 번 해보았지만 핸즈온랩은 저번 유니톤 세미나 이후로 두 번째였다. 일주일의 갭을 두고 2번의 발표가 있어서 회사일과 개인 일정은 많이 제쳐두고 핸즈온 실습에 대해서 AUSG 친구들과 함께 리허설도 많이 해보고 피드백도 여러 방면으로 주고받았다. 저번 세미나는 대학생들을 위한 AWS 강의였기 때문에 그렇게 떨리거나 하지 않았지만, 이번에는 현업 직장인분들도 많이 오셔서 준비한 내용이 변변치 않다면 많은 폐를 끼칠 것 같아서 조금 더 오랜 시간을 잡고 준비했다. C9과 Elastic Beanstalk 이란 서비스를 잡고 세미나를 준비했었는데 c9의 경우에는 이전 멋쟁이사자처럼 이라는 동아리에서 활동할 때 많이 다루어 봤기 때문에 큰 문제는 없었다. 그런데 Elastic Beanstalk의 경우 POC(poof of concept) 정도는 진행 해 보았지만 Production Level 까지는 다루지 않아봤기 때문에 운영레벨에서의 후기까지는 들려주기 힘들다고 생각했다. 그래서 더 열심히 준비했다. 아래 내용은 핸즈온랩을 준비했던 과정, 세미나를 진행하면서 느꼈던 느낌과 후에 돌아보면서 잘한 점 잘못 했던 점을 짚고 넘어가는 형식이다.나중에도 세미나에서 발표할 자리가 있다면 조금 더 나은 세미나를 준비하고 싶은 개인적인 욕심에서 주절주절 기록해두면 좋겠다는 생각에 글을 써본다. 발표 준비우선 실습서의 내용은 이전 세미나에서 진행했던 틀을 그대로 잡고 만들기 시작했다.awskrug/unithon-serverless-2018: 대학생 연합 해커톤 유니톤 2018 serverless 세미나이전에 만들었었던 세미나 자료인데 원본은 AWSLABS에서 만든 것이었고, AWS KRUG: AWS 한국 사용자 모임 번역을 해주셨던 자료였다. 그 자료를 내가 AWS Console이 한글화가 진행됨에 따라 약간의 번역과 최신내용으로 업데이트한 자료였다. 이 자료를 발판으로 이번 C9, Elastic Beanstalk 자료도 차근차근 만들기 시작했다. 나는 발표를 시작하기에 앞서 항상 목차부터 짠다. (큰 그림을 그리는 사람) Cloud 9 시작하기이 책터는 목차는 단순히 C9의 기능인 private ec2 인스턴스를 띄우고 그 환경에서 c9으로 작업하는 활동을 하기로 구성했다. 쉬워서 금방 끝날 것으로 생각했다. Cloud9 &amp; EC2 접속두 번째는 C9의 신기한 기능인데 이미 만들어져 있는 EC2인스턴스에 C9으로 접속할 수 있는 기능을 실습해보는 챕터로 구성했다. C9의 경우에는 기본적으로 python, java, node등 기본적인 개발환경이 구성되어 있는데 EC2 인스턴스에 접속하면 어떻게 될까? 가 나도 궁금했다. 직접 실행해보니 첫 접속때 EC2에 기본적인 개발환경을 세팅할 수 있는것을 볼 수 있었다. 생각보다 금방 끝날 것이라고 생각했는데 EC2 인스턴스가 바로 뜨는것도 아니고, 접속해서 SSH 키도 밀어넣는 작업도 필요해서 시간을 좀 길게 할당했다. C9 친구와 작업하기AWS에 C9이 인수가 되기 전에는, 그냥 상대방 이메일만 알면 co-work(동시편집)이 가능했는데 AWS로 인수되면서 여러 보안 문제 때문에 IAM을 설정해 주어야만 동시 작업이 가능했다. IAM이라는 기능이 보안상 상당히 중요하지만, AWS 초보자에게는 쉽게 간과하고 넘어갈 수 있는 부분이기 때문에 자세히 진행하려고 노력했다. Elastic Beanstalk내가 Production Level에서 사용해보지 않은 사람으로서 내가 발표해도 될까? 라는 걱정이 문득 들었다. 하지만 Elastic Beanstalk은 AWS의 초보자에게 무척이나 핵심적인 서비스라고 생각이 들었기 때문에 내 세미나에 주제로 선택했다. Elastic Beanstalk은 어느 정도 관리의 손을 덜어주는 유용한 서비스이기 때문에 EC2, ELB, Security Group, Auto Scaling Group 를 전혀 몰라도 대시보드에서 쉽게 Scale-Out 설정이 가능하고 쉬운 배포 에 강점이 있기 때문에 꼭 진행해야 한다고 생각했다. 나도 많이 써본 기능은 아니지만 공식 문서를 천천히 읽고 기존 운영 경험을 토대로 장단점을 설명하면 그래도 유용하지 않을까 생각했다. 거기에 직접 사용해보지는 않았어도 조금 빨리 배운 선배로서 시간낭비를 줄일 수 있는 꿀팁이 있을 거라고 생각해서 목차에 넣었다. Elastic BeanStalk With C9마지막 주제는 앞에서 했던 것들과 Elastic Beastalk를 EB Cli를 이용해서 내 컴퓨터에 전혀 개발환경이 세팅되지 않았어도 인터넷이 연결된 브라우져만 있다면 개발과 배포 가 가능하다는 것을 보여주고 싶어서 준비했다. 그리고 앞의 내용을 통째로 묶으면서 간단한 아키텍쳐에 대해서 이해할 수 있겠다는 생각해서 이런 구성으로 준비했다. 이렇게 발표 주제를 5가지로 세분화하고 세부 내용을 구성하면서 Amazon Web Services(AWS) 10분 자습서, AWS 공식 문서를 많이 뒤져보게 되었다. 원래 예전에는 어떤 기술에 대해서 배우려면 구글링부터 시작해 보고는 했는데 결국에는 공식 문서를 보게 되었다. 따라서 정도를 걷기 위해서 처음 시작을 공식문서로 잡고 전체 내용은 천천히 읽었다. 세미나 당일현업 직장을 대상으로 한 기술 세미나는 처음이어서 많이 떨릴 줄 알았는데 날씨가 워낙 추워서 손이 잠깐 얼었던 것 빼고는 막힘없이 진행했다. (너무 막힘없이 진행해서 사람들이 못 따라오지는 않았을까) 처음에는 초심자를 배려하는 마음에서 조금 느린 템포로 자세하게 진행했으나, 서포팅을 하는 친구에게 다들 잘 따라하고 있다고 빠르게 나가도 되겠다는 피듭백을 들어서 쉬는시간 이후로는 조금 빠르게 진행했다. 원래 2번 챕터는 시간일 많이 걸려서 빼놓고 나중에 진행하던지, 아니면 진행하지 않던지로 생각하고 있었는데 생각보다 잘 따라오셔서 모든 모듈을 마칠 수 있었다. 끝부분은 시간이 모자르지만 욕심이 있어서 다 진행하고 세미나를 끝냈다. 후기 &amp; 회고저번 세미나보다는 분명히 나아진 점이 많았다. 말하는 도중 문득 생각나는 팁들은 모두 쏟아냈고, 생각보다 긴장도 하지 않았다. 조금 독특한 점은, 내가 준비한 세션을 엄청 집중해서 들어주시는 느낌? 이게 사람이 적어서 집중도가, 아니면 유료 세미나인지는 모르겠지만 확실한 건 저번보다 내가 나아졌고 더 긍정적인 피드백을 많이 들었다는 것이다. 저번에 잘 하고, 이번에 잘 하고가 중요한 게 아니라 한번, 그다음으로 여러 번 할 때마다 점점 나아진다는 게 중요한 게 아닐까 :) MeetUp: AUSG 초보자를 위한 AWS 뿌시기 2회 MeetupSlideShare Link: AUSG 초보자를 위한 AWS 뿌시기 세미나 2회 - 팀플 과제를 여행하는 히치하이커를 위한 안내서실습서 Github Repo: ausg-seminar-2018/teamplay","categories":[{"name":"Conference","slug":"conference","permalink":"https://philographer.github.io/categories/conference/"},{"name":"Dev","slug":"conference/dev","permalink":"https://philographer.github.io/categories/conference/dev/"}],"tags":[]},{"title":"제6회 유니톤 네트워킹데이 세미나 스피커 후기","slug":"unithon-seminar","date":"2018-01-21T03:57:00.000Z","updated":"2018-03-08T05:00:57.718Z","comments":true,"path":"2018/01/21/unithon-seminar/","link":"","permalink":"https://philographer.github.io/2018/01/21/unithon-seminar/","excerpt":"","text":"매번 블로그에 글을 써야지 써야지. 입으로만 썼는데 생각난 김에 후딱 하나를 적어야 겠다는 생각이 들었다. 작년 (2017년)아마 작년에는 이맘때쯤에 SW Maestro 과정에 참여하고 있기도 했고, 동시에 Nexters 활동도 마무리하는 시간이어서 무척 바빴던 것으로 기억한다. 그러던 중, 하고 있던 개발에서 잠깐 뛰쳐나와서 다른 토이프로젝트를 진행하면 어떨까 문득 생각이 들었다. 그래서 같은 과정에 있던 전성민이라는 친구와 제 4회 유니톤 에 참여를 하게 되었다. 그 당시에, 돈톡 이라는 node.js, mongoDB, 안드로이드 농협 핀테크 오픈 API, [Dialogflow](https://dialogflow.com/) (당시에는 api.ai)를 가지고 핀테크 챗봇이라는 애플리케이션을 만들었었는데 나름 운이 좋아서 최우수상을 받게 되었다. 2박 3일 동안 개발이라 무척 힘들었던 기억이 새록새록 난다. 이번 년 (2018년)이번 년에는 작년과는 다르게, 유니톤에 AWS 대학생 그룹의 소속으로, 스피커(연사)로 초청받아서 발표를 하게 되었다. 분명 작년까지만 해도, 내가 저 자리에 앉아서 다른 사람의 AWS 관련 발표를 들었었는데 내가 저 자리에 서게 된다니 굉장히 감회가 새로웠다. 세미나는 작년에 직장인들을 대상으로 했던 핸즈온 랩 세미나를 조금 업데이트시키고, AWS console이 한글화가 진행되었으므로 한글화를 하고 스크린샷을 새로 찍어서 가독성을 높여서 프로젝트를 만들었다. GitHub - awskrug/unithon-serverless-2018: 대학생 연합 해커톤 유니톤 2018 serverless 세미나 원래 4시간짜리 과정인데 이걸 압축해서 2시간 만에 하려니 시간도 무척 모자랐기 때문에 끝부분은 거의 진행하지 못 하고 내가 하는 걸 따라보게 했다. 핸즈온 랩, 라이브 코딩이란 정말 어려운 것 같다. 연습이 많이 부족하기도 했고 중간중간 프로젝터가 꺼지거나 하는 등 예상치 못한 사고가 있기 때문에 세미나는 어려운 것 같다. 세미나가 길어지니, 흥미가 떨어져서 따라오지 못 하는 사람들은 뒷자리에서 딴짓을 하는 게 보였다. -(다 흥미 유발을 못 했던 내 잘못인 것 같다.)- 다음에는 중간중간 놓치지 않도록 더 흥미를 이끌 수 있고 쉬운 콘텐츠를 준비해야겠다는 반성을 하게 되었다.","categories":[{"name":"Conference","slug":"conference","permalink":"https://philographer.github.io/categories/conference/"},{"name":"Dev","slug":"conference/dev","permalink":"https://philographer.github.io/categories/conference/dev/"}],"tags":[{"name":"Conference","slug":"conference","permalink":"https://philographer.github.io/tags/conference/"},{"name":"Dev","slug":"dev","permalink":"https://philographer.github.io/tags/dev/"}]},{"title":"PlayNode 2017 행사","slug":"playnode2017","date":"2017-11-28T13:58:23.000Z","updated":"2018-03-08T05:00:57.711Z","comments":true,"path":"2017/11/28/playnode2017/","link":"","permalink":"https://philographer.github.io/2017/11/28/playnode2017/","excerpt":"","text":"171109 Play.NodeGraphQL In Action: REST와 이별할 때 생각해야 하는 것들 고통의 근원: 이게 RESTful한가? 계속 질문하게 됨. Path, method, url 설계 등등…. 특징 scheme를 정의하여 validation이 편함 상속: union, interface keyworld recursive query: fragment 사용 Tool GUI Client Insomnia REST Client GitHub - graphql/graphiql BaaS Graphcool - GraphQL Backend Development Framework 구현체 GitHub - apollographql/apollo GitHub - relay 같이쓰면 좋은 GitHub - facebook/dataloader -&gt; 캐싱 lambda.js와 함께 하는 간단한 API Server 만들기 GitHub - ramda/ramda: Practical functional Javascript 순수함수 side effect가 없는 함수: 외부 변수에의해 조작이 불가능한 일급함수 … 함수를 파고들어갈때 R.isNil R.compose R.last R.curry R.allPass 알면 좋은 것 Cookbook · ramda/ramda Wiki · GitHub Try Lambda Node.js API 서버 성능 개선기 테스트 준비 서버 하나의 한계 파악 병목구간 확인 코드 개선 후 비교 테스트 툴 로컬 성능 확인 GitHub - shoreditch-ops/artillery npm script pre, post keyword npx autocannon 서비스 Newrelic 테스트 시작 끝을 알려고 배포 플래그 api이용함 Nsolid RisingStack AWS ECS Cluster Vagrant로 Virtual Box가 아닌 AWS EC2를 띄움 Rsync Ansible 성능 개선 클러스터 인스턴스 변경 컨테이너 CPU, 메모리 조정 DB Pool 사이즈 조정 v8 major update(node v6 -&gt; node v8) turbofan + ignition 엄청난 성능향상… node inspect option (프로파일러) chrome devtools 사용가능 v8 tick profiler node -prof summary Heap Dump -&gt; 메모리 누수 추적 크롬 디버거 -&gt; Memory -&gt; Heap Dump Heap Dump를 테스트 이전, 테스트 이부 협력적 멀티태스킹 Async await 잘 써라 Promise를 래핑함, 성능은 잘 나오지 않더라도 메모리 관리등… 클라우드 시대의 node.js가 좋은 이유 vs JAVA: Memory 차지를 많이함 -&gt; 가지고있는 리소스가 적을때. https://github.com/fzaninotto/uptime ELK Stack","categories":[{"name":"Conference","slug":"conference","permalink":"https://philographer.github.io/categories/conference/"},{"name":"Dev","slug":"conference/dev","permalink":"https://philographer.github.io/categories/conference/dev/"}],"tags":[]},{"title":"휴학 회고 (2016.08-2017.08)","slug":"absence","date":"2017-11-12T03:57:39.000Z","updated":"2018-03-08T05:00:57.695Z","comments":true,"path":"2017/11/12/absence/","link":"","permalink":"https://philographer.github.io/2017/11/12/absence/","excerpt":"","text":"글을 쓰며휴학을 하기 전에 작성했던 글을 다시 되돌아보았다. 어떤 마음가짐으로 휴학을 하게 되었고 다시 복학하기 전까지 나는 무엇이 달라졌을까. 복학 전 마음이 뒤숭숭한 지금, 일 년 동안 나는 무엇을 했고 어떻게 지내왔는지를 한번 되돌아보는 시간을 가지면 좋겠다는 생각에 글을 쓰려고 키보드를 잡았다. 그런데 일에 치이고, 시간이 없다는 핑계로 “소프트웨어 마에스트로”가 끝나자마자 작성하려고 했으나 밀리고 밀려서 8월 중순이 돼서야 적게 된다. 그래도 지금이라도 적는 게 어디인가. 사실 블로그 아티클은 누군가 보여주려고 쓰는 것이지만, 이 글만은 내가 나중에 일기장에서 꺼내보는 느낌으로 적어본다. 휴학 전 &amp; 휴학 후의 심경 160923 휴학. - Dev.Timero의 학습일기이 글은 물리적 시간의 제약으로 고통받던 내가, 유일하게 잠시 미룰 수 있는 학교를 쉬면서 적은 심경이 담겨있는 글이다. 선택과 집중을 하기 위해 휴학을 선택했었는데 휴학이 끝날 무렵 다시 되돌아보면 그렇게 집중하지도 못했던 것 같다. SubJob과 SW Maestro를 병행하기는 참 어려웠다. 물리적 시간을 나누어 두 가지 일을 동시에 하기란 무척 어려웠다.글을 보면 3000만 원 이상 벌고 그 이상의 경험도 한다고 했는데 그 두 가지 관점에서 봤을 때는 성공적인 휴학이었다. (그런데 왜 내 통장에 3000만 원이 없지?, 반절은 썼구나…) 1년뒤 나의 개발 기술 및 스펙 - Dev.Timero의 학습일기C+도하고, 웹 스택에, Ruby에, Python에, Go까지 적혀있다. (난 정말 욕심이 많다). 결과적으로 말하면 C 계열은 손도 못 대보았고, Go는 SW Maestro 프로젝트에 도입하려다가 Open CV의 커넥터의 퀄리티가 별로여서 실패했다. 하지만 결론적으로 Web Stack은 더욱 견고히 다지게 되었고, Typescript, Angular에 React까지 만져볼 기회가 있었다. Python과 Django 또한 SW Maestro에서 영상처리를 하는데 좋은 경험을 하게 되었다. 그런데 Django 는 손에 안 익어서 별로였다. (너무 무겁다) Team Mondrian (스타트업 근무, 2016-08 ~ 현재(2017-08-21))아마도 1년 동안 가장 많이 노력과 시간을 쏟아부은 일은 스타트업에서 근무한 일 아닐까. Team Mondrian을 짧게 소개하자면 스타트업 팀이다. 팀이라고 쓴 이유는 말 그대로 프로젝트팀의 느낌이랄까. “기존의 회사에 근무하는 느낌”이라기보다는 “프로젝트를 진행하는 팀원들이 모인 회사 느낌”이다. 원격 근무로 “Slack, Hangout”등으로 회의하며 아이디어 회의 등이나 이슈를 해결하는 자리는 Offline 미팅을 가진다.어쨌든 일 년 동안 가장 성과가 있었고 내가 배운 것도 많은 회사였다. 주로 Javascript를 이용한 Web Backend, Frontend (Web Full Stack)을 다루었다.서울대학교 융합과학기술원 연구 프로젝트 “Being” 과 Inbody사와 Co-work했던 “Inbody-Wear App”을 개발했었는데 Ionic2, React-native, node.Js, express.Js, AWS를 다루었기 때문에 웹, 앱, 서버 모두 넘나들면서 Full Stack을 했었다. 얇고 넓은 지식을 쌓게 되었다. 사실 얇고 넓은 지식에 대해서는 휴학 전에 경계하는 느낌이었다. “모두 알지만 모두 모른다”는 느낌일 수 있겠지만 막상 여러 가지 일을 하면서 Production Level을 찍고, 운영 및 버그 픽스를 해보면서 느껴본 결과는 얇고 넓은 일을 하면 통찰력을 얻을 수 있는 것 같다. 아직도 느끼는 것이지만 Generalist로 진로를 잡을 것이냐 Speciallist 로 진로를 잡을 것이냐를 결정하는 일은 참 어려운 일이다. 사실 지금 스타트업에서의 경험은 Generalist이기도 하고 학생 때의 경험은 Special보다 General이 더 낫다고 생각한다. General이 좀 더 넓은 통찰력을 기를 수 있는데, 이 기회는 지금이 아니면 기르기 힘든 핵심 가치관이기 때문이다. Work &amp; Life Balance스타트업에 근무하면서 얻은 좋은 경험은 Work &amp; Life의 Balance였다. 내가 근무한 스타트업은 한국 회사에서 찾아보기 힘든 “완전한 형태의 원격 근무“의 형태를 띠고 있으며 내가 원한다면 당장 미국으로 떠나서 일해도 괜찮다. 하지만 내가 디지털 노마드를 하지 않는 이유는 강원도 여행과 일본 여행 중 디지털 노마드가 된다면 어떤 느낌일까? 라는 생각으로 노트북을 짊어지고 갔으나 결과는 참혹했다. 다른 사람에게는 다를지도 모르겠지만 적어도 나에게는 Work와 Life가 정확히 구분되어야 한다는 것을 느꼈다. Nexters 8기 마무리(개발자와 디자이너를 위한 IT 연합동아리, 2016-01 ~ 2017-03)이담누나, 현철형, 수민이 + 영수영과 함께 Wazap-와서잡아/공모전/팀빌딩 을 런칭하였고, 이담누나, 현철형, 수민이와 함께했던 넥스터즈에서의 2번째 앱 출시인 “미세몬”을 런칭했다. (물론 지금은 AWS 비용상 서버가 내려가있다.). 동아리에서 이런 퀄리티에 앱을 낼 수 있는 사람들이 있다는 점에서 무척 동아리에 고마웠다. 아주 훌륭하고 뛰어난 디자이너&amp;개발자가 많아서 귀감이 되었던 동아리였다. 그뿐만 아니라 NEXTERS의 일원으로 제3회 유니톤에서 최우수상도 받게 되었다. 이런 좋은 동아리인 Nexters가 앞으로도 번창해서 많은 개발자와 디자이너에게 귀감이 되었으면 좋겠다. SW Maestro (과학기술 정통부 산하 SW 인재양성 프로그램, 2016-06 ~ 2017-06) 1차 프로젝트소프트웨어 마에스트로에서 OpenStack에 Kubernetes관련 Plugin을 개발하는 프로젝트를 진행했었다. (2016-09-01 기준으로 이러한 Feature는 Blueprint에도 없었던 개념이지만 현재는 관련 플러그인이 개발 및 안정화가 되고있는 것으로 보인다.) 생소한 개념인 인프라, 플랫폼 레벨의 OpenStack은 여러 가지 마이크로서비스 아키텍처를 지향하며 세상에서 가장 활발히 성장하고 있는 클라우드 오픈소스이다. 처음 다가갈땐 Network, Infra에 대해서는 무척 생소하였지만 큰 프로젝트를 공개된 소스를 통하여 뜯어보면서 대규모 프로젝트의 구조, Automation에 대하여 배운 프로젝트였다. 여기서 배운 지식이었던 BuildServer의 개념과 Automation은 지금까지도 유용하게 써먹고 있다. 2차 프로젝트2차 프로젝트는 짧게 말하면 “풋살경기 자동 촬영 시스템과 그 영상을 통한 하이라이트 편집” 이었다. 난생처음으로 H/W와 연계한 프로젝트였고 나는 영상처리와 Server 분야를 맡게 되었다. 쉽게 말하면 공을 따라다니면서 자동으로 풋살경기 영상을 촬영해주고, 그 영상을 서버에 업로드하면 자동으로 하이라이트 부분만 편집하여 알맞은 음악과 트랜지션 효과를 넣어주고 영상을 잘라서 편집해주는 S/W를 개발하였다. 전체적으로는 완성이었지만 세부 트랜지션 효과와 실제 경기 영상을 많이 촬영해 보지 못한 점이 아쉬움으로 남는 프로젝트였다. 경디공 4기(경인지역 경상&amp;디자인&amp;공학 연합 동아리, 2017-03 ~ 2018-03)Nexters 활동이 끝나고, 서울로 가기 지친 나에게 경디공의 모집글을 학교 게시판에서 보게 되었다. 경디공은 인천에서 활동하는 경상&amp;디자인&amp;공학의 줄임말인 동아리로, 매주 스터디와 반분기 프로젝트를 진행하며 공모전에도 참여하는 경인중심 대학생 연합 동아리이다. 사실 이런 연합동아리들은 서울 중심으로 포진해 있어서 인천에 살고있는 나는 너무나도 왔다갔다 체력을 많이 뺏기기에, 오히려 인천에 있다면 체력소모가 덜하지 않을까 생각하며 동아리에 지원했다. 주로 인하대, 인천대와 서울권 학교, 경기도권 학교에 재학 중인 대학생들이 활동하고 있으면서 다분야 &amp; 다각도에서 보기 좋아하는 나에게 안성맞춤인 동아리였다. 개발자가 아닌 홍보부로 활동하면서 지친 나에게 쉬면서 다 전공의 사람들과 교류하며 시선을 옅볼 수 있는 활동을 진행하고 있다. AWSKRUG Suporters 1기 (아마존 웹서비스 유져그룹 서포터즈, 2017-07 ~ 2018-03)AWS! 가장 내가 좋아하는 클라우드 서비스를 제공하는 회사이다. 관심 있는 회사에서 관심 있는 활동을 하다니. 너무너무 지원하고 싶었다. AWS내 에반젤리스트, 테크니컬 어시스트님들이 함께 강의해주기 때문에 무척이나 유익해 보인다! 아직 시작한 지 얼마 되지 않아서 프로젝트나 그런 것들에 대해서는 진행사항이 없지만 1기 활동으로서 내년에는 인천지역에서 AWS 관련 모임이나 대학생 할동을 할 수 있을 것으로 생각된다. 열심히 활동하면서 후기들을 써 내려가 보고싶다. 취미라즈베리파이, 라떼판다와 같은 OpenSource H/W 가 요새들어 눈에 보인다.Backend, frontend의 기술을 익히고 보니, 실제로 상품성이나 실용성 있는 아이디어는 결국 H/W가 있어야 한다는 것을 느꼈다. 라즈베리파이로 입문하려고 책과 하드웨어를 10만원 이내로 구입하려고 계획중이다. 앞으로 하고 싶은 TodoList GoLang으로 백엔드 및 시스템레벨 자동화 프로젝트 Jenkins 도입과 빌드서비스들 Career path 오픈소스 프로젝트 기여 알고리즘 풀이 SW Membership, BOB, 또는 한이음 프로젝트 마무리하며인생의 선택 기준은 지금 할 수 있는일 t1, 나중에라도 할 수 있는 일 t2일때 t1을 선택한다. 그래서 내가 지금 “돈되지 않는 일”과 “오로지 학생때만 할 수 있는 일”을 좋아하는 것 같다. 앞으로의 선택 기준과 인생의 가치관인 “학생으로서의 Generalist” 를 유지하면서 앞으로는 무엇을 하는게 Best인가?를 항상 고민하며 학생 생활을 마무리해야겠다.","categories":[{"name":"Retrospect","slug":"retrospect","permalink":"https://philographer.github.io/categories/retrospect/"},{"name":"Personal","slug":"retrospect/personal","permalink":"https://philographer.github.io/categories/retrospect/personal/"}],"tags":[]},{"title":"Github Webhook","slug":"webhook","date":"2017-02-15T20:29:14.000Z","updated":"2018-03-08T05:00:57.724Z","comments":true,"path":"2017/02/16/webhook/","link":"","permalink":"https://philographer.github.io/2017/02/16/webhook/","excerpt":"","text":"개요프로젝트를 진행하면서 빠르게 api 서버를 배포해야 할 일들이 많다.예를 들자면 해커톤에 참여할 때라던지, 당장 나의 api를 클라이언트 프로그래머가 사용해야 할 경우가 종종 있다.API 서버를 테스트로 배포할 때는 주로 다음의 과정을 거친다. localhost에서 작업을 하고 Postman를 테스트를 거친다 Github Repository에 Push한다 현재 돌고있는 코드를 stop 한다. 서버(AWS, 물리)에 접속하여 Git pull을 받는다. 다시 코드를 start 한다. 상당히 번거로운 작업이 아닐 수 없다. 그래서 나는 이런 경우 주로 ec2에 git을 설치하고, 서버에 직접 repository를 만든 다음 ec2의 repo push하면 post receive hook을 사용하여 빠른 배포를 진행했다. 다음의 링크와 같은 방법이다. DIY node.js server on Amazon EC2 하지만 이런 방법에는 큰 단점이 있다. 바로 server에 git을 직접 bare로 설치하는 방법이기 때문에 나중에 github으로 프로젝트를 관리하기 어려워진다는 점이다. 최근 AWS직원분들과 이야기를 나눌 기회가 있었는데 Github Webhook에 대해서 말씀해 주셔서 알아보게 되었다. 여담으로, 처음에 “어떻게 빠른 배포를 진행할까?”에 대해서 생각하면서 Jenkins, Travis같은 빌드툴을 이용하고 그 다음 자동 배포 로직을 돌리면 어떨까 생각했는데 생각보다 빌드툴을 셋팅하기도 오래 걸렸기 때문에 간단한 테스트에는 적합하지 않았다. AWS Code Deploy에서 테스트 프로젝트를 돌려보니 Blue Green 배포 방식이고 router를 재연결하는 방식이기 때문에 코드가 빨리 배포되지는 않아서 매우 짜증이 났다.그래서 결국에 제일 간단한 방법인 Github Webhook을 선택하였다. Webhook 이란?Webhook에 대해 알아보기 전에 우선 hook이 무엇인지 알아보자면,hook이란 각종 소프트웨어 구성요소 간에 발생하는 함수 호출, 메시지, 이벤트를 중간에서 가로채는 행위를 말한다.Webhook은 Webhooks | GitHub Developer Guide에 매우 잘 나와 있고, 링크를 요약하자면 git repository에 이벤트가 발생했을 때 이를 미리 설정한 URL에 HTTP POST Method로 보내주는 것을 말한다. 주로 이슈 트래커, CI Build, Update Backup Mirror, deploy에서 사용한다고 한다. 이 글에서는 deploy관점에서 webhook을 적용한다. Prerequisite Apt-get upgrade Apt-get update Install Node.js Debian-ubuntu-Node.js | Node.js Install Pm2 pm2: Production process manager for Node.js Install Nginx How To Install Nginx on Ubuntu 16.04 | DigitalOcean or Nginx Install 1. Ssh key Setting (On Server) 서버에서 Generating a new SSH key and adding it to the ssh-agent를 참조하여 ssh 키를 만든다. 다음링크에서 만들었던 서버의 공개 키를 등록한다. (기본값으로 설정했다면 vi ~/.ssh/id_rsa.pub 에서 볼 수 있다.) https://github.com/settings/ssh 공개키(id_rsa.pub)에 있는 내용을 서버의 ~/.ssh/authorized_keys 파일의 끝에 copy and paste한다. 2. Github Repository Setting우선 Github의 Repository에서 Settings 탭을 보면 Add Webhook 버튼이 있다.친절히 가이드도 적혀있으니 시간이 있다면 참조해보자. 3. Secret SettingAdd Webhook을 누르면 다음과 같은 화면을 볼 수 있다. Payload URL에는 원하는 도메인의 Post Request가 날아갈 EndPoint를 적어준다. 내 경우는 추후에 NGINX Proxy를 이용해서 /hook 로 날린 요청을 받기 때문에 저렇게 설정했다. Content type은 json이나 form을 선택할 수 있다. 필자는 node에서 json으로 처리하는게 편하기 때문에 json을 선택했다. Secret은 보안상 필요한 부분이다. 생략해도 되지만 설정하기를 권장한다. 자신이 원하는 값을 적으면 된다. Secret을 생략할 수 있지만 사실 매우 중요한 부분이다. SECRET을 설정하지 않는다면 서버에서는 어떤 Post Request에도 Shell Script나 커맨드 또는 Logic을 무조건 실행하므로 보안상 배우 취약할 수 있다. 4. NGINX SettingNginx 설정을 진행한다.$ vi /etc/nginx/sites-available/default 123location /hook &#123; // 이 부분이 포인트 proxy_pass http://127.0.0.1:3100/; //3100 포트로 proxy &#125; 설정 파일을 잠깐 살펴보면 /hook 으로 endpoint에 접속하면 3100번 포트로 proxy한다. 5. Hook ScriptGithub에 Push되었을 때 실행될 스크립트를 작성한다$ mkdir ~/hook$ vi ~/hook/hook.sh futsal-node라고 적혀진 부분을 자신의 node server 디렉토리로 바꾼다. futsal이라고 적혀진 부분을 추후 pm2 에서 실행할 이름으로 미리 정해둔다. 코드를 설명하자면 Github Repository에 코드가 Push되었을때, 서버 디렉토리로 이동 후 Code를 Pull 받은 다음 pm2로 실행중인 기존의 서버를 재시작한다는 내용이다. 그 다음으로 Hook 폴더 내에서 $ npm init을 한 후, start script를 작성한다. 추후에 pm2에 의해 nom start script가 실행된다.$ vi ~/hook/package.json123456789101112&#123; \"name\": \"hook\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"hook.js\", \"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\", \"start\": \"nodejs ./hook.js\" &#125;, \"author\": \"\", \"license\": \"ISC\"&#125; 6. Node.js Server ScriptGithub에 Push 되었을때 이를 인지할 수 있는 작은 서버스크립트가 필요하다.$ vi ~/hook/hook.js 코드를 설명하자면 Post Request가 왔을 때 클라이언트가 헤더에 x-hub-signature 값을 보내주는데, 이 값을 Server가 가지고 있는 토큰을 기반으로 Body를 암호화한 값과 같은지 보고 맞다면 아까 만들어둔 hook.sh를 실행한다는 내용이다. 여기서 중요한 점은 보안상의 이유로 위에서 진행했던 Secret Setting에 설정했던 키와 똑같은 키를 하드코딩된 변수가 아닌 환경변수(process.env[‘SCRET_TOKEN’]) 에서 불러와서 쓴다는 점이다. SCRET_TOKEN 환경변수는 다음과 같이 설정한다.$ echo export SECRET_TOKEN=아까설정했던Secret &gt;&gt; ~/.bash_profile 7. Pm2 Setting$ pm2 start npm --name=&quot;hook&quot; -- start이제 Background에서 Node.js 서버가 돌고있으면서 Post Request가 오기를 기다리고 있다. Github Repo에 Push를 하면 Github이 우리 서버 URL(~~~/hook) 로 Post Request를 날리고, Nginx에서 이것을 3100 port로 proxy한다. 그러면 우리의 hook.js 서버에 도달하고 만약 SECRET이 일치한다면 hook.sh를 실행하고 불일치하면 실행하지 않는다. npm start 커맨드를 pm2에서는 다음과 같이 실행한다. pm2 start npm —name “{app_name}” — run {script_name} (run is optional) 마치면서빠르게 배포하기 위해서 Github Webhook에 대해서 알아봤다. Bash Script, SSH, PM2, Node.js 에 대해서 미리 어느 정도 알고 있다면 그렇게 어렵지는 않을 것이다. 까먹지 않고 있으면 빠른 배포가 필요한 상황에서 매우 유용할 것 같다. 참고자료 Deploy your site with git · GitHub","categories":[{"name":"DevOps","slug":"devops","permalink":"https://philographer.github.io/categories/devops/"}],"tags":[{"name":"vcs","slug":"vcs","permalink":"https://philographer.github.io/tags/vcs/"}]},{"title":"4회 Unithon 후기","slug":"4th-unithon","date":"2017-02-07T05:07:49.000Z","updated":"2018-03-08T05:00:57.635Z","comments":true,"path":"2017/02/07/4th-unithon/","link":"","permalink":"https://philographer.github.io/2017/02/07/4th-unithon/","excerpt":"","text":"개요어떠한 활동이던, 경험은 해놓았지만 적어놓지 않으면 서서히 기억 속에서 사라져 버린다. 프로그래밍에 대해서 경험한 것은 블로그에 쓰면 나중에 다시 뒤돌아볼 때 좋은 동기부여가 되지 않을까 싶어서 ‘후기를 적어보자!’ 라는 생각이 들어서 포스팅을 적게 되었다. Unithon(유니톤) 이란? 유니톤은 Nexters, REAL, YAPP, insiders등 4개의 대학생 IT 연합동아리가 중심이 되어 기획하고 주관하는 해커톤이다. 외부 인원에 대해서는 소속이있거나, 팀을 미리 이룬 팀만 참가가 가능하다. 1일차나는 Nexters의 소속으로 해커톤에 참가했는데, 우연히도 현재 Software Maestro 7기 과정에서 같이 아는 동생과 만나게 되었다. 사실 Software Maestro도 적지 않은 인원이 연수를 받는 터라, 그 동생과는 안면만 있는 정도라 해커톤에서 거의 처음 본 사이였지만 팀에 무언가 연이 있는 사람이 있다는 생각에 빠르게 친해지는 데 큰 도움이 되었다. 팀이 구성되고 서버 개발자 2, 안드로이드 개발자 2, 디자이너 1, 기획자 1로 포지션을 나누었다. 아이디어를 선정하는 과정은 브레인스토밍을 통해 아이디어의 목록을 만들고, 각 아이디어에 점수를 부여하여 투표하는 과정을 거쳤다. 최종적으로 나온 아이디어는 핀테크 챗봇이었다. 주제가 나오고 나서, 모두가 아이디어에 살을 붙이기 시작했다. 생활 밀착형 핀테크 챗봇을 만들기로 했다. 꽤 아이디어를 모으는 과정과 아이디어가 선정되기까지의 과정이 빠르게 진행되었다. 사실 처음 만난 사이라 서먹하기는 했지만, 해커톤은 ‘속도전’이다. 해커톤에서 아이디어가 매우 빨리 결정 된 것은 크나큰 장점이었다. 프로젝트 컨셉 대학생의 공과금은 절대 자동이체를 안 한다 =&gt; 알림을 준다 작은 돈 받기 힘들다. 최대한 정중히 이메일은 보내준다. (일수) 캐릭터화 되어있는 돈(봇)이 말을 한다. (심사임당: 50,000원 임당, 다보탑: 나는 바보인가보다보탑, 세종대왕: 얼른 돈을 보내야 하느니라. 등등) 협업 툴로는 단순히 Trello를 사용하기로 하였고 버전 관리는 Github으로 만들기로 하였다. 빠르게 Github organization을 만들고 초대를 돌렸다. 그 후 Server와 Android 프로젝트 Repository를 만들고 개발을 진행하였다. 첫날은 대부분 프로젝트 셋팅이 대부분이어서 개발환경만 마련하고 집으로 돌아갔다. 나는 집이 멀기에 소프트웨어 마에스트로 센터에서 하루 자기로 하였다. 센터에 돌아와서 간단히 로그인, 회원가입, 이메일 전송까지 완성하고 잠들었다. 3시즈음 잠든 것 같다. 2일차아침에 꽤 일찍(8시?) 쯤 일어나서 센터에서 샤워한 후 정신을 가다듬고 선정릉역 디캠프로 걸어갔다. 아침에 갑자기 배가 고파서 국밥을 하나 사 먹고 가려다가 간단히 편의점에서 김밥을 하나 사서 해커톤 장소에 도착했다. Naver API를 사용해서 Oauth2.0 로그인을 하는 부분을 작업했다. 또한 빚에 대해서 독촉하는 이메일 기능도 작업하였다. 같이 작업하는 친구가 Node, Typescript, Mongo 에 대해서 작업에 익숙하지 않은 터라 조금씩 알려주면서 진행했는데 워낙 베이스가 튼튼한 친구라 간단히 알려줘도 잘 응용했다. 주로 2일차에 인증, API Endpoint 구조를 나누고 API 문서를 작성하는데에 시간을 썼다.UNITHON Hack API v0.1 - Google 스프레드시트 3일차3일차는 안드로이드와 API를 연결하고, 챗봇의 정확성을 높이기 위해 전처리, 후처리하는 과정과 최적화에 힘을 쏟았다. 아침이 되니 체력이 방전돼서 한 1-2시간 즈음 엎드려서 잠든 것 같다. 기획자님이 결과물을 잘 포장해서 발표해 주셨는데 너무 잘 발표하셔서 딱 듣자마자 ‘아! 수상권이다.’라는 생각이 들었다. 발표 후 심사위원님들이 돌아다니시며 시연을 보여드리고 수상이 진행되었다. 결과 사실 결과물에 비해 상이 너무 과분해서 다른 팀들에게 죄송했다. 수상에 대해서 왜 수상했는지를 생각해보았다. 기획자님이 발표를 매우 매우 잘해주셨다. 챗봇을 짧은 기간에 만들었다 (api.ai를 사용해서 빠른 자연어처리) 상황에 맞는 최적화를 잘 진행했다. (시연 때 미리 정확한 채팅과 API를 뽑아놓았다.) 기획 -&gt; 디자인 -&gt; 결과물을 뽑아내는 속도와 주기가 매우 빨랐다. 시연 때 심사위원의 입맛에 맞추어 잘 진행했다. 기획이 매우 좋았다.(생활 밀착형 핀테크) 마치면서작년 해커톤보다 개인적으로 꽤 많이 성장했다고 느꼈다. 작년까지는 그냥 어느정도 Web Frontend에 대해서 이해한 채로 해커톤에 나가서 어려운 점이 많았었는데 이제는 Server파트도 어느정도 이해하고 있으니 구현의 속도가 매우 빨라졌다는 것을 느꼈다. 이제는 일 년에 해커톤을 한두 번 정도 나가서 이전 해커톤의 나에 비해서 얼마나 성장했는가 느껴보는 기회를 매년 가져야겠다는 생각이 들었다.","categories":[{"name":"Retrospect","slug":"retrospect","permalink":"https://philographer.github.io/categories/retrospect/"},{"name":"Competition","slug":"retrospect/competition","permalink":"https://philographer.github.io/categories/retrospect/competition/"}],"tags":[{"name":"retrospect","slug":"retrospect","permalink":"https://philographer.github.io/tags/retrospect/"}]},{"title":"travis-ci","slug":"Travis-CI","date":"2017-02-01T16:10:36.000Z","updated":"2018-03-08T05:00:57.690Z","comments":true,"path":"2017/02/02/Travis-CI/","link":"","permalink":"https://philographer.github.io/2017/02/02/Travis-CI/","excerpt":"","text":"들어가면서사실 CI Tool은 그동안 쓸 일이 많지 않았다. 그마저도 직접 쓴 적은 없고, Openstack 관련해서 Software maestro에서 1차 팀 프로젝트를 진행할 때 옆에서 팀원이 Jenkins를 사용하는 것을 본 것이 전부이다. 현재 맡은 업무가 프론트쪽에 가까워서 시스템 쪽으로 따로 공부할 일도 없지만, 오픈소스 프로젝트들을 보면 무조건 CI를 사용하고 있고, Test coverage system 또한 갖추어 놓았다. 어차피 이번 해커톤에 나가서 Auto Deployment 때문에라도 공부할 거 빨리 공부하는 게 좋다고 생각해서 포스팅을 작성한다. CI 란? 우선 CI란 Continuos Intergration의 줄임말이다. Travis 란? Getting started모든 개발 Document에는 Getting started가 있다. 천천히 따라해보자. Travis CI Getting started문서를 읽다 보니 링크를 하나 더 발견했다. Travis CI for Complete Beginners 완전 초보자를 위한 문서위 문서를 번역하면 다음과 같다. Test용 PHP Repository 를 Folk한다 https://travis-ci.org/auth에서 github계정으로 회원가입을 하고 Travis에게 권한을 준다. https://travis-ci.org/profile/yoohoogun114에서 아까 folk한 repo를 선택한다. 자신이 Folk한 Repo를 clone한다. ($ git clone 자신의리포주소) Clone한 폴더에서 vi .travis.yml 로 .travis.yml 파일의 내용을 본다.123456language: phpphp:- 5.5- 5.4- hhvmscript: phpunit Test.php PHP 5.5버전, 5.4버전, HHVM(테스트 오픈소스) 이 적혀있고, 마지막 라인에는 Unit Test 파일이 적혀있다. vi NewUser.txt 라는 명령어로 텍스트 파일을 만들고 자신의 이름을 적은 후 저장한다. 그다음으로 다음 명령어를 실행하여 커밋하고, 푸시한다.123$ git add -A$ git commit -m 'Testing Travis CI'$ git push build status 그러면 여기서 빌드 상태를 볼 수 있고, 빌드가 완료(성공, 실패)하면 메일이 날아간다. 처음 빌드는 무조건 실패한다. 왜냐하면, 테스트 코드가 무조건 실패하도록 적혀있기 때문이다. 우리에게 시작하자마자 실패를 안겨주는 Travis 팀 vi Test.php 로 테스트 코드를 수정해보자. 테스트 라인을 $this-&gt;assertEquals(1+1,2); 이렇게 고치면 된다. 아래는 완성된 코드 12345678910&lt;?phpclass Test extends PHPUnit_Framework_TestCase&#123; public function testOnePlusOne() &#123; $this-&gt;assertEquals(1+1,2); &#125;&#125;?&gt; assertEquals, $this 이런 문법은 php 문법이기에, 이 포스팅에서는 중요하지 않다. 단지 ‘php에서는 저렇게 테스트코드를 작성하는구나!’ 라는 정도로 넘어가면 된다. 똑똑한 우리는 무조건 성공하는 테스트 코드를 작성하였다. 다시 commit을하자. 123$ git add -A$ git commit -m 'Testing Travis CI: fixing the build'$ git push build status 다시 빌드 상태를 보면 다음과 같이 성공한다. 우리는 반드시 이긴다. 마치면서우리는 CI가 무엇인지, Travis가 무엇인지, Travis가 우리에게 무엇을 해줄 수 있는지 알아보았다. 이제는 자신이 필요한 언어로, Travis를 어떻게 상용하는지 알아보자.글쓴이는 주력 언어가 Javascript이므로 Javascript-Travis를 참조하도록 하겠다. 다음 포스팅은 Javascript Travis로 이어진다.","categories":[{"name":"DevOps","slug":"devops","permalink":"https://philographer.github.io/categories/devops/"}],"tags":[{"name":"devops","slug":"devops","permalink":"https://philographer.github.io/tags/devops/"}]},{"title":"Node, Express, Typescript, Mongo project boilerplate","slug":"Node-Express-Typescript-Mongo-project-boilerplate","date":"2017-01-30T14:31:17.000Z","updated":"2018-03-08T05:00:57.682Z","comments":true,"path":"2017/01/30/Node-Express-Typescript-Mongo-project-boilerplate/","link":"","permalink":"https://philographer.github.io/2017/01/30/Node-Express-Typescript-Mongo-project-boilerplate/","excerpt":"","text":"개요작년 제2회 유니톤(대학생 연합 해커톤)에 나가면서, 절실히 느꼈던 것은 미리 준비해 갈 수 있는 것들에 대해서 준비하지 않아서 애를 많이 먹었다. 예를 들어 프로젝트의 boilerplate, 프로젝트 디렉토리 설정, linter설정, db connect, server config, aws설정을 미리 해갈 수 있었다면 좀 더 빨리 기능구현을 할 수 있지 않을까 생각했다. Boilerplate란? Boilerplate는 변경 없이 재 사용할 수 있는 물품을 말한다. 이 용어는 철강쪽에서 유래된 단어로, 보일러 플레이트는 증기 보일러 내에 사용되는 커다란 압연 강판을 말한다. 이처럼, 오랜 기간동안 사용되었으며 튼튼하거나 반복적으로 재사용하기 충분한 정도로 만들어진 물품을 말한다. 소프트웨어에서는, 일종의 기본설정이 되어있고 디렉토리설정이 되어있는 재사용 가능한 템플릿 이라고 볼 수 있다. 가장 유명한 boilerplate는 아마도 HTML5 Boilerplate: The web’s most popular front-end template가 아닐까. Node.js란? Node.js는 크롬 V8 Javascript Engine위에서 동작하는 Javascript runtime이고 이벤트-드리븐 방식, non-blocking I/O를 사용하므로 가볍고 효율적이다. node의 생태계중 하나인 NPM은 세계에서 가장 큰 오픈소스 생태계 중 하나이다. 무슨 소리인지 하나도 모르겠다. 라고 생각하는 독자가 있다면 단어 하나하나에 걸려있는 링크를 참조하며 이해하도록 하자. 개발자가 되려면 모르는 것을 검색하고 스스로 학습하는 습관을 들여야 한다. Node에 대한 기본 지식이 없다면 간단히 Mooc에서 기본 개념정도는 알아두고 시작하는 것이 좋다고 생각한다. 추천하는 Mooc는 역시 codeschool의 Node.js Tutorial | Code School , Express.js Tutorial | Code School를 참조하는 것이 좋다. codeschool은 유료기는 하지만 충분이 가격 대비 품질이 보증되는 Mooc이므로 무조건 추천한다. Typescript란? Typescript는 순수한 자바스크립트로 컴파일되는 자바스크립트 superset이다. 컴파일 타임에서 타입을 체크하는 언어이고, Microsoft가 주요 Maintainer이며 Angular , Ionic Framework , Aurelia, DoJo등 많은 오픈소스에서 이미 채택되어 사용중이다.쉽게 말하면 타입이 있는 자바스크립트이다. 타입스크립트는 3가지 특징을 가지고있다. Type checking자바스크립트에서 type은 동적타이핑이며 이는 코딩할 때에 많은 이슈를 불러왔다. 예를들어 함수의 인자로 type을 검사하지 않기 때문에 String에서 Number관련 내장 함수를 사용하여 오류가 나는등 여러 이슈가 있다.유연함이 생산성을 늘리는 것은 맞지만 도리어 해가 될때도 있다. 자바스크립트를 한번이라도 써본 사람이라면 타입이 있었으면 하는 바람을 가지고 있을 것이다. 이를 해결해 준것이 Typescript이다. Compiletypescript로 작성한 파일에 컴파일 명령어를 치면 ecma5로 작성된 js를 자동으로 생성해준다. 그러므로 대부분의 브라우져에서 그대로 사용할 수 있다. Objective Oriented Programming마지막으로 OOP이다. typescript는 es6처럼 class를 가지고 있고 이는 그동안 자바스크립트가 가지고 있던 난해한 prototype으로 설계하는 방식에서 벗어나 다른 프로그래밍 언어와 비슷한 OOP를 적용할 수 있게 되었다는 점이다. Mongo DB란? MongoDB는 대표적인 NoSQL으로 알려져있다. Scheme에 제약된 조건이 없으며 row수가 많은 데이터를 보관, 검색이 간편하고 scale-out에 장점을 가지고 있는 DB로 알려져있다.사실 필자도 사이드 프로젝트를 하면서 Codeschool 강의를 참조하고, CRUD정도 작성해 본 것이 전부이기 때문에 다음 포스팅에서 자세히 작성하겠다. Getting Started자 이제 기본 개념들을 알았으니 한번 사용해보자.물론, 이 블로그 아티클을 보는 사람의 컴퓨터에 Node.js 환경이 구축되어 있다는 것을 가정한다. 만약 Node.js가 구축되지 않은 환경이라면 Node.js 설치 링크를 참조하고 난 후 진행한다. Node.js 환경이 구축되어 있다면 NPM이 설치되어 있을 것이다. 1. NPM이 설치되어 있는지 확인12$ npm -v4.0.5 2. npm을 이용해 typescript, tslint 를 global로 설치한다.1$ npm install -g tslint typescript TSLint 란 typescript 전용 linter이다. linter는 여러명이서 협업을 진행할때 코딩 스타일, 코딩 컨벤션을 지정해 주는 툴이고 보면 된다. 유명한 linter에 관한 짤은 다음 그림을 참조하자. 이 프로젝트에서 쓰지 않지만 typings와 tsd에 대해서 궁금한 사람들이 혹시 있을까봐 적는다.typings란 기존 자바스크립트 라이브러리들의 타입 정보만을 선언한 파일을 내려받을 수 있도록 도와주는 tool이다. 적다 보니 이제 안 쓴단다.이전엔 TSD라는 typings와 비슷한 definition manager가 있었으나 Deprecated 되고 typings로 옮겨졌다.그리고 typings 마저도 이제 안 쓴다. 사실 필자도 설치하는 방법, 설정들을 정리하면서 @types/package들과 typings둘의 차이점에 대해서 몹시 궁금해졌다. 아무거나 적당히 사용하면 되는게 아닌가? 했지만 블로그에 글을 실으려면 정확한 정보를 제공해야 하기 때문에 구글링을 해 보았다. 구글 검색어: typings vs @type (외국도 한국처럼 vs를 참 좋아한다. 2가지 비교하고 싶으면 compare보다 vs를 치는게 훨씬 잘 나오는듯)역시나 갓버플로우 형님들이 깔끔한 답변을 넣어줬다.TypeScript typings in NPM @types org packages - Stack Overflow3줄요약 typescript 2.0넘으면 typings가 필요없다. Microsoft에서 npm에 developer team을 갈아넣어서 maintain 할 것이다. npm에서 설정만 하면 다 해줌. 결론적으로는 $ npm install @types/express 로 라이브러리를 설치하고import * as express from &quot;express”; 이렇게 사용한다. 3. Express generator를 이용해 프로젝트 기본 Scaffolding을 한다.필자는 Webstorm을 주로 사용하고, Webstorm에서 node project를 만들때는Webstorm의 file탭-new탭-project를 클리하면 다음 화면이 나오고, 원하는 generator 버전, template 엔진을 선택한다. Webstorm을 깔기 싫은 독자는 커맨드라인을 이용한다. GitHub - expressjs/generator: Express’ application generator을 사용한다.123$ npm install -g express-generator$ express --view=jade 만들프로젝트경로 &amp;&amp; cd 만들프로젝트경로$ npm install API 서버를 만들것이기에 Template엔진은 default로 설정되어있는 jade를 우선 깔고 나중에 필요없는 코드를 삭제한다. 4. 프로젝트를 만들었으니 접속1$ npm start 그다음 http://localhost:3000/ 에 접속하면 Express의 Wellcome to Express 화면을 볼 수 있다. 다음 화면을 볼 수 있으면 여기까지 잘 설치된 것이다. 5. Typescript 컴파일 설정을 한다12$ tsc --initmessage TS6071: Successfully created a tsconfig.json file. 위 커맨드로 tsconfig.json 파일이 생성되고 열어보면 다음과 같다. 12345678&#123; \"compilerOptions\": &#123; \"module\": \"commonjs\", \"target\": \"es5\", \"noImplicitAny\": false, \"sourceMap\": false &#125;&#125; CommonJS 는 브라우저 뿐만 아니라 서버사이드 애플리케이션이나 데스크톱 애플리케이션에서 사용되기 위한 javascript 명세이다. ts를 es5의 js로 컴파일 한다는 설정이다. 6. js파일들을 ts로 모두 바꾸자 Project/app.js =&gt; app.ts Project/bin/www =&gt; www.ts Project/router/index.js =&gt; index.ts 7. Tslint Config1$ tslint —init 위 커맨드를 입력하면 tslint.json파일이 생성되고, 이 파일에는 json구조로 규칙이 저장되어있다. 규칙을 수정하고 싶으면 tslint를 설정하는 규칙은 Tslint Rules을 참조하여 수정하면 된다.간단히 설명하자면 대부분 첫번째 인자로의 true, false는 규칙 적용 여부, 그 뒤의 string은 옵션이다.필자는 string이나 path에서 double quote(“)가 아닌 single quote(‘)를 사용하므로 이를 수정한다.12345678~~~&#123;“quotemark”: [ true, “single” //기존 “double” ],&#125;~~~ Webstorm에서는 다음과 같이 설정하면 빨간 밑줄을 띄워주고, 대체로 editor나 IDE단에서 linter정도는 지원해 주므로 밑줄또는 경고등을 띄워준다. 커맨드라인에서 linter를 적용하고 싶으면 다음을 입력하면 된다. 1$ tslint -c path/to/tslint.json ‘path/to/project/**/*.ts’ linter를 적용하고 나면 여러 경고를 만날 수 있는데, 이 경고에 따라 수정하면 된다. 대체로 처음 설정후 만나는 linter의 경고에서는 변수가 아닌 값들을 var가 아닌 const나 let으로 강제하는 것들이 대부분이다. 8. exportapp.js의 마지막줄 module.export를 export default로 바꿈, routes/index.ts,routes/users.ts도 module.export를 export default로 바꾼다.1export default app; // module.exports = app; 9. livereloadnode는 기본적으로 코드를 변경하고 난 후에 서버를 재시작해야 그 코드가 반영된다. 매번 ctr + c, 서버 재시작하기 귀찮음을 많이 느껴보았으므로 livereload 기능은 써보니 엄청나게 편하다! 이를 설정하는 방법은 다음과 같다. npm install nodemon –save-dev npm install concurrently –save-devconcurrently는 여러 명령어를 한번에 실행시키는 node module이다. 12345678&#123;…\"scripts\": &#123; \"start\": \"npm run build:live\", \"concurrently \\\"tsc -w\\\" \\\"nodemon ./bin/www.js --config nodemon.json\\\"\" &#125;,...&#125; 위의 스크립트를 넣음으로써 동작은 다음과 같다. 1. npm start를 입력하면 typescript 컴파일러에 의해 코드의 변경을 감지하면 자동으로 컴파일을 진행(typescript =&gt; javascript) 2. nodemon은 컴파일된 javascript 파일의 변화를 감지하고 재시작한다 위의 방법이 싫으신 분은 ts-node사용하는 방법도 있다.Bonus: Live compile + run 10. 역시 소스코드 수정후 잘 돌아가는지 검사123456789101112131415$ npm strtyuhogyun-ui-MacBook-Pro:boilerplate yuhogyun$ npm start&gt; boilerplate@0.0.0 start /Users/yuhogyun/boilerplate&gt; npm run build:live&gt; boilerplate@0.0.0 build:live /Users/yuhogyun/boilerplate&gt; concurrently \"tsc -w\" \"nodemon ./bin/www.js --config nodemon.json\"[1] [nodemon] 1.11.0[1] [nodemon] to restart at any time, enter `rs`[1] [nodemon] watching: *.*[1] [nodemon] starting `node ./bin/www.js` 11. Mongodb, Mongoose 설치 및 코드작성우선 MongoDB Download Center | MongoDB 이 링크에서 몽고디비를 설치한다. 그다음 몽고디비 서버를 켠다1$ mongod mongoose 는 Mongo를 node에서 사용하기 위한 object model이라고 보면 된다.typescript에서 mongoose를 이용하려면 DefinitelyTyped/mongoose를 따라해보자.123456789101112131415161718192021222324252627282930313233343536/** Mongoose Config **/var mongoose = require('mongoose');mongoose.Promise = global.Promise;mongoose.connect('mongodb://localhost/boilerplate');import &#123;Document, model, Model, Schema&#125; from 'mongoose';var UserSchema: Schema = new Schema(&#123; username: &#123; type: String, required: true, unique: true &#125;, age: Number, friends: [String], data: [Schema.Types.Mixed]&#125;);interface IUser extends Document &#123; username: string; age: number; friends: string[]; data: any[];&#125;var UserModel: Model&lt;IUser&gt; = model&lt;IUser&gt;('User', UserSchema);var user = new UserModel(&#123;user.username: 'Jane'&#125;);user.username; // IUser properties are availableuser.save(); // mongoose Document methods are availableUserModel.findOne(&#123;&#125;, (err: any, user: IUser) =&gt; &#123; user.username; // IUser properties are available user.save(); // mongoose Document methods are available&#125;); Reference Demo Project블로그 글을 쓰며 개인용으로도 쓸겸 typescript node mongo express로 기본 CRUD API 서버를 만들어보았다.위의 긴 과정을 생략하고 싶은 독자들은 다음 링크를 참조하자.https://github.com/yoohoogun114/node-express-mongo-typescript 글을 마치며Typescript가 트렌드가 될지 안 될지는 모르겠지만, 우선 javascript에서 타입 부여가 가능하다는 것은 매우 큰 장점이다. Typescript 말고도 관련 오픈소스 프로젝트들을 둘러보았는데 아주 활발한 것 같아서 아마 미래는 밝은 듯 하다. 또한 그동안 MEAN스택에서 빠져있던 mongo를 채우니 이제 드디어 완성인 것 같은 느낌이다. 참고자료TypeScript with NodeJSInclude TypeScript files by default by arosequist · Pull Request #871 · remy/nodemon · GitHub","categories":[{"name":"Javascript","slug":"javascript","permalink":"https://philographer.github.io/categories/javascript/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"https://philographer.github.io/tags/typescript/"}]},{"title":"git-lifecycle","slug":"git-lifecycle","date":"2017-01-27T04:30:55.000Z","updated":"2018-03-08T05:00:57.706Z","comments":true,"path":"2017/01/27/git-lifecycle/","link":"","permalink":"https://philographer.github.io/2017/01/27/git-lifecycle/","excerpt":"","text":"Lifecycle이란?짧게 말하면 한국어로 생명주기이다. 안드로이드의 Activity 라이프사이클(물론 글쓴이는 네이티브 안드로이드를 해보지 않았다.)React의 Component 라이프사이클, IOS의 View 라이프사이클 등등이 있다. 대체로 아래 그림과 같은 구조를 가지고 있다. 다만 cycle이라고 해서 꼭 순환되지는 않는 경우도 있다. (역주행 하는 경우도 있다.) Git의 lifecycleGit에도 이처럼 4가지의 Lifecycle을 가지고 있다. Untracked Unmodified Modified Staged 말로만 설명하면 어려우니 아래 그림을 참조해보자. 명령어와 같이 볼 수 있어서 더 이해가 쉬운 그림이다.","categories":[{"name":"Vcs","slug":"vcs","permalink":"https://philographer.github.io/categories/vcs/"},{"name":"Git","slug":"vcs/git","permalink":"https://philographer.github.io/categories/vcs/git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://philographer.github.io/tags/git/"}]},{"title":"gitignore","slug":"gitignore","date":"2017-01-27T02:39:15.000Z","updated":"2018-03-08T05:00:57.708Z","comments":true,"path":"2017/01/27/gitignore/","link":"","permalink":"https://philographer.github.io/2017/01/27/gitignore/","excerpt":"","text":"개요Git으로 프로젝트를 관리할때 무시할 파일들이 있다.대표적으로 node_modules 디렉토리에 있는 npm 모듈이라던지, .idea 같은 jet brains 사의 개발툴 설정 같은 파일, 디렉토리는 git에 올릴 필요가 없다.그런 파일들은 git에 올릴때 무시할 수 있는 설정이 있다.바로 gitignore이다. .gitignore의 기능gitignore의 기능은 짧게 말하자면 어떤 파일을 git에서 무시할지 규칙을 설정하는 파일이다. .gitignore 규칙.gitignore에 입력하는 패턴은 아래 규칙을 따른다 아무것도 없는 라인이나, # 로 시작하는 라인은 무시한다(주석) 표준 Glob 패턴을 사용한다. (Glob은 정규표현식을 단순하게 만든 것) 슬래시(/)로 시작하면 하위디렉토리에는 적용되지 않는다. 디렉토리는 슬래시를 끝에 사용하는 것으로 표현한다 느낌표(!)로 시작하는 패턴의 파일은 무시하지 않는다. .gitignore 예제1234567891011121314151617# 확장자가 .a인 파일은 무시*.a# 윗 라인에서 확장자가 *.a인 파일은 무시햇지만 lib.a는 무시하지 않음!lib.a# 현재 디렉토리에 있는 TODO 파일은 무시하고 subdir/TODO처럼 하위 디렉토리에 있는 파일은 무시하지 않음/TODO# build/ 디렉토리에 있는 모든 파일은 무시build/# doc/notes.txt 파일은 무시하고 doc/server/arch.txt 파일은 무시하지 않음doc/*.txt# doc 디렉토리 아래에 모든 .pdf 파일은 무시doc/**/*.pdf 유용한 서비스사실 이 부분이 가장 중요하다.반복적인 작업은 전 세계인이 똑같이 느끼고 있다. 처음부터 무언가를 만들어 보는 경험도 중요하지만, 우리는 생산성을 위해서는 누군가 잘 만들어 놓은것을 알맞게 사용하는 것도 하나의 실력이 되는 시대에 살고있다.따라서 우리는 유용한 서비스를 알아보겠다.https://www.gitignore.io/들어가보면깔끔한 페이지를 볼 수 있다. 대체로 내가 설정하는 옵션은 다음과 같다. 위와 같이 설정하고 generate 버튼을 누르면123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131# Created by https://www.gitignore.io/api/macos,webstorm,node### macOS ###*.DS_Store.AppleDouble.LSOverride# Icon must end with two \\rIcon# Thumbnails._*# Files that might appear in the root of a volume.DocumentRevisions-V100.fseventsd.Spotlight-V100.TemporaryItems.Trashes.VolumeIcon.icns.com.apple.timemachine.donotpresent# Directories potentially created on remote AFP share.AppleDB.AppleDesktopNetwork Trash FolderTemporary Items.apdisk### WebStorm #### Covers JetBrains IDEs: IntelliJ, RubyMine, PhpStorm, AppCode, PyCharm, CLion, Android Studio and Webstorm# Reference: https://intellij-support.jetbrains.com/hc/en-us/articles/206544839# User-specific stuff:.idea/workspace.xml.idea/tasks.xml# Sensitive or high-churn files:.idea/dataSources/.idea/dataSources.ids.idea/dataSources.xml.idea/dataSources.local.xml.idea/sqlDataSources.xml.idea/dynamic.xml.idea/uiDesigner.xml# Gradle:.idea/gradle.xml.idea/libraries# Mongo Explorer plugin:.idea/mongoSettings.xml## File-based project format:*.iws## Plugin-specific files:# IntelliJ/out/# mpeltonen/sbt-idea plugin.idea_modules/# JIRA pluginatlassian-ide-plugin.xml# Crashlytics plugin (for Android Studio and IntelliJ)com_crashlytics_export_strings.xmlcrashlytics.propertiescrashlytics-build.propertiesfabric.properties### WebStorm Patch #### Comment Reason: https://github.com/joeblau/gitignore.io/issues/186#issuecomment-215987721# *.iml# modules.xml# .idea/misc.xml# *.ipr### Node #### Logslogs*.lognpm-debug.log*# Runtime datapids*.pid*.seed*.pid.lock# Directory for instrumented libs generated by jscoverage/JSCoverlib-cov# Coverage directory used by tools like istanbulcoverage# nyc test coverage.nyc_output# Grunt intermediate storage (http://gruntjs.com/creating-plugins#storing-task-files).grunt# node-waf configuration.lock-wscript# Compiled binary addons (http://nodejs.org/api/addons.html)build/Release# Dependency directoriesnode_modulesjspm_packages# Optional npm cache directory.npm# Optional eslint cache.eslintcache# Optional REPL history.node_repl_history# Output of 'npm pack'*.tgz# Yarn Integrity file.yarn-integrity# End of https://www.gitignore.io/api/macos,webstorm,node 다음과 같은 text 파일을 얻을 수 있을 수 있다.프로젝트 폴더에 .gitignore 라는 파일을 만들고 위의 내용을 붙여넣은 다음 git에 커밋하면 완성된 .gitignore를 얻을 수 있다. 무척 편하지 않은가! 위의 파일을 자신의 입맛대로 수정하면 된다.","categories":[{"name":"Vcs","slug":"vcs","permalink":"https://philographer.github.io/categories/vcs/"},{"name":"Git","slug":"vcs/git","permalink":"https://philographer.github.io/categories/vcs/git/"}],"tags":[{"name":"vcs","slug":"vcs","permalink":"https://philographer.github.io/tags/vcs/"}]},{"title":"Object Array를 key에 의해 정렬하기","slug":"objectArraySortByKey","date":"2017-01-22T16:15:45.000Z","updated":"2018-03-08T05:00:57.711Z","comments":true,"path":"2017/01/23/objectArraySortByKey/","link":"","permalink":"https://philographer.github.io/2017/01/23/objectArraySortByKey/","excerpt":"","text":"개요개발하고 있는 Application에서 Object의 Array를 Key에 의해 정렬할 일이 생겼다.Array에 int나 string이 담겨 있을 때는, 그냥 sort() 메소드를 사용하면 되지만, Object가 들어있을 때는 조금 까다롭다. Array.sort() 함수요즈음, Javascript에 대한 메소드를 검색하다보면, MDN(Mozilla Developer Network)에 있는 문서를 주로 보게 된다. 가장 깔끔한 형식이고, 예제도 무척이나 쉽다! sort() 메소드는 누구나 알고 있겠지만 배열의 요소를 정렬하고 배열을 반환한다.(String의 정렬 순서는 유니코드 순서에 따른다. 주의할 점은 유니코드에서 숫자는 대문자 앞에 온다는 점이다.) Array.sort() 함수의 파라미터재미있는 점은 sort 함수의 파라미터는 2가지가 있다.1. arr.sort()2. arr.sort(compareFunction(a,b)) //인자 2개를 받는 함수.그동안 파라미터가 없이는 자주 사용했지만, 파라미터에 무언가를 담지는 않았다.파라미터를 담아서는 어떻게 사용할까?compareFunction은 인자 2개를 받아서 사용한다. 예를들자면, 다음과 같이 사용한다.123456789let unSortedObjArr = [&#123; c: 100,&#125;,&#123; c: 50&#125;,&#123; c: 10&#125;];unSortedObjArr.sort((a, b) =&gt; &#123;&#125;); // 이 부분! 재미있는 점은, compareFunction의 반환 값에 따라 요소를 정렬한다는 점이다. 반환 값이 0보다 작으면 a를 b보다 먼저 정렬한다. (a가 b 앞에 온다는 말이다.) 반환 값이 0이면 a와 b를 변경하지 않고 나머지 요소에 대하여 정렬한다 (정렬 x) 반환 값이 0보다 크면 b를 a보다 먼저 정렬한다. (b가 a 앞에 온다는 말이다.) 자 이제 본래 의도였던, Object Array를 Value에 의해 정렬해보자.1234567891011121314151617181920212223let items = [ &#123; name: 'Edward', value: 21 &#125;, &#123; name: 'Sharpe', value: 37 &#125;, &#123; name: 'And', value: 45 &#125;, &#123; name: 'The', value: -12 &#125;, &#123; name: 'Magnetic' &#125;, &#123; name: 'Zeros', value: 37 &#125;];// sort by valueitems.sort(function (a, b) &#123; if(a.hasOwnProperty('value'))&#123; return a.value - b.value; &#125;&#125;);console.log(items)/* [ &#123; name: 'The', value: -12 &#125;, &#123; name: 'Edward', value: 21 &#125;, &#123; name: 'Sharpe', value: 37 &#125;, &#123; name: 'And', value: 45 &#125;, &#123; name: 'Magnetic' &#125;, &#123; name: 'Zeros', value: 37 &#125; ] */ 추가로 Object Array를 Key에 의해 정렬해보자.1234567891011121314151617181920212223let items = [ &#123; name: 'Edward', value: 21 &#125;, &#123; name: 'Sharpe', value: 37 &#125;, &#123; name: 'And', value: 45 &#125;, &#123; name: 'The', value: -12 &#125;, &#123; name: 'Magnetic' &#125;, &#123; name: 'Zeros', value: 37 &#125;];// sort by name(key)items.sort(function(a, b) &#123; var nameA = a.name.toUpperCase(); // ignore upper and lowercase var nameB = b.name.toUpperCase(); // ignore upper and lowercase return nameA - nameB;&#125;);console.log(items);/* [ &#123; name: 'Edward', value: 21 &#125;, &#123; name: 'Sharpe', value: 37 &#125;, &#123; name: 'And', value: 45 &#125;, &#123; name: 'The', value: -12 &#125;, &#123; name: 'Magnetic' &#125;, &#123; name: 'Zeros', value: 37 &#125; ] */ Array.sort() 함수의 알고리즘 및 내부원하던 Object의 배열은 끝이 났지만, 한 번 더 깊이 들어가 보자.sort()함수는 어떤 정렬을 사용할까? Bubble sort? Merge sort? Select sort?어떤 정렬인지 한번 내부를 보자.예제를 써보고, 안 되면 구글링을 해보자 12345678910111213141516171819202122232425262728293031323334353637383940let unSortedObjArr = [&#123; c: 4,&#125;,&#123; c: 3&#125;,&#123; c: 2&#125;,&#123; c: 1&#125;];let sortedObjArr = unSortedObjArr.sort((a, b) =&gt; &#123; console.log(a.c); console.log(b.c); console.log('========='); return a.c - b.c;&#125;);console.log(sortedObjArr);/* 43=========42=========32=========41=========31=========21=========*/ 무언가 이상하다고 생각하지 않는가? 그냥 봐서는 어떤 정렬인지 모르겠다. Google에 검색해 보았다. (검색어: javascript sort function algorithm)algorithm - Javascript Array.sort implementation? - Stack Overflow 요약해 보자면, 스택 오버플로는 선택된(첫 번째) 답글이 진리이지만, 답글보다 많이 vote를 받은 comment에 보면 이 답변은 선택되지 말았어야 했다고 적혀있다.다음 답글을 보니 첫 번째 답글보다 up vote가 많다. 뭔가 읽을 만 한가보다짧게 요약하자면 크롬이나 사파리에서 쓰는 웹킷에서는 Number type에서는 quicksort를 사용 String에서 가능하면 quicksort를, 불가능하면 mergesort를 사용 다른 타입의 배열에서는 selection sort를 사용여담으로 string은 radix sort로 O(n)이 되는게 아닌가 싶지만, 이 알고리즘은 runtime 에서 더 복잡도가 높아진다고 한다. 그래서 ‘quick소트를 사용한 것이구나’를 알 수 있다. 포스팅을 간단히 쓰려고 했는데 무척이나 길어지게 되었다.깊게 쓰려니 끝이 없는 것 같다!","categories":[{"name":"Javascript","slug":"javascript","permalink":"https://philographer.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://philographer.github.io/tags/javascript/"}]}]}