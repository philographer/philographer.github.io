<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Philographer&#39;s Blog</title>
  
  
  <link href="/feed.xml" rel="self"/>
  
  <link href="https://philographer.github.io/"/>
  <updated>2018-09-06T12:03:20.944Z</updated>
  <id>https://philographer.github.io/</id>
  
  <author>
    <name>Philographer</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>취업 후기 1-취업 준비편</title>
    <link href="https://philographer.github.io/2018/09/03/job-search-1/"/>
    <id>https://philographer.github.io/2018/09/03/job-search-1/</id>
    <published>2018-09-03T02:20:49.000Z</published>
    <updated>2018-09-06T12:03:20.944Z</updated>
    
    <content type="html"><![CDATA[<img src="/2018/09/03/job-search-1/gradu.jpg"><h2 id="개요"><a href="#개요" class="headerlink" title="개요"></a>개요</h2><p><strong>단군 이래로 취업이 가장 어려운 때</strong>인 바로 지금, 운이 좋게도 졸업 이전에 취업을 끝마치고 HR(Human Resources)과 입사 일정 조율을 하면서 쉬고 있던 도중 문득 <strong>대학교 졸업</strong> 및 <strong>취업</strong> 에 관한 경험담을 써야겠다고 마음을 먹었다. </p><p><strong><del>본래 사람이란 나태한 동물 인지라…</del></strong> 집에서 쓰기는 어려울 것으로 생각했다. 그래서 전날 아침에 조조 영화를 일부러 예매한 후, 보고 나서 더욱 심심할 때 즈음 카페에 나와서 몇 글자 적어본다.</p><h2 id="대학교-입학-고삐-풀린-망아지-1학년"><a href="#대학교-입학-고삐-풀린-망아지-1학년" class="headerlink" title="대학교 입학, 고삐 풀린 망아지 1학년"></a>대학교 입학, 고삐 풀린 망아지 1학년</h2><p>물론 모두가 힘들게 대학교에 입학했겠지만, 나에게는 그 기억이 무척 강하게 남아있다. 왜냐하면 부모님 항상 나에게 </p><blockquote><p>“대학만 가라. 그때까지는 공부에 집중하고 대학 가면 네가 놀고 싶은 만큼 놀아라”</p></blockquote><p>라고 말씀하시곤 하셨다. 나는 부모님의 말씀을 아주 잘 듣는 <strong><del>효자</del></strong>이므로 <strong>인하대학교</strong>에 입학해서는 정말 마음껏 놀았다. 늦게 들어오면 부모님이 걱정 하실까 봐 아예 밤을 새우고 아침 일찍 집에 들어갔으며, 몸을 못 가눌 만큼 술을 진탕 먹고 집에 다 들어와 현관문에 엎어지며 입술이 찢어져 응급실에 실려갈만큼!!! <strong>질령나게 놀아버렸다.</strong></p><p>당연하게도 열심히 놀았던 만큼 성적은 나를 배신하지 않았다. 가장 장학금을 받기 쉽다던 1학년 1학기, 2학기 모두 평점이 채 <strong>3</strong>이 채 되지 못했다. 1학년 2학기 성적표를 받아보고, 지금 이 타이밍이 바로 군대로 도망갈 타이밍이란 걸 직감하고 바로 <strong>해군에 자원입대</strong>하게 되었다.</p><h2 id="군생활"><a href="#군생활" class="headerlink" title="군생활"></a>군생활</h2><p>해군에서 <a href="https://namu.wiki/w/%EA%B3%A0%EC%86%8D%EC%A0%95" rel="external nofollow noopener noreferrer" target="_blank">고속정 </a>을 타며 먹고, 자는 생활을 했었다. 항해하고 정박하는 특성상 통신실을 지키거나, 현문(배의 입구)에서 혼자 당직을 서는 시간이 매우 많았었다. 새벽 &amp; 밤에 혼자서 할 일이 무엇이 있을까… <strong>”혼자 멍때리는 시간”</strong>을 무척 많이 가졌다. 밤바다를 바라보며 <strong>“제대 후 하고 싶은 일들, 앞으로의 미래”</strong>에 대해서 종이에 많이 끄적거렸던 것 같다. </p><p>이렇게 혼자 시간을 보내는 시간이 많으니, 당연하게도 스스로에 대해서 많은 고민도 해 보고, 제대해서는 1학년처럼 마냥 놀면서 시간을 보내면 안 된다고 생각했다. <strong>그렇게 많은 고민과 생각으로 제대하게 되었다.</strong></p><p>PS. 이 무렵, 우연히 연평해전이라는 영화가 주목받아 <a href="http://d.kbs.co.kr/news/view.do?ncd=2875604" rel="external nofollow noopener noreferrer" target="_blank">제1연평해전 15주년…승전 잇는 ‘서해 수호자’들</a> KBS에 인터뷰가 나가기도 했다.</p><h2 id="제대-이후-정신차린-2학년"><a href="#제대-이후-정신차린-2학년" class="headerlink" title="제대 이후, 정신차린 2학년"></a>제대 이후, 정신차린 2학년</h2><p>제대하며 코딩이란 코딩은 다 까먹어 버리고 2학년 1학기로 빠르게 복학하게 되었다. 복학했을 무렵에는, 여자 동기들은 취준생이기도 하고 남자 동기들은 아직 군대에 있는 친구들이 대부분이어서 같이 놀 사람도 많이 없었다. 시간이 없는 대학생이 혼자 술을 먹겠는가, 혼자 놀겠는가. 할 게 없으니 공부라도 해야지 하는 생각에 <strong>군대버프</strong>를 받아서 2학년 1학기에는 <strong>성적 우수자</strong>로 장학금을 받기도 했다.</p><p>우연히 2학년 1학기에 친구와 <strong>웹 프로그래밍</strong> 수업을 듣게 되었다. 전공 선택인 과목이라 듣지 않아도 되었지만, 그냥 코딩이 재밌어 보여서 수강하게 되었다. <strong>HTML5, CSS, Javascript, Apache, Tomcat, JSP</strong> 등을 배웠는데 혼자 개인 블로그를 만드는 것이 최종 프로젝트이자 한 학기에서 가장 큰 과제였다. 뭔가 계속 기능을 더 붙이고 싶어서 새벽까지 붙들고 기능을 추가하느라 안간힘을 썼던 기억이 많이 난다.</p><p>2학년 2학기가 끝나갈 무렵, 인터넷에서 <a href="https://likelion.net/" rel="external nofollow noopener noreferrer" target="_blank">멋쟁이사자처럼</a> 의 모집 글을 보게 되었다.  비 전공자와 함께하는, 만들고자 하는 서비스를 직접 프로그래밍하는 동아리 를 모토로 하는 동아리였는데 당시의 내 실력은 비전공자와 다름이 없었기에 무식하고 용감하게 지원하게 되었다. </p><p>복학 후 얼마나 심심했는지 <a href="https://likelion.net/" rel="external nofollow noopener noreferrer" target="_blank">멋쟁이사자처럼</a>에서 Ruby On Rails를 가지고 공강시간에 혼밥하는 학생들을 모아서 함께 밥을 먹는 프라이빗 소셜 다이닝 서비스 <a href="https://www.facebook.com/inhatastingparty/" rel="external nofollow noopener noreferrer" target="_blank">인하미식회</a> 를 런칭하기도 했다. 서비스는 교내 커뮤니티에서 이슈가 되면서 적지않은 관심을 가지게 되기도 하였으나 혼자 개발, 운영, CS, QA 모든 일을 할 수 없다는 것을 깨닫고 서비스를 종료하게 되었지만 <strong>직접 서비스 출시를 통해 학교 수업보다 많은 것을 느끼고 배웠다.</strong></p><h2 id="대외-활동-그리고-질풍의-3학년"><a href="#대외-활동-그리고-질풍의-3학년" class="headerlink" title="대외 활동, 그리고 질풍의 3학년"></a>대외 활동, 그리고 질풍의 3학년</h2><p><a href="https://likelion.net/" rel="external nofollow noopener noreferrer" target="_blank">멋쟁이사자처럼</a>을 시작으로, 대외활동에 재미를 붙이더니 3학년에는 <strong>수도권 대학생 디자이너, 개발자 IT 연합동아리</strong>인 <a href="http://teamnexters.com/" rel="external nofollow noopener noreferrer" target="_blank">NEXTERS</a>를 거쳐서 도제식 멘토링을 해주고, 창업을 지원해주는 <a href="https://namu.wiki/w/SW%20Maestro" rel="external nofollow noopener noreferrer" target="_blank">SW Maestro</a> 활동도 하게되었다. 무언가 하나의 기점을 출발해서 연쇄적으로 이어진 듯이 동아리&amp;활동을 찾고, 가입하고, 활동하게 되었다. 그리고 이 무렵에<a href="http://codeforincheon.github.io/homepage/" rel="external nofollow noopener noreferrer" target="_blank">CODE FOR INCHEON</a> 이란 도시문제 해결을 목적으로 한 NGO(Non-Governmental Organization) 활동도 하게 되었다. </p><p>이런저런 <strong>대외 동아리&amp;활동</strong>을 하다 보니, 여러 가지 프로젝트들을 개발할 기회도 생겼고 자연스럽게 교육, 스마트시티, O2O등 의 <strong>도메인 지식</strong>에 대해서 접할 기회도 있어서 유익했다.</p><p>활동들이 쌓이다 보니,  <a href="http://codeforincheon.github.io/homepage/" rel="external nofollow noopener noreferrer" target="_blank">CODE FOR INCHEON</a>에서 같이 활동하던 오거나이저 분이 운영하시는 스타트업인 <a href="http://teammondrian.com/" rel="external nofollow noopener noreferrer" target="_blank">Team Mondrian</a>에 같이 일해보자는 제안도 받았었다. 휴학했을때는 풀타임으로 일하고, 학교에 다니면서는 파트타임으로 일하며 본의 아니게 중고신입 같은 경력이 쌓이게 되었다.</p><p>3학년 때 가장 많이 기억에 나는 활동은 <strong>SW Maestro</strong>였다. 매달 나오는 지원금 100만원이 경제적 생활에 매우 큰 도움이 되기도 하였고, 현업에 종사하시는 멘토님의 실무적 프로젝트를 진행하며 개발 외적으로도 프로젝트 리딩, 기획, 퍼블릭 스피킹, 방법론(애자일) 등에서도 배울 기회가 있었던 게 성장에 큰 밑거름이었다.</p><h2 id="정리-그리고-4학년"><a href="#정리-그리고-4학년" class="headerlink" title="정리, 그리고 4학년"></a>정리, 그리고 4학년</h2><p>4학년이 되니, <strong>1학년 때 말아먹었던 학점을 복구</strong>하느라 고생했던 게 생각난다. 1학년 과정을 들으면서 본의 아니게 양학을 해버렸고 학점을 <strong>3.5</strong>로 겨우 복구하는 데 성공했다. </p><p>이 무렵 서버사이드, 그리고 AWS에 관심이 생겨서 <a href="https://www.slideshare.net/awskr/ausg-86146458" rel="external nofollow noopener noreferrer" target="_blank">AUSG</a>활동을 하기도 했고, 서울에 가는 활동들에 지쳐서 집 주변인 인천에서 모임이 이뤄지는 <strong>경상&amp;디자인&amp;공학 연합 동아리</strong> <a href="https://www.facebook.com/mdtconv/" rel="external nofollow noopener noreferrer" target="_blank">경디공</a> 에서 전시, 강의들을 하면서 활동을 했다.</p><p>4학년엔 주로 개발보다는, 이력서와 포트폴리오를 정비하고 다듬는 작업들, 어딘가에 가서 발표하는 일들을 많이 진행했다. 졸업 전 내가 해왔던 결과물들을 재정비할 수 있고 되돌아볼 수 있는 시간이 있어서 <strong>한층 더 발전한다는 느낌이 들었다.</strong></p><h2 id="마무리하며"><a href="#마무리하며" class="headerlink" title="마무리하며"></a>마무리하며</h2><p>그렇게 모든 활동과 대학생활이 끝나가는 시점인 4학년 1학기의 기말고사 즈음, 남들과 비슷하게 여러 가지 인턴 자리를 알아보다가 우연히 좋은 기회로 <strong>Naver</strong>에 인턴을 진행하기도 했다. 이제 4학년 2학기를 맞이하지만 웹강을 하나 들으면서 졸업할 수 있는 학점을 갖춰놓았기 때문에 별 이변이 없는 한 무탈하게 졸업하지 않을까 생각한다.</p><p>회고록을 적으면서, 이력서를 수정할 때면 <strong>“과거에 나는 정말 치열하게 살았구나”</strong> 라는 생각이 문득 든다. 그 당시엔 무척 힘들지는 않고 재미로 했었지만 그런 재미있는 활동들이 오늘의 나를 이룬 성장의 밑거름인 활동들인 것 같다.</p><p>글을 마무리 할 때 즈음, 내가 적는 다이어리에 이런 문장이 떠올라 이 말을 인용하며 글을 마무리한다.</p><blockquote><p>처음에는 도대체 “왜” 하냐고 물을 것이고<br>나중에는 도대체 “어떻게” 해낸 거냐고 물을 것이다.</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/2018/09/03/job-search-1/gradu.jpg&quot;&gt;
&lt;h2 id=&quot;개요&quot;&gt;&lt;a href=&quot;#개요&quot; class=&quot;headerlink&quot; title=&quot;개요&quot;&gt;&lt;/a&gt;개요&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;단군 이래로 취업이 가장 어
      
    
    </summary>
    
      <category term="Retrospect" scheme="https://philographer.github.io/categories/retrospect/"/>
    
      <category term="Personal" scheme="https://philographer.github.io/categories/retrospect/personal/"/>
    
    
      <category term="후기" scheme="https://philographer.github.io/tags/%ED%9B%84%EA%B8%B0/"/>
    
  </entry>
  
  <entry>
    <title>Flex의 사용방법</title>
    <link href="https://philographer.github.io/2018/04/22/flex/"/>
    <id>https://philographer.github.io/2018/04/22/flex/</id>
    <published>2018-04-22T06:34:46.000Z</published>
    <updated>2018-04-22T06:57:00.192Z</updated>
    
    <content type="html"><![CDATA[<h2 id="개요"><a href="#개요" class="headerlink" title="개요"></a>개요</h2><p>학교 컴파일러 과제를 진행하다가 <code>Flex</code>를 사용해 볼 기회가 있었다. 이론 수업을 듣다 보면 어느 정도 이해가 가기는 하지만, 본래 프로그래밍이란게 <strong>백문이 불여일타</strong> 이기 때문에 직접 작성해 보고 언제 쓸 수 있을지는 모르겠지만 기록으로 남겨두어야겠다는 생각이 들어서 블로그 아티클을 작성해본다.</p><h2 id="lex란"><a href="#lex란" class="headerlink" title="lex란?"></a>lex란?</h2><p><strong>Flex</strong>에 대하여 말하기 이전에, <strong>Lex</strong>에 대해서 이해해야 한다. <strong>Lex</strong>란 <strong>Lexical Analyzer Generator</strong>이다. 이 말인즉슨, 어떠한 규칙에 따라서 Input Stream으로 들어온 Source Code를 미리 정의된 문법 규칙에 따라서 Tokenize해 주는 것 Lexical을 말한다. 다시 말하면 Lexical Analyzer의 주 역할은 다음과 같다.<br><strong>Lexical Analyzer의 역할: Source Code -&gt; Token으로 Tokenize해 준다.</strong><br><img src="/2018/04/22/flex/flex.jpg"></p><h2 id="flex란"><a href="#flex란" class="headerlink" title="flex란?"></a>flex란?</h2><p>그렇다면 flex란 무엇일까?  <strong>Flex</strong>는 <strong>Fast Lexical Analyzer Generator</strong> 란 것으로 Lex의 <strong>Open-Source</strong> 버전이라고 생각하면 된다.</p><h2 id="flex-설치하기"><a href="#flex-설치하기" class="headerlink" title="flex 설치하기"></a>flex 설치하기</h2><p>필자의 환경은 Mac이므로 Mac 기준으로 설명하겠다.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew install flex</span><br></pre></td></tr></table></figure></p><h2 id="flex-사용하기"><a href="#flex-사용하기" class="headerlink" title="flex 사용하기"></a>flex 사용하기</h2><p>기본적인 Lex 파일의 구조는 다음과 같다.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* FileName: lex.l */</span></span><br><span class="line"></span><br><span class="line">%&#123;</span><br><span class="line"><span class="comment">/* C Header Include, Define */</span></span><br><span class="line">%&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* regexp definitions */</span></span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line"><span class="comment">/* Translation Rules */</span></span><br><span class="line">%%</span><br><span class="line"></span><br><span class="line"><span class="comment">/* C Code */</span></span><br><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment">Already Defined Variables</span></span><br><span class="line"><span class="comment">yyval = Lexeme Begin</span></span><br><span class="line"><span class="comment">yytexr = Pointer To Lexeme begin</span></span><br><span class="line"><span class="comment">yyleng = Length of Lexeme</span></span><br><span class="line"><span class="comment">***/</span></span><br></pre></td></tr></table></figure></p><p>그러면 예제 코드를 작성해 보도록 하자. 아래 프로그램은 In-fix -&gt; Post-Fix 변환하는 코드이다.  예를들어 1+2+3을 입력하면 12+3+으로 변환해 준다.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* FileName: lex.l */</span></span><br><span class="line"></span><br><span class="line">%&#123;</span><br><span class="line"><span class="comment">/* C Header Include, Define */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUMBER 256 <span class="comment">// 숫자</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IDENTIFIER 257 <span class="comment">// 변수</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OPERATOR 258 <span class="comment">// 덧셈, 뺄셈 연산자</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFSIZE 100 <span class="comment">// 버퍼 사이즈, 배열 크기</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EOL 100 <span class="comment">// 엔드 오브 라인</span></span></span><br><span class="line"></span><br><span class="line">%&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* regexp definitions */</span></span><br><span class="line">num ([<span class="number">0</span><span class="number">-9</span>]*[.])?([<span class="number">0</span><span class="number">-9</span>]+)([E][-]?[<span class="number">0</span><span class="number">-9</span>]+)?</span><br><span class="line">EOL \n</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line"><span class="comment">/* Translation Rules */</span></span><br><span class="line">&#123;num&#125; &#123; <span class="keyword">return</span> NUMBER; &#125;</span><br><span class="line">[a-zA-Z0<span class="number">-9</span>]+ &#123; <span class="keyword">return</span> IDENTIFIER; &#125;</span><br><span class="line">[+,-] &#123; <span class="keyword">return</span> OPERATOR; &#125;</span><br><span class="line">&#123;EOL&#125; &#123;<span class="keyword">return</span> EOL;&#125;</span><br><span class="line">%%</span><br><span class="line"></span><br><span class="line"><span class="comment">/* C Code */</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main () &#123;</span><br><span class="line"><span class="keyword">char</span> operatorStack[BUFSIZE]; <span class="comment">// 연산자 스택</span></span><br><span class="line"><span class="keyword">int</span> operatStackTopIdx = <span class="number">-1</span>; <span class="comment">// 스택의 Top Index</span></span><br><span class="line"><span class="keyword">int</span> token;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> ((token = yylex()) != EOL) &#123; <span class="comment">// 토큰이 끝이라면 종료</span></span><br><span class="line"><span class="keyword">switch</span> (token) &#123;</span><br><span class="line">        <span class="keyword">case</span> NUMBER:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s "</span>, yytext); <span class="comment">// 숫자는 바로바로 출력</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> OPERATOR:</span><br><span class="line"><span class="keyword">if</span>(operatStackTopIdx == <span class="number">-1</span>) &#123; <span class="comment">// 연산자는 스택이 비어있으면 넣고,</span></span><br><span class="line">operatorStack[++operatStackTopIdx] = yytext[<span class="number">0</span>];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// 스택이 비어있지 않으면 안에 있는것을 빼서 출력하고, 방금 받은 연산자는 새로 넣는다.</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c "</span>, operatorStack[operatStackTopIdx--]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> IDENTIFIER:</span><br><span class="line"><span class="comment">// printf("IDENTIFIER: %s, LENGTH:%d\n", yytext, yyleng);</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>: </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Error: %s not recognized\n"</span>, yytext);</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(operatStackTopIdx &gt; <span class="number">-1</span>) &#123; <span class="comment">// 스택이 비어있을 때 까지, 남은 연산자 출력</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c "</span>, operatorStack[operatStackTopIdx--]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>위의 파일을 <code>lex.l</code> 이라고 저장한 후에 다음과 같이 실행할 수 있다.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ flex hello.l <span class="comment"># lex를 이용해 .yy.c 파일 생성</span></span><br><span class="line">$ gcc lex.yy.c -ll <span class="comment"># gcc를 이용해 -ll 옵션을 주고 컴파일</span></span><br><span class="line">$ ./a.out <span class="comment"># 실행파일 실행</span></span><br><span class="line"><span class="comment"># 실행 파일의 내용은 in-fix인 1+2+3을 입력하면</span></span><br><span class="line"><span class="comment"># post-fix인 12+3+으로 변환해 준다.</span></span><br></pre></td></tr></table></figure></p><img src="/2018/04/22/flex/flex_command.png"><h2 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h2><p><strong>Lex</strong>, <strong>Flex</strong>에 대해서 알아보고 실제 <strong>Flex</strong>를 이용할 때 어떤 명령어를 사용해보고 정리해 보았다. 사실 <strong>Lexical Analyzer</strong>나 <strong>Parser</strong> 또는 <strong>Compiler</strong>를 직접 만들어서 내가 쓸 수 있을지는 모르겠지만, 정리해 둔다면 언젠가 후배가 물어본다거나 할 때 쓸 수 있지 않을까.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;개요&quot;&gt;&lt;a href=&quot;#개요&quot; class=&quot;headerlink&quot; title=&quot;개요&quot;&gt;&lt;/a&gt;개요&lt;/h2&gt;&lt;p&gt;학교 컴파일러 과제를 진행하다가 &lt;code&gt;Flex&lt;/code&gt;를 사용해 볼 기회가 있었다. 이론 수업을 듣다 보면 어느 정도
      
    
    </summary>
    
      <category term="tip" scheme="https://philographer.github.io/categories/tip/"/>
    
    
      <category term="tip" scheme="https://philographer.github.io/tags/tip/"/>
    
  </entry>
  
  <entry>
    <title>Team Mondrian 퇴사 후기</title>
    <link href="https://philographer.github.io/2018/03/18/retire-mondrian/"/>
    <id>https://philographer.github.io/2018/03/18/retire-mondrian/</id>
    <published>2018-03-18T05:00:35.000Z</published>
    <updated>2018-03-18T05:11:40.000Z</updated>
    
    <content type="html"><![CDATA[<img src="/2018/03/18/retire-mondrian/retire.jpg"><h2 id="개요"><a href="#개요" class="headerlink" title="개요"></a>개요</h2><p>드디어 미루고 미뤄왔던 후기 시리즈의 마지막인 <strong>근무했던 스타트업의 퇴사 후기</strong>를 적게 된다. 퇴사는 2월 20일부로 퇴사하였는데 학교에 다니고, 전시회 준비, 커뮤니티 활동을 하면서 적었던 후기에 밀려 밀려 마지막에 퇴사 후기를 적게 되었다.</p><hr><h2 id="팀-소개"><a href="#팀-소개" class="headerlink" title="팀 소개"></a>팀 소개</h2><p><a href="http://teammondrian.com/" rel="external nofollow noopener noreferrer" target="_blank">Team Mondrian</a>은 대한민국의 스타트업으로 <strong>도시 시각화, 헬스케어, 데이터 사이언스, 컨설팅, 중규모 SI</strong>를 하는 회사이다. 회사의 멤버는 유수 대학 석박사출신 엔지니어들로 이루어져 있다.</p><hr><h2 id="합류"><a href="#합류" class="headerlink" title="합류"></a>합류</h2><p>2015년도 즈음, 제대 후에 할 일이 없어 여러 가지 대학생 모임 활동에 전전하고 있었다. 그러던 중, 심심해서 페이스북을 보고 있었는데 집앞에 <a href="http://codeforincheon.org/" rel="external nofollow noopener noreferrer" target="_blank">Code For Incheon</a>이란 모임이 열리고 있었다. 마침 집도 코앞이기 때문에 잠깐 나갔는데 어찌어찌 정규 멤버로 합류하기도 하고, 운영자와 같이 모임의 Organizer를 하게 되었다.</p><p>여러 가지 <strong>도시문제 해결</strong>을 위한 프로젝트를 기획하기도 하고, 매주 자신이 준비한 자유주제로 발표를 하는 세션도 있었기 때문에 흥미롭게 진행하기도 했었다. 그러던 중 모임의 다른 Organizer가 간단한 외주 프로젝트를 진행하는 게 어떠냐는 제안을 시작으로 팀에 합류하게 되었다.</p><hr><h2 id="팀의-문화"><a href="#팀의-문화" class="headerlink" title="팀의 문화"></a>팀의 문화</h2><p><strong>완전 원격 근무</strong>를 지향하고 있는 팀이다. 해외에서는 <strong>Remote Work</strong>를 심심찮게 볼 수 있지만, 국내 문화에서는 아직 이르다는 평가로 도입이 늦춰지고 있는 문화이다.</p><p>팀에서는 <a href="https://slack.com/" rel="external nofollow noopener noreferrer" target="_blank">Slack</a>, <a href="https://github.com/" rel="external nofollow noopener noreferrer" target="_blank">GitHub</a>, <a href="https://www.google.com/drive/" rel="external nofollow noopener noreferrer" target="_blank">Google Drive</a>, <a href="https://hangouts.google.com/" rel="external nofollow noopener noreferrer" target="_blank">Google 행아웃</a> 등의 도구로 원격에서 소통하며 1주에 월, 수, 금요일 1시간 정도 정기회의 세션을 가지며 서로 협업한다.</p><p>처음에 근무를 시작했을 때 너무너무 멋지다는 생각이 들었다. 아직 정식 출퇴근은 해본 경험은 없지만 매일 출근 시간 넘치는 인파들 속에서 등교하기 힘들었던 경험을 하지 않게 되어서 행복했다.</p><hr><h2 id="원경-근무의-장점"><a href="#원경-근무의-장점" class="headerlink" title="원경 근무의 장점"></a>원경 근무의 장점</h2><p><strong>완전 원격 근무</strong>의 장점은 오전, 오후, 야간에 진행해야 할 일들을 편히 할 수 있어서 매우 만족도가 높았다. 예를 들어 점심에 환전 등의 업무로 <strong>은행</strong>에 가야 할 때, 직장인들이 많은 점심시간을 피해서 아침 일찍 가거나 <strong>병원 예약</strong>을 내가 원하는 시간에 할 수 있어서 매우 편했다.</p><p>가장 좋은 점은 바로 내 <strong>생산성</strong>을 높일 수 있어서 좋았다. 원격근무를 한참 할 때는 내가 가장 코딩하기 좋아하는 시간인 <strong>이른 아침</strong>에 가장 좋고 많은 코드를 적어낼 수 있었으며 일하기 싫은 밥 먹고 난 이후 <strong>점심</strong>에는 1~2시간씩 낮잠을 잘 수 있었다. 그리고 다시 생산성이 매우 높아진 상태로 업무에 돌입할 수 있으며 점심에 까먹은 1~2시간은 조용한 <strong>12시 이후</strong>에 다시 보충했다. 그리고 저녁 시간은 야근 없이 친구들이나 여자친구, 가족들과 시간을 보낼 수 있었다. 물론 일이 많았을 때도 저녁 시간에 놀 수 있었지만 12시 이후에 다시 컴퓨터에 앉아서 새벽 늦게까지 야근하는 불상사가 일어지기도 했다.</p><hr><h2 id="원격-근무의-단점"><a href="#원격-근무의-단점" class="headerlink" title="원격 근무의 단점"></a>원격 근무의 단점</h2><p>원격 근무의 장점은 <strong>출근을 하지 않는다</strong>이지만, 최대의 단점은 <strong>퇴근도 하지 않는다.</strong>이다. 한참 일이 바쁠 때면 <strong>침대에서 일어나 출근인 상태로, 침대에 누우면서 퇴근을 한 달 정도 반복했던 적도 있었다.</strong></p><p>또 다른 단점은 초창기 팀원들의 <strong>커뮤니케이션</strong>이 쉽지 않았다. “슬랙, 행아웃, 스크린 히어로, 팀뷰어” 등 협업을 위한 툴들이 많이 생겼지만, 화상채팅만 가지고 회의에서 상대방의 <strong>진짜 의미</strong>나 <strong>제스처</strong> <strong>분위기</strong> 를 보기 어렵기 때문에 <strong>아이디어 회의</strong>나 팀의 방향과 문화를 정하는 <strong>중대한 사항</strong>을 논할때는 원격 협업 툴이 큰 도움이 되지 않았다.</p><p>마지막 단점은 <strong>자기관리</strong>였다. 출근과 퇴근 시간이 정해져 있지 않으므로 일과 삶이 구분되지 않은 <strong>워커 홀릭</strong>으로 지내거나 일을 하지 않아도 월급을 받는 <strong>월급 도둑</strong>이거나 삶이 둘 중에 하나로 변질되기 쉽다. 이런 두 가지 타입 사이에서 줄타기하듯 위태위태 중간을 유지하는 것이 어려웠다.</p><hr><h2 id="Lessons-learned"><a href="#Lessons-learned" class="headerlink" title="Lessons learned"></a>Lessons learned</h2><ul><li><strong>자기관리</strong><br>처음에는 전력투구하여서 <strong>워커 홀릭</strong>으로 몇달간 지냈다. 그렇게 지내다 보니 건강도 악화하며 체력도 약해지고 눈도 아프더니 몇 주간 쉬니 <strong>월급 도둑</strong>이 되어있었다. 원격근무 초기에는 이런 두 가지 타입을 몇 번씩 반복하니 나름의 노하우를 습득하였다.</li></ul><p>아주 간단한 방법인데 바로 <strong>계획을 세우고 지킨다</strong>는 것이다. 아침에는 8시 고정된 시간에 운동하고, 점심엔 주기적으로 3~5시에 낮잠을 자고 5시에는 일어나자마자 업무를 저녁 먹기 전까지 진행하며 자기 전 1시간은 업무 마무리로 쓴다 같은 계획이었다.</p><p>상당히 단순한 타임테이블 이지만, 세상에서 가장 지키기 어려운게 <strong>Todo-list</strong>가 아니라 <strong>Time-table</strong>이었다. 이를 고수하는데 큰 노력이 들었다.</p><p>그리고 자기 자신에게 투자하는 <strong>개발 장비</strong>, <strong>온라인 강의</strong> 등에는 아끼지 않고 돈을 쏟아부었다. (그래서 지금은 집에 아이맥 5k로 글을 쓰고 있다 ㅋㅋ)</p><p>마지막으로 건강관리인데, 건강이 악화되고 회복하는 과정을 여러번 거치다 보니 내 몸에 대해서 알게 되었다. 어느 정도가 한계치이고 어느 정도에 쉬어줘야 하는지 알았기 때문에 생산성을 어느 타이밍에 어떤 목적으로 늘릴 수 있는지 터득하게 되었다.</p><ul><li><strong>자율 출근 &amp; 미팅</strong><br>스타트업에서 가장 어려운 건 바로 회의였다. 현재 회사가 정확히 어느 길로 가는지 모르는 중에 회의한다는 것은 매우 어려웠다. 회사가 작기 때문에 나 같은 인턴이라도 개인의 의사결정이 회사의 방향에 매우 큰 영향을 미칠 수 있으므로 신중에 신중히 처리해야 했다.</li></ul><p>그런데 이런 상황에서의 <strong>원격 회의</strong>는 독이다. 따라서 결국에는 자율적으로 <strong>오피스에 일주일에 몇 번씩 출근</strong>하는 문화가 만들어지게 되었다.</p><ul><li><strong>사수에게서 배우는 키워드 &amp; 아키텍쳐 &amp; 코드 스트럭쳐</strong><br><strong>회사는 학교가 아니다.</strong> 초창기에는 과다한 의욕으로 사수에게 이것저것을 캐묻고는 했었는데 개인의 호기심을 채우면서 회사에 생산성에는 악영향을 끼친다는 것을 깨달았다. 따라서 그 후로부터는 사수에게 효과적으로 질문하는 방법을 알게 되었다.</li></ul><p>뿐만 아니라 사수에게서 문제점의 키워드를 알아내고 <strong>스스로 공부하는 습관</strong>을 들였다. 사수는 사수이지 선생님이 아니기 때문에 적당한 키워드를 알아낸다면 스스로 공부하고 블로그에 글을 쓰던, 개인 메모장에 적던, 필기하던, 코드를 짜던 하는 방법으로 자가학습하는 방법을 깨달았다.</p><p>마지막으로는 <strong>팀원들의 코드와 주석을 보고 배우는 습관</strong>을 기르게 되었다. 주석이 없는 코드더라도 자세히, 몇 번씩 들여다보면 이 사람이 무슨 생각으로 코드를 적었는지 알 수 있었기 때문에 신기하고 재미있었다.</p><ul><li><strong>스타트업의 문화 &amp; 비전 &amp; 인사이트</strong><br>사실 이 팀에 들어오기까지 스타트업에 대해서는 문외한이었다. 하지만 본인이 스타트업 판 한 가운데가 있으므로 관심을 가지지 않으려야 안 가질 수가 없었다. 아무것도 모른 채로 들어왔을 때 스타트업은 매우 멋져 보이고 유망해 보였지만, 내가 경험했던 세계는 약육강식의 세계가 따로 없을 정도로 힘들고 척박한 곳이었다. </li></ul><p>물론 우리 회사의 배경이나 문화는 좋았지만 스타트업 커뮤니티에 참여하면서 느끼고 배웠던 점은 스타트업의 오너를 하는 것은 참으로 어렵고 험난한 길이라는 것을 느꼈다.</p><p>스타트업의 <strong>완전 원격 근무</strong>,  <strong>뛰어난 멤버들의 비전과 인사이트</strong>를 사회 초년생이 배워가기에는 스타트업 근무 경험이 더할 나위 없이 좋았다.</p><hr><h2 id="퇴사-이유"><a href="#퇴사-이유" class="headerlink" title="퇴사 이유"></a>퇴사 이유</h2><p><strong>짧게 말하면 학업 &amp; 학점. 길게 말하면 취업준비</strong> 로 말할 수 있을 것 같다. 1년 휴학 기간은 공부와 일을 동시에 하는 데 문제가 크게 없었다. 하지만 학교에 다니던 중 파트타임 인턴으로 일을 하다 보니 <strong>학점</strong>이 크게 좋지 못했다. 따라서 졸업하기 전에 원하는 학점으로 졸업하기 위해서는 학교에 매진해야 했다.</p><p>그리고 스타트업에서 일해봤으니, 이제는 더욱 <strong>큰 기업에서 일을 해보고 싶은 개인적인 욕구</strong>가 생겼다. 아무래도 이리저리 떠돌면서 내가 원하는 게 뭔지 찾아가려는 내 특성 때문이 아닐까. 큰 곳에서 일해보면 그 다음에는 중견기업인가…!</p><hr><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h2><p>가장 마지막에 쓰는 후기 시리즈이기도 하고, 미뤄왔던 글을 써 내려가니 홀가분하기도 하다. 지금은 학교에 다니면서 시간도 나서 이런 글을 쓰고는 하는데, 직접 일을 해보니 이런 글 쓸 시간을 내는 것 조차 쉽지 않겠다는 생각이 든다. 앞으로는 더욱더 자기관리, 경력관리에 매진해서 좋은 기업에 취직을 목표로 취준생 생활을 보내야겠다는 마음가짐으로 글을 마친다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/2018/03/18/retire-mondrian/retire.jpg&quot;&gt;
&lt;h2 id=&quot;개요&quot;&gt;&lt;a href=&quot;#개요&quot; class=&quot;headerlink&quot; title=&quot;개요&quot;&gt;&lt;/a&gt;개요&lt;/h2&gt;&lt;p&gt;드디어 미루고 미뤄왔던 후기 시리즈
      
    
    </summary>
    
      <category term="Retrospect" scheme="https://philographer.github.io/categories/retrospect/"/>
    
      <category term="Personal" scheme="https://philographer.github.io/categories/retrospect/personal/"/>
    
    
  </entry>
  
  <entry>
    <title>Can You Feel My Heartbeat? 프로젝트 후기</title>
    <link href="https://philographer.github.io/2018/03/12/mdtconv2/"/>
    <id>https://philographer.github.io/2018/03/12/mdtconv2/</id>
    <published>2018-03-12T03:09:48.000Z</published>
    <updated>2018-03-12T09:51:08.490Z</updated>
    
    <content type="html"><![CDATA[<img src="/2018/03/12/mdtconv2/poster.jpg" title="전시회 포스터"><h2 id="개요"><a href="#개요" class="headerlink" title="개요"></a>개요</h2><p>요즘 활동이나 프로젝트 후기를 쓰면서 프로젝트 포트폴리오를 정리하고 있다. 따라서 이번 <a href="https://www.facebook.com/mdtconv/?ref=br_rs" rel="external nofollow noopener noreferrer" target="_blank">경디공</a> 활동에서 진행했고, 신도림역에서 전시했던 작품에 대해서도 역시 후기를 써보려고 한다.</p><h2 id="What-To-Make"><a href="#What-To-Make" class="headerlink" title="What To Make"></a>What To Make</h2><p>팀원은 재료공학과 팀원 1명, 디자인학부 1명, 컴퓨터공학과 1명으로 팀이 꾸려졌다. 전시회의 주제는 <code>감성 &amp; 빛</code>으로 잡혔기 때문에 범위 안에서 우리 팀의 주제를 선정해야 했다. 열띤 토론 끝에 심장박동을 가지고 게임이든 뭔가를 해보자는 쪽으로 결론이 잡혔다.</p><p>처음에는 심장박동을 가지고 <a href="http://www.itfind.or.kr/WZIN/jugidong/1251/125103.htm" rel="external nofollow noopener noreferrer" target="_blank">바이오피드백 게임</a> 을 만드는 건 어떨까 생각했었다. 그런데 우리가 사용 가능한 예산 내에서는 <code>라즈베리 파이, 아두이노</code> 등의 저가형 보드가 전부이며 <code>왜 게임을 만들어야 하는가?</code> 에 대한 해답을 우리 팀 내부에서도 찾지 못했다.</p><p>그러던중, 생각난 것이 <code>심장박동</code> 이었다. 심장박동은 알게 모르게 우리의 <code>감성, 감정</code>을 대변하는 도구이며 심장박동 센서를 통하여 수치화 및 분석을 할 수 있다. 따라서 우리는 심장박동을 가지고 무언가 한다면 재미있겠다는 생각이 들었다.</p><p>심장박동이란 내가 주체로 나오는 데이터이기도 하지만, 이것을 자신이 고스란히 보기는 어렵다. 따라서 우리는 이런 감성을 대변하는 <code>심장박동</code> 을 제 3자의 입장에서 표현하여 다시 본인에게 보여준다는 것을 가닥으로 프로젝트 주제를 잡았다.</p><h2 id="How-To-Make"><a href="#How-To-Make" class="headerlink" title="How To Make"></a>How To Make</h2><p>우선 팀원 당 할당된 예산이 많지 않았다. 약 15만 원 정도로 아래의 3가지 모듈들을 모두 대여하거나 구매해야 했다.</p><ul><li>높은 밝기를 영사할 수 있는 프로젝터 3개</li><li>프로그래밍 가능한 보드 &amp; 심장박동 센서 &amp; LED &amp; 각종 모터, 센서들</li><li>심장박동 센서 및 보드의 거치가 가능한 아크릴 재료비 및 재단 비</li></ul><p>“프로젝터”와 “아크릴”은 고정비용으로 나갈 수 있으니 재료비를 최대한 아끼려면 “프로그래밍 가능한 보드 &amp; 센서”에서 최대한 비용을 아껴야 했으므로 저가형 보드인 <code>Arduino</code>와 <code>Rasberry Pi3</code> 에 대하여 주로 알아보았다.</p><p>처음 라즈베리 파이 보드와 심장박동 센서를 구매해서 사용해보니 생각보다 정확도가 높지 않았다. 내가 너무 저가형 센서에 많은 것을 기대했던 것인가 걱정도 들었다. <a href="pulsesensor.com">pulsesensor.com</a> 에서 판매하는 정품 센서는 2만 원 중반대의 가격이었지만 내가 구매한 것은 4-5천 원 정도의 심장박동 센서 였다. </p><h2 id="SW-HW-Architecture"><a href="#SW-HW-Architecture" class="headerlink" title="SW/HW Architecture"></a>SW/HW Architecture</h2><img src="/2018/03/12/mdtconv2/archi1.png"><img src="/2018/03/12/mdtconv2/archi2.png"><hr><img src="/2018/03/12/mdtconv2/archi3.png"><ol><li><code>라즈베리파이</code> 를 이용한 센서 값 수집부</li><li><code>AWS EC2</code> 환경에서 <code>Node.js</code>와 <code>Socket.io</code>를 이용한 data proxy server</li><li><code>Chrome</code> 브라우져의 <code>Syphoner</code>을 이용한 동영상 스트리밍 및 <code>Madmapper</code> (Projection Tool)</li><li>3대의 <code>Projector</code> 와 1대의 <code>Bluetooth Speaker</code> 를 이용한 Output</li></ol><h2 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h2><img src="/2018/03/12/mdtconv2/collage.png"><div class="video-container"><iframe src="//www.youtube.com/embed/-fUFdbOrhjk" frameborder="0" allowfullscreen></iframe></div><h2 id="Postmortem"><a href="#Postmortem" class="headerlink" title="Postmortem"></a>Postmortem</h2><p>포스트모템은 영어로 “사후 시행하는 검시” 이며 프로젝트에서는 끝난 일에 대한 분석과 재검토를 말한다.</p><p>소프트웨어를 총괄적으로 한 세트를 구성해서 프로젝트를 진행해본 경험은 몇 번 있었지만, 하드웨어까지 합쳐서 구성해본 경험은 처음이었다. 처음에는 라즈베리 파이의 구조와 동작 원리, 전압 전류 저항 등을 이해하느라 어려웠지만, 인터넷에 있는 cheatsheet 같은 것들을 보고 youtube에서 튜토리얼을 보면서 연결하는 방법을 익혔다.</p><p>전시중 하드웨어 부분에서 <code>심박센서 -&gt; 진동</code>의 피드백이 역으로 <code>진동 -&gt; 심박센서</code> 의 센서값으로 인식되어 어려움이 있었다. 전시 후반부에서는 진동모터를 제거하고 전시를 진행하였다.</p><p>사실 소프트웨어, 하드웨어는 내가 전담해서 만들었지만 보이는 부분이 컸던 <code>Projection</code>과 아크릴로 손수 제작했던 <code>case</code> 의 부분이 생각보다 퀄리티 있어서 완성도가 높았던 프로젝트로 기억할 수 있을 것 같다.</p><p>단순히 재미로 시작했던 프로젝트였는데 전시를 진행하면서 이 전시물을 왜 만들었고, 사람들이 직접 체험하면서 재미있어하는 모습을 보면서 나도 흥미를 많이 느끼고 배웠던 프로젝트였다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/2018/03/12/mdtconv2/poster.jpg&quot; title=&quot;전시회 포스터&quot;&gt;
&lt;h2 id=&quot;개요&quot;&gt;&lt;a href=&quot;#개요&quot; class=&quot;headerlink&quot; title=&quot;개요&quot;&gt;&lt;/a&gt;개요&lt;/h2&gt;&lt;p&gt;요즘 활동이나 프로
      
    
    </summary>
    
      <category term="Retrospect" scheme="https://philographer.github.io/categories/retrospect/"/>
    
      <category term="Project" scheme="https://philographer.github.io/categories/retrospect/project/"/>
    
    
      <category term="경디공" scheme="https://philographer.github.io/tags/%EA%B2%BD%EB%94%94%EA%B3%B5/"/>
    
  </entry>
  
  <entry>
    <title>경디공 3기 활동 마무리 후기</title>
    <link href="https://philographer.github.io/2018/03/08/mdtconv/"/>
    <id>https://philographer.github.io/2018/03/08/mdtconv/</id>
    <published>2018-03-08T05:01:15.000Z</published>
    <updated>2018-03-08T14:15:20.000Z</updated>
    
    <content type="html"><![CDATA[<img src="/2018/03/08/mdtconv/mdtconv-logo.jpg" title="전공융합 동아리 “경디공”"><h2 id="개요"><a href="#개요" class="headerlink" title="개요"></a>개요</h2><p>2017년 3월 휴학하고 SW Maestro활동과 스타트업 프로젝트 마무리를 진행하면서 점점 가용 시간이 늘어났다. 그래서 남는 내 에너지를 어디에 쏟을 수 있을까 고민하던 찰나 학교 커뮤니티인 인하광장에서 <a href="https://www.facebook.com/mdtconv/" rel="external nofollow noopener noreferrer" target="_blank">경디공</a> 이라는 <strong>대학생 연합 동아리</strong>를 발견했다. 조금 재미있는 점은 원래 연합동아리의 경우 <strong>같은 전공</strong>이나 <strong>공학+디자인</strong>의 조합으로 좀 더 자신의 전공에 심화한 활동들을 하는 게 대부분인데 이 동아리는 <strong>전공 융합</strong> 이라는 키워드를 필두로 활동을 진행한다는 게 독특했다. 나도 기술을 어차피 회사 일을 하거나 다른 커뮤니티, 그도 아니라면 개인적으로 독학할 수 있으니 시야를 넓히고자 이 동아리에 지원하게 되었다.</p><hr><h2 id="서류-평가"><a href="#서류-평가" class="headerlink" title="서류 평가"></a>서류 평가</h2><p>여느 동아리 활동들처럼 두 가지를 통과하면 활동을 할 수 있게 된다. 지원자가 채워야 할 항목은 다음과 같았다.</p><ul><li><strong>질문1: 자신을 3가지 단어로 표현한다면? (Ex, 여신, 주당, 4차원 + 간단한 설명도 함께 작성해주세요)</strong><br>답변: Geek: Geek이란 무언가에 빠져있는 엉뚱한 괴짜라는 뜻입니다. 무언가에 골똘히 빠져있는 것을 좋아합니다. 주로 대상은 컴퓨터지만, 다른 것에도 관심이 많습니다.<br>즉흥: 즉흥적으로 무언가를 하거나 먹는 것을 좋아합니다.<br>Choicer: 잘 찍고 고르는데 일가견이 있습니다. 메뉴 선정 등등.</li></ul><blockquote><p>위의 답변은 <a href="http://jasoseol.com/" rel="external nofollow noopener noreferrer" target="_blank">자소설닷컴</a> 에 기록이 남아있는 것을 그대로 가져왔다. 1년이 지난 다음 봐도 나를 잘 설명한 글 같다. 하지만 바뀐 예명 Philographer에 대한 설명이 없는 게 아쉽다. 다음에 지원할 땐 조금 바뀐 단어들이 들어갈 듯 (ex. 철학)</p></blockquote><ul><li><strong>질문2: 본인이 이것만은 자신있다! 또는 이런 프로그램도 다룰 줄 안다! 하는 장점이 있다면 무엇인가요? (Ex, 발표를 잘한다, ppt를 잘 만든다, 포토샵 및 3d 프로그램 사용가능하다 등)</strong><br>답변: 홈페이지 만들기, 어플리케이션 제작, 서버 프로그래밍이 가능하다!<br>(단, 디자이너가 디자인을 만들어 주는대로만 가능… 개인의 예술 감각은 전무합니다 ^~^)</li></ul><blockquote><p>짧게 적어서 제출했다. 한창 <a href="http://www.swmaestro.kr/" rel="external nofollow noopener noreferrer" target="_blank">SW Maestro 과정</a>을 마무리해서 그런지 대충 적은 감이 없지 않다.</p></blockquote><ul><li><strong>질문3: 본인 전공 외 관심 있는 분야는 무엇인가요?</strong><br>답변: 주로 웹이나, 어플리케이션을 만들다 보니 디자인 분야에 관심이 많습니다.(UI, UX)<br>컴퓨터 앞에만 앉아있다 보니 운동량 부족에 시달립니다. 살기위해 운동에도 관심이 많습니다.</li></ul><blockquote><p>이 항목은 저 당시에는 프론트엔드를 한창 열심히 하고 있었기 때문에 저렇게 적었나 보다. 지금은 인프라&amp;백엔드&amp;DevOps 쪽에 더 많은 관심이 있다.</p></blockquote><ul><li><strong>질문4: 경디공을 통해 이루고 싶은 것 또는 기대하는 것은 무엇인가요?</strong><br>답변: 첫 번째로, 대학생 신분일 때 ‘대학생만’할 수 있는 활동에 관심이 많습니다. 경디공의 활동을 전부 찾아보지는 못했지만, 블로그, 페이스북을 봤을 때 개인의 취미를 나누거나 축제에 참여하는 모습을 보았습니다. 돈이 되지 않지만 재미있어 보이는 일을 단순히 재미로 시작하는 일들은 오로지 대학생 때만 할 수 있다고 생각합니다. 이런 재미있는 활동들을 하고싶습니다.</li></ul><p>두 번째로, 커뮤니케이션 능력을 기르는데 힘쓰는 편입니다. 개인의 전공 능력도 중요하지만, 그만큼 의사소통 능력을 늘리고 협업하는 것도 중요하다고 생각합니다. 이러한 협업은 같은 전공을 가진 사람들끼리만 하는 것이 아니라, 다분야의 사람들과 직접 부딪히며 늘려야 한다고 생각합니다. 경디공 사람들과 함께 공모전에 참가하거나, 내부 활동들을 하면서 커뮤니케이션 능력을 기르고 싶습니다.</p><p>세 번째로, 인천에서 네트워크를 많이 꾸려가고 싶습니다. 인천에서 대학교에 다니고 있지만, 개인적으로 학교에 집중하기보다는 주로 외부 활동을 하고 있습니다. 그러다 보니, 인천지역의 친구도 많이 없고, 공대생의 특성상 친구들은 거의 공돌이뿐입니다. 다양한 분야의 멋진 재능을 가진 친구들을 경디공에서 만나고 싶습니다.</p><blockquote><p>지금에서야 말할 수 있지만 세 번째 항목이 가장 큰 이유였다. 스타트업 활동과 소프트웨어 마에스트로 활동이 서울에서 이루어지고 있었으므로 왕복 2~3시간이 매일같이 사라지고 있었다. 따라서 이동시간을 최소한 줄이고 알찬 대학생 활동을 하고 싶기 때문에 지원했었다.</p></blockquote><ul><li><strong>질문5: 무엇보다 협업과 적극적인 참여가 중요한 곳입니다. 협업할 때 있었던 트러블과 그것을 극복한 에피소드가 있다면? (Ex, 수업, 아르바이트 등) 없었다면 팀 내에 무임승차하는 인원이 있다면 어떻게 행동하시겠습니까?</strong><br>답변: 프리라이더가 팀원 중 있을 때, 크게 두 가지 경우가 있습니다.<br>1.본인이 팀장으로 있을 경우, 2. 본인이 팀원으로 있을 경우.<br>팀장으로 있는 경우라면, 팀원에게 역할을 정확히 할당합니다. 프리라이더가 프리라이딩을 할 수 있는 이유 중 하나는, 자신이 프리라이딩을 해도 팀에서 티가 나지 않기 때문입니다. 이를 방지하기 위해 팀원에게 프로젝트의 중요한 역할을 할당하고 이를 지속해서 관리하며 책임감을 느끼도록 유도합니다.</li></ul><p>팀원으로 있는 경우라면, 우선 팀장에게 말합니다. 그렇게 해서 팀장이 팀원과 조율을 하게 되는데 만약 잘 안 된다면 팀원과 개인적으로 이야기해서 어떻게든 설득하는 편입니다. 현재 팀의 상황, 계속되는 팀원의 무임승차로 현재 팀에게 나타나고 있는 문제점, 이로 인한 프로젝트의 결과 등을 말해가며 설득합니다.</p><p>개인적인 경험으로, 정확한 역할 할당과 설득에도 불구하고 끝까지 프리라이딩을 하는 팀원이 있었는데 아주 곤혹스러웠습니다. 프리라이더를 태우고서라도 프로젝트는 성공적으로 완성되어야 합니다. 최악의 경우에는, 프리라이더를 제외하고 나머지 팀원들의 결속과 책임감을 유도하여 프로젝트를 완성하려고 노력하는 편입니다.</p><blockquote><p>프리라이더에 대한 해결책 질문은 다른 기업 자소서나 동아리 자소서에서도 많이 적어봤고, 실제로도 겪어봤던 항목이었다. 따라서 솔직한 내 생각과 팀장으로서의 나의 경험을 풀어내었다.</p></blockquote><h2 id="면접-평가"><a href="#면접-평가" class="headerlink" title="면접 평가"></a>면접 평가</h2><p>면접은 경인 지역 대학생 활동답게 인천대에서 이루어졌다. 집에서 인천대까지는 약 40분 정도 소요되었기 때문에 미리 집에서 출발하여 지각하지 않고 도착하였다. 면접평가는 크게 두 단계로 진행되었다. 하나는 나와 같은 면접자 1명이 팀원으로, 랜덤주제가 적힌 종이쪽지를 2개 뽑는다. 그리고 팀원과 상의하여 그 2가지 주제를 합친 아이템에 대하여 5분간 피칭하는 방식이다. 이전에는 경험해 보지 못한 새로운 방식이었다. 내 경우에는 <strong>환경 + 유아</strong>의 주제를 골랐다. 아이디어에 대하여 논의할 제한된 시간이 10분~15분밖에 되지 않아서 빠르게 가닥을 잡고 나갔다. 아이들의 옷은 아이가 금방 자라서 금방 쓸모없어지는 경우가 많다. 따라서 아이들 옷을 서로 포인트를 가지고 서로 물물교환을 하는 앱을 빠르게 기획하여 피칭하였다.</p><hr><h2 id="활동"><a href="#활동" class="headerlink" title="활동"></a>활동</h2><p>첫 활동은 자신의 학과에서 어떤 것을 배우는지 소개하는 시간이었다. 내 경우는 “컴퓨터공학” 이란 학과에서 처음에는 “컴퓨터 공학 입문” 과목부터 시작해 구조, 알고리즘, 프로그래밍 등 여러 가지를 배우며 진로로는 어느 방면이 있다 정도로 소개했었다.</p><p>처음에는 사실 3기밖에 안 된 활동이라 탄탄한 커리큘럼이나 여러 가지 시스템을 기대하지는 않았지만, 동아리가 매우 난해하였다…. 왜냐하면, 한가지 전공도 아니고 경상, 디자인, 공학이 서로 섞여 있을 뿐만 아니라 경상 쪽은 경영, 경제, 무역학부의 학생이 있었고 디자인도 영상 디자인, 도시 디자인, 제품 디자인의 분야가 있고 공학도 전기, 전자, 컴퓨터, 인프라, 재료, 화학, 보안, 컴퓨터 등 매우 다양한 전공의 학생들이 모여있었기 때문에 프로젝트를 하더라도 서로 무엇을 해야 하는지 모르는 경우가 다반사였다.</p><p>하지만 점차 매주 진행하는 전공&amp;취미 스터디를 진행하면서 서로에 대해서 적응하기 시작했다. 커뮤니케이션이 부족한 공대 친구들은 PPT와 팀플레이 지식이 많은 경상 친구들에게 대화하는 방법을 습득했고, 경상 친구들은 기술에 관해서 관심을 가지기 시작했다. 디자인 친구들은 자신들이 상상하던 디자인이 기술적으로는 어떤 문제점이나 실제로 제품으로 판매했을 때는 어떤 이득과 손해가 있을지를 서로가 서로에게 배워나가는 장이 되었다.</p><p>지금 다시 후기를 적다 보니 조금 부끄러운 순간도 있었다. 동아리 시작 초기에 갈피를 못 잡아갈 때쯤 많은 인원이 동아리를 나갔다. 아무래도 갈피를 못 잡고 있는 이 동아리를 계속 해야 하는지 이유를 알지 못하는 학생들이 많이 나갔던 것 같다. 나 역시도 나갈지 말지 고민을 하던 그 학생들 중 하나였다. 내가 나가지 않았던 건, 그냥 중간에 포기하고 소위 말하는 “탈주”를 하기 싫었다. 그래서 이 동아리에 <strong>의미 부여</strong>를 하기 시작했다. 왜 내가 지원했고, 뭘 내가 이 동아리에서 얻어갈 수 있는지를 다시 돌이켜 보니 중간에 그만두기보다는 끝까지 해내야겠다는 생각이 들었다. 그리고 팀의 프로젝트에서 <strong>팀장</strong>의역할 맡았다. 내가 스스로 도망가지 못하도록 묶어놓는 역할이 되었으므로 책임감과 참여도를 올릴 수 있었다. </p><hr><h2 id="전시"><a href="#전시" class="headerlink" title="전시"></a>전시</h2><img src="/2018/03/08/mdtconv/mdtconv-poster.jpg" title="전시 포스터"><p>전공융합 동아리에서는 마지막 끝나기 전 최종 활동으로 <strong>전시</strong> 프로젝트를 준비한다. 회비나 지원금을 모아서 전시장소를 대관, 컨셉이나 주제를 잡고 자기들이 원하는 프로젝트로 일반인들에게 오픈되는 전시를 진행한다. 이번 프로젝트의 전시 주제는 <strong>우리를 빛나게 하는 것들</strong> 이었다.</p><p>우리 팀에는 운영진이 각 전공이 잘 섞이도록 팀이 짜여있게 되었다. 경영학과 학생, 디자인학부 학생, 컴퓨터공학 학생 2명, 재료공학과 학생 1명으로 팀이 구성되었다. 그중에서 컴퓨터 하는 친구와 경영을 공부하는 친구는 게임을 만들고 싶다고 해서 팀을 작게 “바이오 피드백 게임”으로 분할했다. 그리고 남은 디자인, 컴퓨터(me), 재료공학 학생은 “심박 시각화” 프로젝트를 시작하기로 했다.</p><p>우리가 정한 시놉시스는 다음과 같다.</p><blockquote><p>인간의 감정이란 눈으로 보이지 않는다. 그 때문에 사람들은 서로의 감정을 몸짓, 행동, 말 등으로 표현하며 이해하려고 한다.우리는 이런 감정의 스스로 표현의 매체가 시각적으로 눈으로 표현되면 좋겠다는 생각을 했다. 인간의 감정은 심박 수를 통하여 드러난다. 화나거나 흥분할 땐 빨라지고, 차분한 상태에서는 정적인 심박 수를 유지한다. 우리는 감정을 심장박동과 같이 여기고 시각, 청각, 촉각적으로 느낄 수 있도록 작품을 구상하였다.</p></blockquote><p>이렇게 탄생한 작품은 다음과 같다. 보다 더 기술적인 내용은 추후 블로그 글로 설명할 것이다.</p><ul><li><p>심박 시각화</p><div class="video-container"><iframe src="//www.youtube.com/embed/-fUFdbOrhjk" frameborder="0" allowfullscreen></iframe></div></li><li><p>전시회 walk-through</p><div class="video-container"><iframe src="//www.youtube.com/embed/cmyVH8Nu6Lw" frameborder="0" allowfullscreen></iframe></div> </li></ul><hr><h2 id="후기"><a href="#후기" class="headerlink" title="후기"></a>후기</h2><p>심심함에서 시작했으나 끝날 때는 많은 것을 느꼈다.  <strong>SW Maestro</strong> 과정처럼 엄격한 심사기준에 맞춰서 들어오는 활동이 아니기도 하거니와 한가지(컴퓨터) 전공을 가진 친구를 만나는 게 아니라 정말 다양한 전공의 친구들을 만날 수 있다는 게 가장 큰 장점이었다. 처음 활동을 시작할 때는 이렇게 많은 전공의 학생들을 모아두니 어디에 쓰려나…. 걱정이 많았다. 아직 학생이기 때문에 각 분야에 전문성을 출중하게 가지고 있는 것도 아니기 때문에 정체성이 모호했다. 하지만 점차 활동을 진행함에 따라서 여러 가지 크고 작은 프로젝트와 스터디를 진행하니 컴퓨터 공부만 했을 때보다 넓은 시야가 보이게 되었다. 경상 입장에서는, 디자인 입장에서는, 그리고 또 다른 공학 입장에서는 이라는 서로 다른 피드백들을 주고받으니 더욱 아이디어가 creative 해지는 것을 많이 느꼈다. </p><p>이 활동이 끝났을 때 다시 나에게 한번 물어봤다. 1년 전 이 활동을 하기 전보다 나는 성장했을까?<br><strong>물론이다.</strong> 라고 대답할 수 있을 것 같다. 내가 보지 못했던 새로운 시야를 열어준 <strong>경디공</strong>을 후배들에게도 추천해주고 싶다라는 이야기로 글을 마친다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/2018/03/08/mdtconv/mdtconv-logo.jpg&quot; title=&quot;전공융합 동아리 “경디공”&quot;&gt;
&lt;h2 id=&quot;개요&quot;&gt;&lt;a href=&quot;#개요&quot; class=&quot;headerlink&quot; title=&quot;개요&quot;&gt;&lt;/a&gt;개요&lt;/h2&gt;&lt;
      
    
    </summary>
    
      <category term="Retrospect" scheme="https://philographer.github.io/categories/retrospect/"/>
    
      <category term="Personal" scheme="https://philographer.github.io/categories/retrospect/personal/"/>
    
    
      <category term="경디공" scheme="https://philographer.github.io/tags/%EA%B2%BD%EB%94%94%EA%B3%B5/"/>
    
  </entry>
  
  <entry>
    <title>Talent X 1기 합격 후기</title>
    <link href="https://philographer.github.io/2018/03/06/talentx/"/>
    <id>https://philographer.github.io/2018/03/06/talentx/</id>
    <published>2018-03-06T01:32:22.000Z</published>
    <updated>2018-03-08T05:00:57.712Z</updated>
    
    <content type="html"><![CDATA[<img src="/2018/03/06/talentx/talentx-logo.png" title="Talent"><h2 id="개요"><a href="#개요" class="headerlink" title="개요"></a>개요</h2><p>어느덧 이런저런 활동과 학생 생활을 지나 보내니 <strong>4학년</strong>이 되었다. 어느새 주변 사람들은 나에게 <strong>“취준생”</strong>이란 타이틀을 부여하기 시작했다. 듣다 보니 나도 “아…. 이제 슬슬 취업준비 해야지”라는 생각도 들었다.</p><hr><h2 id="서류평가"><a href="#서류평가" class="headerlink" title="서류평가"></a>서류평가</h2><p>사실 대학교 생활을 하면서 무언가…. 고통스럽게 감내하기보다는 내가 하고 싶었던 활동들을 찾아 나섰다. 그래서 더욱 <strong>돈이 되지 않고, 대학생들만 할 수 있는 활동들에 치중</strong>해서 활동했던 것 같다. 물론 재미도 좋지만 스스로 생각하기에도 이번 년 가장 중요한 목표는 <strong>취업</strong>이라고 결론을 내렸다.</p><p>이러던 와중에 <code>Facebook</code>에서 <a href="https://www.facebook.com/talentxmanagement" rel="external nofollow noopener noreferrer" target="_blank">Talent X </a> 의 1기를 모집한다는 소식을 보게 되었다. Logo를 보다 보니 무척 어디선가 본듯한 느낌이 들었다. 바로 <a href="http://teammondrian.com/" rel="external nofollow noopener noreferrer" target="_blank">Team Mondrian</a>에 재직했을 때 스타트업 <strong>다국적 조직역량 강화 프로그램</strong>에 선정되어서 <a href="https://talentx.traitify.com" rel="external nofollow noopener noreferrer" target="_blank">TalentX. Traitify</a> 라는 프로그램의 주관으로 보였다.</p><p><a href="https://talentx.traitify.com/" rel="external nofollow noopener noreferrer" target="_blank">Traitify</a>는 자신이 선호하는 그림을 선택하다 보면 자신의 성향을 알려주는 성격검사 같은 사이트로 기억한다. UI/UX가 매우 매끄러워서 재미있다는 경험을 남겨줬던 것으로 기억한다.</p><p>홈페이지를 자세히 살펴보니 <strong>인재 기획사</strong>라는 표현이 눈에 띄었다. 나도 여기 소속되면 <strong>연예 기획사 연습생</strong> 이 되는 건가!<br>홈페이지를 죽 둘러보니 합격하면 무료로 취업 관련 컨설팅을 제공하는 것 같았다. <strong>자소서 첨삭</strong>, <strong>모의 면접</strong> 이런 것들은 학교 취업준비센터에서도 해줄 수 있는 항목이라 별로 눈에 띄지 않았는데 <strong>퍼스널 브랜딩</strong>, <strong>기업 인터뷰 연결</strong> , <strong>개인 프로필 리디자인</strong> 이라는 항목이 눈에 띄어서 지원하게 되었다.</p><p>지원서를 작성하니 크게 다른 항목은 없었고, <strong>개인의 스킬지수 평가</strong>와 <strong>포트폴리오(Github)</strong>. 그리고 <strong>대외활동 &amp; 인턴</strong> 경험을 묻는 항목도 있었다. 꽤 대외활동치고는 빡빡하게 정보를 입력받는 게 신기했다. 그리고 <strong>개인의 역량지수</strong>(조직 적응, 팀워크, 우선 순위화) 등을 받는 항목도 있었다.</p><p>모든 항목을 채워서 지원을 완료하고, 회사의 뒷조사(?)를 시작했다. <strong>왜 이 회사는 무료로 나 같은 취준생에게 컨설팅해준다는 것일까?</strong> 무슨 관계인지는 모르겠지만 내가 예전 개인성향검사를 했던 <code>traitify</code>와 관련이 있는 회사이고 한국 소개 홈페이지를 보니 커리어 컨설팅을 해주는 회사로 보였다. 결국에 취업 준비생들과 기업들을 연결해 주어서 커미션을 받는 헤드헌팅 하는 회사로 느껴졌다. 조금 다른 점은 기존의 개인 헤드헌터가 personal 하게 연락을 돌리는 것이 아니라 <strong>개인 성향 검사, 데이터</strong> 에 기반을 둔 기업 추천이 차별점으로 보였다.</p><hr><h2 id="서류평가-결과"><a href="#서류평가-결과" class="headerlink" title="서류평가 결과"></a>서류평가 결과</h2><img src="/2018/03/06/talentx/서류합격.png" title="서류합격"><p>퇴사 전 해야 할 일들을 정신없이 마무리하던 도중에 <strong>서류합격</strong> 메일을 받았다. 추가로 서류에 합격했으니 면접날을 정했는데 참석이 가능하냐는 유선상 연락도 함께 받았다. 2월 초에 재직하고 있던 회사의 퇴사 준비로 워낙 바빴기 때문에 따로 면접준비를 해서 면접에 가야겠다는 생각은 하지 못했다.</p><hr><h2 id="인성-면접"><a href="#인성-면접" class="headerlink" title="인성 면접"></a>인성 면접</h2><ul><li><strong>1분 자기소개를 해주세요.</strong></li></ul><p>짧은 자기소개를 하라고 어느 정도 예상은 했는데 1분(30초였는지 기억이 나지 않는다.) 자기소개를 하라고 하는데 시간제한을 주셔서 조금 당황했다. 그렇지만 이름과 학교, <strong>주로 했던 활동들(시빅해킹, 문제해결, 커뮤니티)</strong>에 대해서 간략히 설명하며 이야기를 풀어나갔다.</p><ul><li><strong>자신이 활동했던 활동들에 대해서 자세히 설명해주세요.</strong></li></ul><p><a href="http://codeforincheon.github.io/homepage/" rel="external nofollow noopener noreferrer" target="_blank">CODE FOR INCHEON</a> 이란 시빅해킹 커뮤니티에서 <strong>Organizer</strong>로 활동했던 경험과 <a href="https://www.facebook.com/groups/awskrug/" rel="external nofollow noopener noreferrer" target="_blank">AWSKRUG - AWS 한국사용자모임 공개 그룹</a> 에서 활동했던 경험을 주로 풀어서 설명하였다. <strong>커뮤니티</strong>와 <strong>사회 문제해결</strong>이라는 키워드로 화제를 풀어나갔다.</p><ul><li><strong>자신이 가장 관심 있는 분야에 관해서 설명해주세요.</strong></li></ul><p>가장 관심 있는 분야는 <code>Back-end</code> <code>Cloud &amp; Infra</code>라고 설명했다. 다음에 왜 <code>Front-end</code> 경력이 대부분인데 왜 <code>Back-End &amp; Infra</code> 에 관심이 많냐고 물어봤을 때 스타트업에 있을 때 대규모 인프라를 운영해본 경험이 없어서 그 부분이 하고 싶다고 대답했다.</p><hr><h2 id="기술면접"><a href="#기술면접" class="headerlink" title="기술면접"></a>기술면접</h2><ul><li><p><strong>프로젝트를 진행할 때 사용해본 방법론에 관해서 설명해주세요</strong><br><a href="http://www.swmaestro.kr/web/web/main.do" rel="external nofollow noopener noreferrer" target="_blank">SW Maestro</a> 에서 프로젝트를 진행할 때 멘토님의 지도하에 <code>Agile Scrum</code> 방법론을 사용해 보았고 실제로 이 방법론을 통해 프로젝트를 진행하며 느꼈던 장단점에 대하여 설명했다. 애자일 스크럼은 내가 느껴보기에 방법론보다는 개발 문화에 가까웠고</p></li><li><p><strong>DNS 스푸핑이란 무엇인가?</strong><br><code>DNS</code>의 개념과 <code>DNS 스니핑</code>은 알지만, <code>스푸핑</code>은 알지 못해서 솔직히 바로 모른다고 답변했다. 면접이 끝나고 질문시간에 추가로 이 주제에 관해서 물어보았다.</p></li></ul><ul><li><strong>자신이 가장 자신 있는 기술에 관해서 설명해주세요.</strong><br>아무래도 스타트업에 재직 중인 기간동안 웹&amp;앱 프론트를 했으니 JS를 말로 풀어내는 데 유리하다고 생각했다. JS의 역사와 변천 과정, 현재의 생태계에 관해서 설명했다.<br>그리고 <code>React</code>와 <code>React Native</code> 를 Production Level 까지 다루어 보았으니 프론트엔드 라이브러리 위주로 설명했다. 내 생각대로 <code>React</code>와 <code>Jquery</code>의 차이부터 이야기를 쭉 끌어가다가 내 앞의 면접관이 4명 모두 기술진이 아니라 인사, 경영도 함께 있다는 것을 깨달음과 동시에 이야기를 점차 마무리 지었다.</li></ul><ul><li><strong>페이퍼 코딩테스트</strong><br>개략적으로 설명하자면 영어로 된 문제를 손 코딩으로 시험을 치렀다. 문제는 여느 judge 사이트에서 쉽게 볼 수 있는 문제로 특별한 알고리즘이나 전형적인 알고리즘의 주제에 속했던 것은 아니고, 미리 정해진 기능을 수행하는 간단한 function을 만들라고 하는 느낌의 string 문제였다.<br>영문이지만 이해하기 쉬웠고 문제도 난도가 높지 않았다. 그런데…. 주어진 문제를 <strong>결론적으로 풀지 못했다.</strong> 문제도 이해가 갔고, 어찌 도는지도 알겠는데 내가 생각한 알고리즘으로는 Input을 넣었을 때 문제에 주어지는 output이 나오지 않았다. 중간중간 궁금한 걸 물어보라고 하시길래 내가 생각하는 알고리즘을 물어봤지만 결국 답을 내지 못했다. 추후에 어떤 방식으로 푸냐고 물었던 질문에는 내가 생각하는 알고리즘을 설명하다 보니 작게 <strong>주의사항, ETC</strong> 에 쓰여 있는 영어를 잘못 해석해서 답을 내지 못했던 것을 발견했다. 앞으로는 이런 세부사항을 놓치지 말아야겠다…!</li></ul><hr><h2 id="질문시간"><a href="#질문시간" class="headerlink" title="질문시간"></a>질문시간</h2><p>모든 면접에서는 질문시간이 주어진다. 학교에서 스타트업 관련 수업을 들을 때 교수님이 이 <strong>질문시간</strong>을 잘 활용하는 것이 면접의 필살기라고 말해주셨다.</p><ul><li><strong>코딩테스트를 통과하지 못했는데 치명적인가?</strong><br>그렇게 크게 중요하지 않다. 푸는 방법을 보려고 하는 것이다.</li></ul><ul><li><strong>기술면접 시간에 <code>DNS 스푸핑</code>이란 무엇인가를 대답 못 했는데 이것도 당락에 지장이 있는가?</strong><br>신입의 입장에서는 정확한 대답을 바라고 했던 질문은 아니다. 어려운 질문을 내고 어디까지 아는지를 보고 싶었다. 그런데 단칼에 모른다. 보다는 어느 정도 아는 부분 만큼은 대답하는 게 좋고 다음에 이 부분에 알아야겠다. 라고 대답하는 것이 좋다. 그리고 모르는 것을 모른다고 솔직히 말하는 것도 좋은 능력이라는 평가를 해주셨다.<blockquote><p>그래서 바로 센스있게 집에 가서 블로그 포스팅으로 DNS 스푸핑에 대해서 올리겠다고 말했다!</p></blockquote></li></ul><ul><li><strong>Traitify를 해봤는데 TalentX랑은 무슨 관련이 있는가?</strong><br>미국 실리콘밸리에 있을때 같이 co-work 한 회사이다. 성격 분석 &amp; 직업추천에 대하여 co-work 하였다.</li></ul><ul><li><strong>TalentX 1기를 모집하는데 전에 1, 2기수의 supporters 프로그램 모집을 봤다. 무슨 차이인가?</strong><br>앞서 모집했던 사람들은 blog, Facebook 등의 홍보 운영인력들이었다. 이번 모집이 진짜 자신들이 취업을 시키려는 첫 기수이다.</li></ul><p>위에도 여러 잡다한, 아니면 내가 TalentX 회사나 프로그램에 대하여 미리 조사했던 것들에 대해서 질문들을 쏟아냈다. 왜냐면 코딩테스트와 기술면접의 질문을 잘 대답을 못 했기 때문에 질문시간에 점수를 따내려고 노력했다.</p><h2 id="면접-결과"><a href="#면접-결과" class="headerlink" title="면접 결과"></a>면접 결과</h2><p>사실 면접이 끝나고 집에 오면서 내내 코딩테스트에 합격하지 못해서 떨어졌다고 생각했다. 그리고 보안에 대해서도 개발자의 기본 보안지식 수준으로 공부해야겠다고 마음을 먹었다. 그렇게 불합격을 생각하고 있었는데….<br><img src="/2018/03/06/talentx/최종합격.png" title="최종합격"></p><p>운이 좋게도 <strong>최종 합격</strong>하게 되었다! 앞으로의 내 커리어 컨설팅에 대해서 기대하며 아티클을 마친다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/2018/03/06/talentx/talentx-logo.png&quot; title=&quot;Talent&quot;&gt;
&lt;h2 id=&quot;개요&quot;&gt;&lt;a href=&quot;#개요&quot; class=&quot;headerlink&quot; title=&quot;개요&quot;&gt;&lt;/a&gt;개요&lt;/h2&gt;&lt;p&gt;어느덧 이런
      
    
    </summary>
    
      <category term="Retrospect" scheme="https://philographer.github.io/categories/retrospect/"/>
    
      <category term="Personal" scheme="https://philographer.github.io/categories/retrospect/personal/"/>
    
    
      <category term="retrospect" scheme="https://philographer.github.io/tags/retrospect/"/>
    
  </entry>
  
  <entry>
    <title>.DS_Store 파일을 git에 포함시키지 않기</title>
    <link href="https://philographer.github.io/2018/02/16/gitignore-ds-store/"/>
    <id>https://philographer.github.io/2018/02/16/gitignore-ds-store/</id>
    <published>2018-02-16T10:31:33.000Z</published>
    <updated>2018-03-08T05:00:57.707Z</updated>
    
    <content type="html"><![CDATA[<img src="/2018/02/16/gitignore-ds-store/gitignore.png" title="gitignore.io"><h2 id="문제점"><a href="#문제점" class="headerlink" title="문제점"></a>문제점</h2><p><code>MacOS</code> 환경에서 매번 프로젝트를 만들고 <code>repository</code>를 커밋할때 <code>.gitignore</code>를 제대로 만들지 않으면 <code>.DS_Store</code>가 딸려서 올라간다. 문득 쉬는 시간에 이걸 해결할 방법은 없는지 궁금해졌다.</p><h2 id="해결방법"><a href="#해결방법" class="headerlink" title="해결방법"></a>해결방법</h2><p>이미 <code>.DS_Store</code>가 커밋되었다면 다음 명령어를 사용한다.  <code>.DS_Store</code>를 찾아서 0번째 인자로 받고 이를 <code>$ git rm</code>하는 명령어이다.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -name .DS_Store -print0 | xargs -0 git rm --ignore-unmatch</span><br></pre></td></tr></table></figure></p><p>모든 <code>repository</code>에서 제거하고 싶을 때는 다음의 명령어를 사용한다. DS_Store가 상위 폴더에 있을 때나 이름이 <code>._.DS_Store</code> 일 때도 포함하지 않을 수 있다.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">".DS_Store"</span> &gt;&gt; ~/.gitignore_global</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"._.DS_Store"</span> &gt;&gt; ~/.gitignore_global</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"**/.DS_Store"</span> &gt;&gt; ~/.gitignore_global</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"**/._.DS_Store"</span> &gt;&gt; ~/.gitignore_global</span><br><span class="line">$ git config --global core.excludesfile ~/.gitignore_global</span><br></pre></td></tr></table></figure></p><h2 id="고찰"><a href="#고찰" class="headerlink" title="고찰"></a>고찰</h2><p>조금 예상하기는 했지만 역시나 <code>global</code>에 <code>.gitignore</code>를 추가하는 명령어가 있었다. 생각해보면 <code>$ git add</code>를 할 때 <code>current_directory</code>의 <code>.gitignore</code>을 읽기도 하지만 <code>~/.gitignore_global</code>도 읽는구나 예측해볼 수 있다.</p><p>출처: <a href="https://stackoverflow.com/a/26454988/5622387" rel="external nofollow noopener noreferrer" target="_blank">.gitignore all the .DS_Store files in every folder and subfolder - Stack Overflow</a><br>검색어:     <code>ignore ds_store global</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/2018/02/16/gitignore-ds-store/gitignore.png&quot; title=&quot;gitignore.io&quot;&gt;
&lt;h2 id=&quot;문제점&quot;&gt;&lt;a href=&quot;#문제점&quot; class=&quot;headerlink&quot; title=&quot;문제점&quot;&gt;&lt;/a
      
    
    </summary>
    
      <category term="tip" scheme="https://philographer.github.io/categories/tip/"/>
    
    
      <category term="-tip" scheme="https://philographer.github.io/tags/tip/"/>
    
  </entry>
  
  <entry>
    <title>Bash에서 Visual Studio Code 열기</title>
    <link href="https://philographer.github.io/2018/02/15/vscode-open-bash/"/>
    <id>https://philographer.github.io/2018/02/15/vscode-open-bash/</id>
    <published>2018-02-15T14:56:26.000Z</published>
    <updated>2018-03-08T05:00:57.723Z</updated>
    
    <content type="html"><![CDATA[<h1 id="개요"><a href="#개요" class="headerlink" title="개요"></a>개요</h1><p>원래 본인은 <code>Jetbrains</code>의 열렬한 추종자이므로  <code>Webstorm</code>을 애정하면서 쓰고있다. 그런데 요즘따라 <code>Visual Studio Code</code> 가 점점 좋아지고 있다.<br>왜냐하면 <code>VScode</code>로 간간히 편집할 일이 있다. 예를들자면 매우 큰 csv파일을 열어볼때나 Line수가 매우 긴 프로젝트의 경우는 가벼운 <code>VScode</code>가 더 간편하기 때문이다.</p><h2 id="문제점"><a href="#문제점" class="headerlink" title="문제점"></a>문제점</h2><p>간단한 JS파일을 수정하다가, 문득 Bash에서 vs code project을 열 수 있으면 무척 편하지 않을까? 생각했다. </p><h2 id="해결방법"><a href="#해결방법" class="headerlink" title="해결방법"></a>해결방법</h2><ol><li>VS Code에서 <code>Command</code> + <code>Shift</code> + <code>P</code></li><li><code>Shell Command : Install code in PATH</code> 검색 후 선택</li><li>bash에서 <code>$ code .</code> 를 타이핑하면 현재 경로를 <code>VScode</code>가 열어준다.</li></ol><p><img src="https://i.stack.imgur.com/Ng886.png" alt="VScode"></p><h2 id="고찰"><a href="#고찰" class="headerlink" title="고찰"></a>고찰</h2><p>그렇다면 Webstorm에도 이런 기능이 있지 않을까? 이걸 모르고 살았다니…</p><p><a href="https://stackoverflow.com/a/36882426/5622387" rel="external nofollow noopener noreferrer" target="_blank">macos - Run / Open VSCode from Mac Terminal - Stack Overflow</a><br>검색 키워드: <code>vscode bash open</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;개요&quot;&gt;&lt;a href=&quot;#개요&quot; class=&quot;headerlink&quot; title=&quot;개요&quot;&gt;&lt;/a&gt;개요&lt;/h1&gt;&lt;p&gt;원래 본인은 &lt;code&gt;Jetbrains&lt;/code&gt;의 열렬한 추종자이므로  &lt;code&gt;Webstorm&lt;/code&gt;을 애정하면
      
    
    </summary>
    
      <category term="tip" scheme="https://philographer.github.io/categories/tip/"/>
    
    
      <category term="tip" scheme="https://philographer.github.io/tags/tip/"/>
    
  </entry>
  
  <entry>
    <title>Fastlane, CircleCI를 이용하여 React Native DevOps 도입기 (4)</title>
    <link href="https://philographer.github.io/2018/02/15/circleci-rn4/"/>
    <id>https://philographer.github.io/2018/02/15/circleci-rn4/</id>
    <published>2018-02-15T10:38:28.000Z</published>
    <updated>2018-03-08T05:00:57.706Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-개요"><a href="#1-개요" class="headerlink" title="1. 개요"></a>1. 개요</h1><p><img src="https://i.ytimg.com/vi/Qp-BA9e0TnA/maxresdefault.jpg" alt="DevOps"><br>우리는 지금까지</p><ul><li>Fastlane, CircleCI를 이용하여 React Native DevOps 도입기 (1)</li><li>Fastlane, CircleCI를 이용하여 React Native DevOps 도입기 (2)</li><li>Fastlane, CircleCI를 이용하여 React Native DevOps 도입기 (3)<br>을 거쳐서 iOS, Android 모두 구성을 마쳤다. 이제 앞에서 진행했던 <strong>JS Test</strong>-&gt; <strong>Native Test</strong> -&gt; <strong>Beta Test Deploy</strong> 과정을 <strong>모두 자동화</strong>해보자.</li></ul><h1 id="2-package-json에-Script-추가하기"><a href="#2-package-json에-Script-추가하기" class="headerlink" title="2. package.json에 Script 추가하기"></a>2. package.json에 Script 추가하기</h1><p><code>DevOpsForRN/package.json</code>에 <code>beta</code> script를 추가되어 있는지 확인한다.<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">    "start": "node node_modules/react-native/local-cli/cli.js start",</span><br><span class="line">    "test": "jest",</span><br><span class="line">    "beta": "cd ios &amp;&amp; fastlane increase_build_number_and_push_to_beta" # 변경</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></p><h1 id="3-Fastlane-Slack-Notify-추가하기"><a href="#3-Fastlane-Slack-Notify-추가하기" class="headerlink" title="3. Fastlane Slack Notify 추가하기"></a>3. Fastlane Slack Notify 추가하기</h1><p>모든 작업이 완료되었을 때 <code>Slack</code>으로 <strong>Notification</strong>을 받기 위한 설정은 다음과 같다.<br><code>DevOpsForRN/ios/fastlane/Fastfile</code> 파일의 <code>beta lane</code> 에 <code>slack</code> 부분을 추가한다.<br><a href="http://seotory.tistory.com/24" rel="external nofollow noopener noreferrer" target="_blank">slack(슬랙), incoming webhooks 을 사용해보자. - seotory</a>의 블로그 아티클이 도움이 될 수 있다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  lane :beta do</span><br><span class="line">    desc &quot;TesfFlight for IOS&quot;</span><br><span class="line">  ...</span><br><span class="line">    ...</span><br><span class="line">    slack(</span><br><span class="line">slack_url: &quot;https://hooks.slack.com/services/*******/********/******************&quot;</span><br><span class="line">    channel: &quot;dev&quot;,</span><br><span class="line">    message: &quot;Successfully uploaded a fastlane beta release&quot;</span><br><span class="line">    )</span><br><span class="line">    end</span><br><span class="line">    ...</span><br><span class="line">end</span><br></pre></td></tr></table></figure></p><h1 id="4-작성한-내용-검증하기"><a href="#4-작성한-내용-검증하기" class="headerlink" title="4. 작성한 내용 검증하기"></a>4. 작성한 내용 검증하기</h1><p>위 설정이 올바르게 되어있으면 다음의 커맨드를 입력하였을 때 <strong>ios의 빌드 넘버를 변경</strong>하고 git의 <code>beta</code> branch에 변경내용을 <strong>push</strong>한다.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm run deploy</span><br></pre></td></tr></table></figure></p><p>우리가 설정한 <strong>테스트</strong> -&gt; <strong>빌드</strong> -&gt; <strong>베타</strong> 배포의 과정이 완료되었다면 다음과 같은 화면을 볼 수 있다.<br><img src="https://github.com/philographer/DevOpsForRN/blob/master/images/circleci-success.png?raw=true" alt="CircleCI-Success"></p><h1 id="ETC-S3-Static-Hosting으로-보여주기"><a href="#ETC-S3-Static-Hosting으로-보여주기" class="headerlink" title="ETC: S3 Static Hosting으로 보여주기"></a>ETC: S3 Static Hosting으로 보여주기</h1><p><a href="https://github.com/rufuspollock/s3-bucket-listing" rel="external nofollow noopener noreferrer" target="_blank">s3-bucket-listing</a> 플러그인을 이용하면 S3 대시보드에 직접 접속하지 않아도 Static Website Hosting처럼 S3의 내용을 표시할 수 있다.<br><img src="https://github.com/philographer/DevOpsForRN/blob/master/images/static-hosting.png?raw=true" alt="static-hosting"><br>Demo: <a href="http://devops-react-native.s3-website.ap-northeast-2.amazonaws.com/?prefix=apk/" rel="external nofollow noopener noreferrer" target="_blank">S3 Bucket Listing Generator</a></p><h1 id="ETC-Build-Error"><a href="#ETC-Build-Error" class="headerlink" title="ETC: Build Error"></a>ETC: Build Error</h1><p>혹시나 CircleCI에서 다음과 같은 에러로 빌드가 되지 않는 경우도 있다.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">bundle: Done writing bundle output</span><br><span class="line">:app:bundleReleaseJsAndAssets FAILED</span><br><span class="line"></span><br><span class="line">FAILURE: Build failed with an exception.</span><br><span class="line"></span><br><span class="line">* What went wrong:</span><br><span class="line">Execution failed <span class="keyword">for</span> task <span class="string">':app:bundleReleaseJsAndAssets'</span>.</span><br><span class="line">&gt; Process <span class="string">'command '</span>node<span class="string">''</span> finished with non-zero <span class="built_in">exit</span> value 137</span><br></pre></td></tr></table></figure></p><p><strong>해결방법:</strong> 이유는 모르겠지만 첫 번들링이 실행이 안되는 경우도 있는 것 같다. 해결방법은 첫 번들링을 로컬에서 실행해주고 remote로 올려서 CircleCI가 overwrite하게 하는 방법이다.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir android/app/src/main/assets</span><br><span class="line">$ react-native bundle --platform android --dev <span class="literal">false</span> --entry-file index.js --bundle-output android/app/src/main/assets/index.android.bundle --assets-dest android/app/src/main/res/</span><br><span class="line">$ git add --all</span><br><span class="line">$ git commit -m <span class="string">'Added bundle.android.js'</span></span><br><span class="line">$ git push origin master</span><br><span class="line">$ npm run beta</span><br></pre></td></tr></table></figure></p><p>Ref: <a href="https://github.com/facebook/react-native/issues/11696" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/facebook/react-native/issues/11696</a></p><h1 id="자동화된-과정들-정리"><a href="#자동화된-과정들-정리" class="headerlink" title="자동화된 과정들 정리"></a>자동화된 과정들 정리</h1><p><strong>React Naitve</strong>의 <strong>Beta Testing</strong>을 자동화 하기 위하여 지금까지 작성한 내용은 다음과 같다.</p><ol><li><code>$ npm run deploy</code> 커맨드를 입력한다 (Developer)</li><li>IOS Project의 Build Number를 1 증가시킨다. (Fastlane local)</li><li><code>Git</code>의 <code>beta</code> Branch에 코드를 push한다. (Fastlane local)</li><li><code>Github</code>이 Webhook을 통해 <code>CircleCI</code>가 <code>beta</code> Branch에 코드가 커밋된 사실을 알아챈다. (Github)</li><li><code>CircleCI</code>가 <code>beta</code> Branch에 대하여 JS Test -&gt; ios, android 각각 빌드 -&gt; Native 테스트 -&gt; 배포의 과정을 실행한다. (CircleCI)</li><li>ios의 경우 미리 지정한 사용자에게 <code>TestFlight</code>가 전송된다. (Fasltnae on CircleCI)</li><li>Android의 경우 미리 지정한 <code>S3</code> Bucket에 Release APK가 업로드된다. (Fasltnae on CircleCI)</li><li>Slack Message를 미리 지정한 채널에 전송한다. (Fasltnae on CircleCI)<br>따라서 일련의 과정을 그려보면 다음과 동일하다.<br><img src="https://raw.githubusercontent.com/philographer/DevOpsForRN/master/images/ci-cd-flow-completed.png" alt="flow-completed"></li></ol><h1 id="데모-프로젝트"><a href="#데모-프로젝트" class="headerlink" title="데모 프로젝트"></a>데모 프로젝트</h1><p>아래 Github에는 지금까지 적용했던 모든 사항들이 적용되어 있다. 혹시 세부적인 세팅이 궁금하다면 참조하자.<br><a href="https://github.com/philographer/DevOpsForRN" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/philographer/DevOpsForRN</a></p><h1 id="마무리하며"><a href="#마무리하며" class="headerlink" title="마무리하며"></a>마무리하며</h1><p>지금까지 <strong>FaceBook</strong>의 하이브리드 앱 프레임워크인 <strong>React Native</strong>의 <strong>CI/CD Flow</strong>를 구축해 보았다.</p><p>이용자의 Needs가 점점 다양해지면서 비즈니스 또한 그 기대에 부응하기 위하여 발 빠르게 움직여야 하는 시대가 되었다. 이에 따라서 개발자들 또한 여러 가지 <strong>Unit/integration test, beta test, build</strong> 들을 자동화하지 않고는 고객들의 요구사항을 맞출 수 없는 상황에 이르렀다. 보다 품질이 보증되는 소프트웨어를 만들기 위한 노력은 소프트웨어 생태계가 발전하면서</p><p>만약, 팀의 누군가 한 명이 자발적으로 이런 <strong>DevOps</strong>에 관심을 가지고 <strong>자동화</strong>를 한 번만 잘 적용해 놓는다면 팀 모두의 <strong>생산성</strong>과 <strong>코드의 품질</strong>을 높일 수 있다. 이제는 <strong>DevOps</strong>에 대하여 깊이 있게 알지 못하더라도, 여러 가지 좋은 <strong>서비스</strong>가 시장에 많이 나와 있으므로 작은 비용의 <strong>유료 Plan</strong>이나 <strong>Open Source</strong> 잘 조합하여 적용한다면 팀에게도 <strong>생산성</strong>과 <strong>코드 품질</strong>에 큰 도움이 되지 않을까 생각한다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-개요&quot;&gt;&lt;a href=&quot;#1-개요&quot; class=&quot;headerlink&quot; title=&quot;1. 개요&quot;&gt;&lt;/a&gt;1. 개요&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://i.ytimg.com/vi/Qp-BA9e0TnA/maxresdefault.j
      
    
    </summary>
    
      <category term="DevOps" scheme="https://philographer.github.io/categories/devops/"/>
    
    
      <category term="DevOps" scheme="https://philographer.github.io/tags/devops/"/>
    
  </entry>
  
  <entry>
    <title>Fastlane, CircleCI를 이용하여 React Native DevOps 도입기 (3)</title>
    <link href="https://philographer.github.io/2018/02/15/circleci-rn3/"/>
    <id>https://philographer.github.io/2018/02/15/circleci-rn3/</id>
    <published>2018-02-15T10:38:26.000Z</published>
    <updated>2018-03-08T05:00:57.705Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-React-Native-프로젝트에서-Fastlane을-사용하기-Android-편"><a href="#1-React-Native-프로젝트에서-Fastlane을-사용하기-Android-편" class="headerlink" title="1. React Native 프로젝트에서 Fastlane을 사용하기(Android 편)"></a>1. React Native 프로젝트에서 Fastlane을 사용하기(Android 편)</h1><p><img src="https://udemy-images.udemy.com/course/750x422/1110974_6279_2.jpg" alt="android-circleci"><br>이제 ios를 모두 구성하였으니, android를 구성해보자.</p><p>Android의 경우는 beta 배포로서 <a href="https://docs.fabric.io/apple/beta/overview.html" rel="external nofollow noopener noreferrer" target="_blank">Fabric Beta</a>도 가능하지만, 이 가이드에서는 간편함을 위해 <a href="https://aws.amazon.com/ko/s3/" rel="external nofollow noopener noreferrer" target="_blank">AWS S3</a>를 사용해본다.</p><p><code>DevOpsForRN/android/fastlane/Fastfile</code> 경로에 다음과 같이 작성한다.<br>아래 내용은 <a href="https://docs.fastlane.tools/getting-started/android/setup/" rel="external nofollow noopener noreferrer" target="_blank">Setup - fastlane docs</a> 가이드를 따라 하면 동일하게 구성할 수 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"># This file contains the fastlane.tools configuration</span><br><span class="line"># You can find the documentation at https://docs.fastlane.tools</span><br><span class="line">#</span><br><span class="line"># For a list of all available actions, check out</span><br><span class="line">#</span><br><span class="line">#     https://docs.fastlane.tools/actions</span><br><span class="line">#</span><br><span class="line"></span><br><span class="line"># Uncomment the line if you want fastlane to automatically update itself</span><br><span class="line"># update_fastlane</span><br><span class="line"></span><br><span class="line">default_platform(:android)</span><br><span class="line"></span><br><span class="line">platform :android do</span><br><span class="line">  desc &quot;Runs all the tests&quot;</span><br><span class="line">  lane :test do</span><br><span class="line">    gradle(task: &quot;test&quot;, flags: &quot;--no-daemon -x bundleReleaseJsAndAssets&quot;)</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  desc &quot;Submit a new Beta Build to Crashlytics Beta&quot;</span><br><span class="line">  lane :beta do</span><br><span class="line">    gradle(task: &quot;assembleRelease&quot;, flags: &quot;--no-daemon -x bundleReleaseJsAndAssets&quot;)</span><br><span class="line">  # crashlytics</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    # sh &quot;your_script.sh&quot;</span><br><span class="line">    # You can also use other beta testing services here</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  desc &quot;Deploy a new version to the Google Play&quot;</span><br><span class="line">  lane :deploy do</span><br><span class="line">    gradle(task: &quot;assembleRelease&quot;)</span><br><span class="line">    upload_to_play_store</span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>마찬가지로 <code>DevOpsForRN/android/fastlane/Appfile</code> 의 경로에도 다음과 같이 작성한다. 이 부분도 fastlane android 공식 가이드 문서에 따르면 동일하다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">json_key_file &quot;&quot; # Path to the json secret file - Follow https://docs.fastlane.tools/actions/supply/#setup to get one</span><br><span class="line">package_name &quot;com.devopsforrn&quot; # e.g. com.krausefx.app</span><br></pre></td></tr></table></figure><p>Android의 경우에는 release apk를 만드는데  Code Signing 필요하다. 다음의 링크를 참조하여 Code Signing을 진행한다.<br><a href="https://stackoverflow.com/a/18329835/5622387" rel="external nofollow noopener noreferrer" target="_blank">android - How to create a release signed apk file using Gradle? - Stack Overflow</a></p><h1 id="2-Gradle-시간별로-빌드"><a href="#2-Gradle-시간별로-빌드" class="headerlink" title="2. Gradle 시간별로 빌드"></a>2. Gradle 시간별로 빌드</h1><p>추후에, 빌드된 apk가 <code>S3</code>에 쌓이는데, 모두 같은 이름이라면 덮어씌워 질 수 있으므로 Gradle이 빌드되었을때 apk의 시간대별로 생성되도록 하면 구별하는데 동무을 줄 수 있다. 이와같은 기능을 사용하려면 다음의 내용을 따라해보자.</p><p><code>DevOpsForRN/app/build.gradle</code> 파일의 내용을 다음의 내용으로 수정한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">...</span><br><span class="line">applicationVariants.all &#123; variant -&gt;</span><br><span class="line">        variant.outputs.each &#123; output -&gt;</span><br><span class="line">            // For each separate APK per architecture, set a unique version code as described here:</span><br><span class="line">            // http://tools.android.com/tech-docs/new-build-system/user-guide/apk-splits</span><br><span class="line">            def versionCodes = [&quot;armeabi-v7a&quot;:1, &quot;x86&quot;:2]</span><br><span class="line">            def abi = output.getFilter(OutputFile.ABI)</span><br><span class="line">            if (abi != null) &#123;  // null for the universal-debug, universal-release variants</span><br><span class="line">                output.versionCodeOverride =</span><br><span class="line">                        versionCodes.get(abi) * 1048576 + defaultConfig.versionCode</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 시간별로 빌드하는 부분을 추가</span><br><span class="line">            def formattedDate = new Date().format(&apos;yyyy-MM-dd-HH-mm-ss&apos;)</span><br><span class="line">            def newName = output.outputFile.name</span><br><span class="line">            newName = newName.replace(&quot;-release&quot;, &quot;-release&quot; + formattedDate)</span><br><span class="line">            output.outputFile = new File(output.outputFile.parent, newName)</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>위와같이 작성하면 <code>./gradlew assembleRelease</code> 와 같은 커맨드를 입력했을때<br><code>app-release2018-02-15-12-26-58-signed.apk</code> 의 파일을 얻을 수 있으므로 시간대별로 apk를 언제 빌드했는지 알 수 있다.</p><h1 id="3-AWS의-devops-react-native-Bucket-만들기"><a href="#3-AWS의-devops-react-native-Bucket-만들기" class="headerlink" title="3. AWS의 devops-react-native Bucket 만들기"></a>3. AWS의 devops-react-native Bucket 만들기</h1><p>다음의 문서를 따라하여 <code>devops-react-native</code>라는 이름의 버킷을 만든다.<br><a href="https://docs.aws.amazon.com/ko_kr/AmazonS3/latest/gsg/CreatingABucket.html" rel="external nofollow noopener noreferrer" target="_blank">https://docs.aws.amazon.com/ko_kr/AmazonS3/latest/gsg/CreatingABucket.html</a></p><h1 id="4-AWS-CLI-설치후-aws-s3-sync"><a href="#4-AWS-CLI-설치후-aws-s3-sync" class="headerlink" title="4. AWS CLI 설치후 aws s3 sync"></a>4. AWS CLI 설치후 aws s3 sync</h1><p>기본적으로 CircleCI가 실행하는 Docker Image인 <code>circleci/node:8</code> 에는 <code>awscli</code>가 설치되어 있지 않다. 따라서 아래 내용 중 <code>beta-deploy-android</code>에 반드시 <code>awscli</code>를 설치하는 내용이 들어가야 한다.</p><p><code>DevOpsForRN/.circleci/config.yml</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"># .circleci/config.yml</span><br><span class="line"></span><br><span class="line"># To Validate your config.yml then use this cli.</span><br><span class="line"># `$ circleci config validate -c .circleci/config.yml`</span><br><span class="line">version: 2</span><br><span class="line">jobs:</span><br><span class="line">  build:</span><br><span class="line">    working_directory: ~/project</span><br><span class="line">    docker:</span><br><span class="line">      - image: circleci/node:8</span><br><span class="line">    steps:</span><br><span class="line">      - checkout</span><br><span class="line">      - run: yarn</span><br><span class="line">      - run: yarn run test</span><br><span class="line">      - persist_to_workspace:</span><br><span class="line">          root: ~/project</span><br><span class="line">          paths:</span><br><span class="line">            - node_modules</span><br><span class="line">      - store_test_results:</span><br><span class="line">          path: ~/project/junit.xml</span><br><span class="line"></span><br><span class="line">  beta-deploy-ios:</span><br><span class="line">    working_directory: ~/project/ios</span><br><span class="line">    macos:</span><br><span class="line">      xcode: &quot;9.0&quot;</span><br><span class="line">    steps:</span><br><span class="line">      - checkout:</span><br><span class="line">          path: ~/project</span><br><span class="line">      - attach_workspace:</span><br><span class="line">          at: ~/project</span><br><span class="line">      - run: bundle update fastlane</span><br><span class="line">      - run: bundle exec fastlane beta</span><br><span class="line"></span><br><span class="line">  beta-deploy-android:</span><br><span class="line">      working_directory: ~/project/android</span><br><span class="line">      docker:</span><br><span class="line">        - image: circleci/android:api-27-node8-alpha</span><br><span class="line">      steps:</span><br><span class="line">        - checkout:</span><br><span class="line">            path: ~/project</span><br><span class="line">        - attach_workspace:</span><br><span class="line">            at: ~/project</span><br><span class="line">        - run: bundle update fastlane</span><br><span class="line">        - run: bundle exec fastlane beta</span><br><span class="line">        - run: sudo apt-get update &amp;&amp; sudo apt-get install -y awscli # AWS CLI Install</span><br><span class="line">        - run: aws s3 sync app/build/outputs s3://devops-react-native/</span><br><span class="line"></span><br><span class="line">  android:</span><br><span class="line">    working_directory: ~/project/android</span><br><span class="line">    docker:</span><br><span class="line">      - image: circleci/android:api-27-node8-alpha</span><br><span class="line">    steps:</span><br><span class="line">      - checkout:</span><br><span class="line">          path: ~/project</span><br><span class="line">      - attach_workspace:</span><br><span class="line">          at: ~/project</span><br><span class="line">      - run: bundle install --path vendor/bundle</span><br><span class="line">      - persist_to_workspace:</span><br><span class="line">          root: ~/project</span><br><span class="line">          paths:</span><br><span class="line">            - android</span><br><span class="line">      - run: bundle exec fastlane test</span><br><span class="line">      - store_test_results:</span><br><span class="line">          path: ~/project/android/reports</span><br><span class="line"></span><br><span class="line">  ios:</span><br><span class="line">    macos:</span><br><span class="line">      xcode: &quot;9.0&quot;</span><br><span class="line">    working_directory: ~/project/ios</span><br><span class="line">    environment:</span><br><span class="line">      FL_OUTPUT_DIR: ~/project/output</span><br><span class="line">    shell: /bin/bash --login -o pipefail</span><br><span class="line">    steps:</span><br><span class="line">      - checkout:</span><br><span class="line">          path: ~/project</span><br><span class="line">      - run:</span><br><span class="line">          name: Set Ruby Version</span><br><span class="line">          command:  echo &quot;ruby-2.4&quot; &gt; ~/.ruby-version</span><br><span class="line">      # Not using a workspace here as Node and Yarn versions</span><br><span class="line">      # differ between the macOS image and the Docker containers above.</span><br><span class="line">      - run: yarn</span><br><span class="line">      - run: bundle install --path vendor/bundle</span><br><span class="line">      - persist_to_workspace:</span><br><span class="line">          root: ~/project</span><br><span class="line">          paths:</span><br><span class="line">            - ios</span><br><span class="line">      - run: bundle exec fastlane test</span><br><span class="line">      - store_artifacts:</span><br><span class="line">          path: ~/project/output</span><br><span class="line">      - store_test_results:</span><br><span class="line">          path: ~/project/output/scan</span><br><span class="line"></span><br><span class="line">workflows:</span><br><span class="line">  version: 2</span><br><span class="line">  node-android-ios:</span><br><span class="line">    jobs:</span><br><span class="line">      - build</span><br><span class="line">      - android:</span><br><span class="line">          requires:</span><br><span class="line">            - build</span><br><span class="line">      - beta-deploy-android:</span><br><span class="line">          filters:</span><br><span class="line">            branches:</span><br><span class="line">              only:</span><br><span class="line">                - beta</span><br><span class="line">          requires:</span><br><span class="line">            - android</span><br><span class="line">      - ios:</span><br><span class="line">          requires:</span><br><span class="line">            - build</span><br><span class="line">      - beta-deploy-ios:</span><br><span class="line">          filters:</span><br><span class="line">            branches:</span><br><span class="line">              only:</span><br><span class="line">                - beta</span><br><span class="line">          requires:</span><br><span class="line">            - ios</span><br></pre></td></tr></table></figure></p><h1 id="5-CircleCI-Env-Variable"><a href="#5-CircleCI-Env-Variable" class="headerlink" title="5. CircleCI Env Variable"></a>5. CircleCI Env Variable</h1><ul><li><p>AWS Permisson 설정<br>AWS CLI가 실행되기 위해서는 권한과 인증이 필요하다.<br><a href="https://docs.aws.amazon.com/ko_kr/IAM/latest/UserGuide/id_credentials_access-keys.html" rel="external nofollow noopener noreferrer" target="_blank">AWS IAM</a> 의 <code>Access-Key</code>와 <code>Secret-Key</code>를 아래와 같이 설정한다.<br><img src="https://github.com/philographer/DevOpsForRN/blob/master/images/aws-key-config.png?raw=true" alt="aws-permission-config"></p></li><li><p>AWS Region 설정<br>AWS CLI가 실행되기 위해서는 기본적으로 <code>region</code>이 설정되어 있어야 한다.<br><code>AWS_DEFAULT_REGION</code>를 <code>ap-northeast-2</code>로 설정이 필요하다.<br><img src="https://github.com/philographer/DevOpsForRN/blob/master/images/aws-region-config.png?raw=true" alt="aws-region-config"></p></li></ul><h1 id="6-Next"><a href="#6-Next" class="headerlink" title="6. Next"></a>6. Next</h1><ul><li><a href="https://philographer.github.io/2018/02/15/circleci-rn4/">Fastlane, CircleCI를 이용하여 React Native DevOps 도입기 (4)</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-React-Native-프로젝트에서-Fastlane을-사용하기-Android-편&quot;&gt;&lt;a href=&quot;#1-React-Native-프로젝트에서-Fastlane을-사용하기-Android-편&quot; class=&quot;headerlink&quot; title=&quot;
      
    
    </summary>
    
      <category term="DevOps" scheme="https://philographer.github.io/categories/devops/"/>
    
    
      <category term="DevOps" scheme="https://philographer.github.io/tags/devops/"/>
    
  </entry>
  
  <entry>
    <title>Fastlane, CircleCI를 이용하여 React Native DevOps 도입기 (2)</title>
    <link href="https://philographer.github.io/2018/02/15/circleci-rn2/"/>
    <id>https://philographer.github.io/2018/02/15/circleci-rn2/</id>
    <published>2018-02-15T10:38:24.000Z</published>
    <updated>2018-03-08T05:00:57.705Z</updated>
    
    <content type="html"><![CDATA[<h1 id="React-Native-프로젝트에서-Fastlane을-사용하기-IOS편"><a href="#React-Native-프로젝트에서-Fastlane을-사용하기-IOS편" class="headerlink" title="React Native 프로젝트에서 Fastlane을 사용하기 (IOS편)"></a>React Native 프로젝트에서 Fastlane을 사용하기 (IOS편)</h1><p><img src="https://docs.fastlane.tools/img/fastlane_text.png" alt="fastlane"></p><blockquote><p>아래 내용은 <a href="https://facebook.github.io/react-native/docs/getting-started.html" rel="external nofollow noopener noreferrer" target="_blank">Getting Started · React Native</a> 에 따라서 기본 환경을 구성했다는 전제 하에 진행됩니다.</p></blockquote><h1 id="React-Native-Project-만들기"><a href="#React-Native-Project-만들기" class="headerlink" title="React Native Project 만들기"></a>React Native Project 만들기</h1><blockquote><p>우선 샘플 프로젝트를 하나 만들도록 한다. 주의할 점은 <code>create-react-native-app</code>로 만들지 말아야 한다는 것이다. <code>crna</code>로 프로젝트를 만들면 <code>expo</code>로 동작하는 데 이용하면, 네이티브 프로젝트를 만들고 <strong>Native Code</strong>를 <strong>Testing</strong> 하는 것이 불가능하다.</p></blockquote><ul><li>아래 명령어로, project를 init한다.<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ react-native init DevOpsForRN <span class="comment"># Native Project Initialize</span></span><br><span class="line">$ <span class="built_in">cd</span> DevOpsForRN</span><br></pre></td></tr></table></figure></li></ul><h1 id="Fastlane을-Native-Project-Directory-에서-사용하기"><a href="#Fastlane을-Native-Project-Directory-에서-사용하기" class="headerlink" title="Fastlane을 Native Project Directory 에서 사용하기"></a><code>Fastlane</code>을 Native Project Directory 에서 사용하기</h1><ul><li>아래 서술하는 내용은 공식 문서와 동일하다.<br><a href="https://docs.fastlane.tools/getting-started/ios/setup/" rel="external nofollow noopener noreferrer" target="_blank">IOS Setup - fastlane docs</a><br><a href="https://docs.fastlane.tools/getting-started/android/setup/" rel="external nofollow noopener noreferrer" target="_blank">Android Setup - fastlane docs</a></li></ul><ul><li><p>우선 fastlane을 사용하기 위해서는 글로벌로 설치를 해야 한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Using RubyGems</span></span><br><span class="line">$ sudo gem install fastlane -NV</span><br><span class="line">$ sudo gem install bundler</span><br><span class="line"></span><br><span class="line"><span class="comment"># 위 명령어가 실행 불가능 하다면 대안으로 아래 명령어를 실행한다.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Alternatively using Homebrew</span></span><br><span class="line">$ brew cask install fastlane</span><br><span class="line">$ sudo gem install bundler</span><br></pre></td></tr></table></figure></li><li><p>첫 번째로 ios 폴더에 들어가서 초기화를 진행한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ios <span class="comment"># DevOpsForRN/ios</span></span><br><span class="line">$ fastlane init <span class="comment"># 초기화</span></span><br></pre></td></tr></table></figure></li><li><p>다음과 같이 어느 걸 하고 싶으냐고 나올 텐데 우리는 여러 가지 일들을 manual하고 싶으니 4번을 선택한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[13:48:34]: What would you like to use fastlane for?</span><br><span class="line">1. 📸  Automate screenshots</span><br><span class="line">2. 👩‍✈️  Automate beta distribution to TestFlight</span><br><span class="line">3. 🚀  Automate App Store distribution</span><br><span class="line">4. 🛠  Manual setup - manually setup your project to automate</span><br><span class="line">$ 4</span><br></pre></td></tr></table></figure></li></ul><p>명령어를 치고나면</p><ul><li><code>DevOpsForRN/ios/fastlane/Appfile</code> -&gt; 프로젝트나 account config(app_identifier, apple_id)</li><li><code>DevOpsForRN/ios/fastlane/Fastfile</code> -&gt; 실제 돌릴 명령어들을 정의</li><li><code>DevOpsForRN /ios/fastlane/Readme</code> -&gt; 설명서, lane을 추가할때 자동으로 변경됨</li><li><code>DevOpsForRN /ios/fastlane/report.xml</code> -&gt; fastlane 명령어를 돌릴때마다 변경되는 report 문서</li></ul><blockquote><p>실제로는 <code>Appfile</code> 은 정해진 계정, <strong>bundle identifier</strong>등을 맨 처음 한번만 정의하면 되고 <code>Fastfile</code>의 경우는 <strong>lane(작업들의 집합)</strong>을 정의할 때만 수정하면 된다.<br>다음 빌드로 넘어가기 전에, 한 가지를 짚고 가야 한다. <strong>IOS</strong> 에서는 <strong>Code Signing</strong>이라는 개념이 굉장히 중요하다. <strong>Code Signing을 하지 않으면 Beta testing service에 올리거나, App Store에 Deploy 할 수 없다.</strong><br><code>Fastlane</code>에는  <strong>3가지 signing 방법</strong>이 있다.</p></blockquote><h1 id="Fastlane의-3가지-Signing"><a href="#Fastlane의-3가지-Signing" class="headerlink" title="Fastlane의 3가지 Signing"></a>Fastlane의 3가지 Signing</h1><ul><li><strong>Match</strong> -&gt; <strong>private key</strong>와 <strong>certificates</strong>를 <code>git</code>에 암호화하여 보관하고, 이를 가지고 signing하는 방법</li><li><strong>Cert and Sigh</strong> -&gt; private key와 certificates를  <code>local</code>에서 가지고 있고, 이를 signing하는 방법</li><li><strong>Manual</strong> -&gt; Apple Developer Portal에서  <code>.p12</code>, <code>.cer</code>, <code>. mobileprovision</code>을 직접 signing 하는 방법</li></ul><blockquote><p>1번 방법(Match)<strong>이 암호화된 인증서를 git에 올리는 게 다소 이상할 수 있지만  이 방식은 생각보다 안전하고, </strong>새로운 팀 멤버가 들어올 경우<strong> 아니면 </strong>새로운 개발 장비를 세팅 할때도 쉽고 간편<strong>하므로 </strong>1번 방법**으로 선택했다.<br><code>Code Signing</code>에 대하여 더 자세히 이해하고 싶다면 <a href="https://codesigning.guide/" rel="external nofollow noopener noreferrer" target="_blank">Code Signing Guide for Teams</a> 문서를 참조하자.</p></blockquote><h1 id="Apple-Developer-Portal에서-Bundle-Identifier-생성"><a href="#Apple-Developer-Portal에서-Bundle-Identifier-생성" class="headerlink" title="Apple Developer Portal에서 Bundle Identifier 생성"></a>Apple Developer Portal에서 Bundle Identifier 생성</h1><ul><li><a href="https://developer.apple.com/account/ios/identifier/bundle" rel="external nofollow noopener noreferrer" target="_blank">Apple Developer Portal</a> 에서 <strong>bundle identifier</strong>를 만든다</li><li>좌측 탭에서 <strong>Identifiers</strong> -&gt; <strong>App IDs</strong></li><li>우측 상단에 <strong>+</strong> 버튼 클릭</li><li>앱 이름을 입력</li><li><code>com.teammondrian.devopsrn</code> 와 같은 당신이 만들 <strong>identifier</strong> 입력</li><li><strong>Done</strong>을 클릭<br><img src="https://github.com/philographer/DevOpsForRN/blob/master/images/apple-create-bundleid.png?raw=true" alt="apple-create-bundleid"></li></ul><h1 id="Fastlane-설정-파일-수정"><a href="#Fastlane-설정-파일-수정" class="headerlink" title="Fastlane 설정 파일 수정"></a>Fastlane 설정 파일 수정</h1><p>다음은 <a href="https://docs.fastlane.tools/actions/match/" rel="external nofollow noopener noreferrer" target="_blank">match - fastlane docs</a> 을 따라 하는 내용과 동일하다</p><ul><li>첫번째로 <strong>private key</strong>와 <strong>certificate</strong>를 담을 <a href="https://github.com/new" rel="external nofollow noopener noreferrer" target="_blank">Github Repository</a>를 새로 하나 생성한다.</li><li><p>주의할 점이 하나 있는데 민감한 정보를 담기 때문에 <strong>Private Repository</strong> 로 만들어야 한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># DevOpsForRN/ios 폴더에서 진행한다.</span></span><br><span class="line">$ fastlane match init</span><br><span class="line"><span class="comment"># 명령어를 입력하고, 방금전 만든 github-repo주소를 넣는다.</span></span><br><span class="line">$ fastlane match appstore</span><br><span class="line"><span class="comment"># 애플 아이디와 비밀번호를 묻는다.</span></span><br><span class="line"><span class="comment"># 이전에 만든 `com.teammondrian.devopsrn` 와 같은 identifier를 입력한다</span></span><br><span class="line"><span class="comment"># passphrase -&gt; 파일들을 암호화할 비밀번호를 입력한다. (자기가 만들 비밀번호)</span></span><br></pre></td></tr></table></figure></li><li><p>그러면 <code>DevOpsForRN/ios/fastlane/Matchfile</code>이 만들어 지는데, 다음과 동일하도록 수정한다.</p></li><li><code>type &quot;development&quot;</code> 를 <code>type &quot;appstore&quot;</code> 로 수정한다.</li><li><code>app_identifier [&quot;com.teammondrian.devopsrn&quot;]</code>에서 <code>com.teammondrian.devopsrn</code> 를 당신의 <strong>Bundle Identifier</strong>로 변경한 후 추가한다.</li><li><p><code>username &quot;yoohoogun114@naver.com&quot;</code> 와 같이 이메일을 당신의 <strong>Apple ID</strong>로 변경후 추가한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">git_url &quot;https://github.com/philographer/create-react-bootstrap-match.git&quot; # 당신이 생성한 git repo의 주소를 입력</span><br><span class="line"></span><br><span class="line">type &quot;appstore&quot; # 기본값은 development이지만, appstore로 수정한다. appstore, adhoc, enterprise or development가 될 수 있다.</span><br><span class="line"></span><br><span class="line">app_identifier [&quot;com.teammondrian.devopsrn&quot;] # 당신이 생성한 bundle identifier 입력</span><br><span class="line">username &quot;yoohoogun114@naver.com&quot; # 당신의 apple id로 수정</span><br><span class="line"></span><br><span class="line"># For all available options run `fastlane match --help`</span><br><span class="line"># Remove the # in the beginning of the line to enable the other options</span><br></pre></td></tr></table></figure></li><li><p><code>DevOpsForRN/ios/fastlane/Fastfile</code> 도 파일이 다음과 동일하도록 수정한다.</p></li><li><p>아래 부분에서, <code>&quot;com.teammondrian.devopsrn”</code> 로 되어 있는 부분을 당신의 <strong>Bundle Identifier</strong>로 변경한다.</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># This file contains the fastlane.tools configuration</span></span><br><span class="line"><span class="comment"># You can find the documentation at https://docs.fastlane.tools</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># For a list of all available actions, check out</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#     https://docs.fastlane.tools/actions</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Uncomment the line if you want fastlane to automatically update itself</span></span><br><span class="line"><span class="comment"># update_fastlane</span></span><br><span class="line"></span><br><span class="line">default_platform(<span class="symbol">:ios</span>)</span><br><span class="line"></span><br><span class="line">platform <span class="symbol">:ios</span> <span class="keyword">do</span></span><br><span class="line">  desc <span class="string">"Build and run tests"</span></span><br><span class="line">  lane <span class="symbol">:test</span> <span class="keyword">do</span></span><br><span class="line">    scan(<span class="symbol">scheme:</span> <span class="string">"DevOpsForRN"</span>)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  lane <span class="symbol">:beta</span> <span class="keyword">do</span></span><br><span class="line">    desc <span class="string">"TesfFlight for IOS"</span></span><br><span class="line">    <span class="comment"># Circle CI does not create new code signing certificates or provisioning profiles.</span></span><br><span class="line">    sync_code_signing(<span class="symbol">type:</span> <span class="string">"appstore"</span>, <span class="symbol">readonly:</span> <span class="literal">true</span>, <span class="symbol">app_identifier:</span> <span class="string">"com.teammondrian.devopsrn"</span>) <span class="comment"># Bundle Identifier를 아까 만든 값으로 치환한다.</span></span><br><span class="line">    <span class="comment"># see code signing guide for more information, readonly because of CircleCI</span></span><br><span class="line">    build_app(<span class="symbol">scheme:</span> <span class="string">"DevOpsForRN"</span>)</span><br><span class="line">    upload_to_testflight(<span class="symbol">skip_waiting_for_build_processing:</span> <span class="literal">true</span>)</span><br><span class="line">    <span class="comment"># slack(</span></span><br><span class="line">    <span class="comment">#   slack_url: "https://hooks.slack.com/services/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"</span></span><br><span class="line">    <span class="comment">#   channel: "dev",</span></span><br><span class="line">    <span class="comment">#   message: "Successfully uploaded a fastlane beta release"</span></span><br><span class="line">    <span class="comment"># )</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">lane <span class="symbol">:increase_build_number_and_push_to_beta</span> <span class="keyword">do</span> <span class="params">|values|</span></span><br><span class="line">    <span class="comment"># Increment the build number (not the version number)</span></span><br><span class="line">    <span class="comment"># Providing the xcodeproj is optional</span></span><br><span class="line">    increment_build_number(<span class="symbol">xcodeproj:</span> <span class="string">"DevOpsForRN.xcodeproj"</span>)</span><br><span class="line">    <span class="comment"># Commit the version bump</span></span><br><span class="line">    commit_version_bump(<span class="symbol">xcodeproj:</span> <span class="string">"DevOpsForRN.xcodeproj"</span>, <span class="symbol">force:</span> <span class="literal">true</span>)</span><br><span class="line">    <span class="comment"># Add a git tag for this build. This will automatically</span></span><br><span class="line">    <span class="comment"># use an appropriate git tag name</span></span><br><span class="line">    add_git_tag</span><br><span class="line">    <span class="comment"># Push the new commit and tag back to your git remote</span></span><br><span class="line">    push_to_git_remote(</span><br><span class="line">        <span class="symbol">remote_branch:</span> <span class="string">"beta"</span>, <span class="comment"># optional, default is set to local_branch</span></span><br><span class="line">        <span class="symbol">force:</span> <span class="literal">true</span>,    <span class="comment"># optional, default: false</span></span><br><span class="line">    )</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li><li><p><code>DevOpsForRN/ios/fastlane/Appfile</code> 도 파일이 다음과 동일하도록 수정한다.</p></li><li><code>app_identifier &quot;com.teammondrian.com&quot;</code> 에서 <code>com.teammondrian.com</code> 부분을 당신의 <strong>Bundle Identifier</strong> 로 변경 후 추가한다.</li><li><p><code>apple_id &quot;yoohoogun114@naver.com&quot;</code> 와 같이 이메일을 당신의 <strong>Apple ID</strong>로 변경후 추가한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">app_identifier &quot;com.teammondrian.com&quot; # The bundle identifier of your app</span><br><span class="line">apple_id &quot;yoohoogun114@naver.com&quot; # Your Apple email address</span><br><span class="line"></span><br><span class="line"># For more information about the Appfile, see:</span><br><span class="line">#     https://docs.fastlane.tools/advanced/#appfile</span><br></pre></td></tr></table></figure></li><li><p>IOS의 경우, TestFlight에 올리려면 <strong>Image Assets</strong> 들을 올려야 한다.  테스트 용도이므로, <a href="https://www.flaticon.com/" rel="external nofollow noopener noreferrer" target="_blank">Free vector icons</a> 에서 자기가 원하는 이미지를 선택하고<br><img src="https://github.com/philographer/DevOpsForRN/blob/master/images/use_asset_catalog.png?raw=true" alt="use_asset_catalog.png"></p></li></ul><p><strong>Use Asset Catalog</strong>를 클릭하고 필요한 Aseets들을 집어넣는다.<br>작성자는 <a href="https://itunes.apple.com/kr/app/asset-catalog-creator-pro/id809625456?mt=12" rel="external nofollow noopener noreferrer" target="_blank">Asset Catalog Creator Pro</a> 를 사용하였지만, 인터넷에서 다른 <strong>Asset Generator</strong>를 사용해도 무관하다.</p><h1 id="Itunse-Connect-앱-등록"><a href="#Itunse-Connect-앱-등록" class="headerlink" title="Itunse-Connect 앱 등록"></a>Itunse-Connect 앱 등록</h1><ul><li><a href="https://itunesconnect.apple.com/login" rel="external nofollow noopener noreferrer" target="_blank">iTunes Connect</a>에 로그인</li><li>나의 앱 -&gt; + 버튼 -&gt; 신규 앱</li><li>플랫폼 -&gt; ios 체크</li><li>나머지 내용들을 채우고, <strong>번들 ID</strong> 는 이전에 Developer Portal에서 만든 <strong>Bundle Identifier</strong>를 선택한다.<br><img src="https://github.com/philographer/DevOpsForRN/blob/master/images/itunes-create-app.png?raw=true" alt="itunes-create-app"></li></ul><h1 id="Fastlane-on-the-CircleCI"><a href="#Fastlane-on-the-CircleCI" class="headerlink" title="Fastlane on the CircleCI"></a>Fastlane on the CircleCI</h1><p>이제 대망의 <code>CircleCI</code>와 <code>Fastlane</code>을 연동할 차례이다. 이를 위해서는 <a href="https://docs.fastlane.tools/best-practices/continuous-integration/#circleci-integration" rel="external nofollow noopener noreferrer" target="_blank">Continuous Integration - fastlane docs</a> 문서를 따라해보자.</p><ul><li><p><code>DevOpsForRN/ios/fastlane/Fastfile</code> 경로에 다음과 같이 추가하자.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># DevOpsForRN/ios/fastlane/Fastfile</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">platform :ios do</span><br><span class="line">  before_all do</span><br><span class="line">    setup_circle_ci</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">desc &quot;Build and run tests&quot;</span><br><span class="line">...</span><br><span class="line">end</span><br></pre></td></tr></table></figure></li><li><p><code>DevOpsForRN/ios/fastlane/Fastfile</code> 의 완성된 내용은 다음과 같다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"># This file contains the fastlane.tools configuration</span><br><span class="line"># You can find the documentation at https://docs.fastlane.tools</span><br><span class="line">#</span><br><span class="line"># For a list of all available actions, check out</span><br><span class="line">#</span><br><span class="line">#     https://docs.fastlane.tools/actions</span><br><span class="line">#</span><br><span class="line"></span><br><span class="line"># Uncomment the line if you want fastlane to automatically update itself</span><br><span class="line"># update_fastlane</span><br><span class="line"></span><br><span class="line">default_platform(:ios)</span><br><span class="line"></span><br><span class="line">platform :ios do</span><br><span class="line">  before_all do</span><br><span class="line">    setup_circle_ci</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  desc &quot;Build and run tests&quot;</span><br><span class="line">  lane :test do</span><br><span class="line">    scan</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  lane :beta do</span><br><span class="line">    desc &quot;TesfFlight for IOS&quot;</span><br><span class="line">    # Circle CI does not create new code signing certificates or provisioning profiles.</span><br><span class="line">    sync_code_signing(type: &quot;appstore&quot;, readonly: true, app_identifier: &quot;com.teammondrian.devopsrn&quot;) # Bundle Identifier를 아까 만든 값으로 치환한다.</span><br><span class="line">    # see code signing guide for more information, readonly because of CircleCI</span><br><span class="line">    build_app(scheme: &quot;DevOpsForRN&quot;)</span><br><span class="line">    upload_to_testflight(skip_waiting_for_build_processing: true)</span><br><span class="line">    # slack(</span><br><span class="line">    #   slack_url: &quot;https://hooks.slack.com/services/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&quot;</span><br><span class="line">    #   channel: &quot;dev&quot;,</span><br><span class="line">    #   message: &quot;Successfully uploaded a fastlane beta release&quot;</span><br><span class="line">    # )</span><br><span class="line">  end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">lane :increase_build_number_and_push_to_beta do |values|</span><br><span class="line">    # Increment the build number (not the version number)</span><br><span class="line">    # Providing the xcodeproj is optional</span><br><span class="line">    increment_build_number(xcodeproj: &quot;DevOpsForRN.xcodeproj&quot;)</span><br><span class="line">    # Commit the version bump</span><br><span class="line">    commit_version_bump(xcodeproj: &quot;DevOpsForRN.xcodeproj&quot;, force: true)</span><br><span class="line">    # Add a git tag for this build. This will automatically</span><br><span class="line">    # use an appropriate git tag name</span><br><span class="line">    add_git_tag</span><br><span class="line">    # Push the new commit and tag back to your git remote</span><br><span class="line">    push_to_git_remote(</span><br><span class="line">        remote_branch: &quot;beta&quot;, # optional, default is set to local_branch</span><br><span class="line">        force: true,    # optional, default: false</span><br><span class="line">    )</span><br><span class="line">end</span><br></pre></td></tr></table></figure></li><li><p><code>DevOpsForRN</code> 폴더 안에 <code>.circleci</code>라는 디렉토리를 만든다.</p></li><li><code>DevOpsForRN/.circleci/config.yml</code> 에는 다음의 내용을 추가하자<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"># .circleci/config.yml</span><br><span class="line"></span><br><span class="line"># To Validate your config.yml then use this cli.</span><br><span class="line"># `$ circleci config validate -c .circleci/config.yml`</span><br><span class="line">version: 2</span><br><span class="line">jobs:</span><br><span class="line">  build:</span><br><span class="line">    working_directory: ~/project</span><br><span class="line">    docker:</span><br><span class="line">      - image: circleci/node:8</span><br><span class="line">    steps:</span><br><span class="line">      - checkout</span><br><span class="line">      - run: yarn</span><br><span class="line">      - run: yarn run test</span><br><span class="line">      - persist_to_workspace:</span><br><span class="line">          root: ~/project</span><br><span class="line">          paths:</span><br><span class="line">            - node_modules</span><br><span class="line">      - store_test_results:</span><br><span class="line">          path: ~/project/junit.xml</span><br><span class="line"></span><br><span class="line">  beta-deploy-ios:</span><br><span class="line">    working_directory: ~/project/ios</span><br><span class="line">    macos:</span><br><span class="line">      xcode: &quot;9.0&quot;</span><br><span class="line">    steps:</span><br><span class="line">      - checkout:</span><br><span class="line">          path: ~/project</span><br><span class="line">      - attach_workspace:</span><br><span class="line">          at: ~/project</span><br><span class="line">      - run: bundle update fastlane</span><br><span class="line">      - run: bundle exec fastlane beta</span><br><span class="line"></span><br><span class="line">  ios:</span><br><span class="line">    macos:</span><br><span class="line">      xcode: &quot;9.0&quot;</span><br><span class="line">    working_directory: ~/project/ios</span><br><span class="line">    environment:</span><br><span class="line">      FL_OUTPUT_DIR: ~/project/output</span><br><span class="line">    shell: /bin/bash --login -o pipefail</span><br><span class="line">    steps:</span><br><span class="line">      - checkout:</span><br><span class="line">          path: ~/project</span><br><span class="line">      - run:</span><br><span class="line">          name: Set Ruby Version</span><br><span class="line">          command:  echo &quot;ruby-2.4&quot; &gt; ~/.ruby-version</span><br><span class="line">      # Not using a workspace here as Node and Yarn versions</span><br><span class="line">      # differ between the macOS image and the Docker containers above.</span><br><span class="line">      - run: yarn</span><br><span class="line">      - run: bundle install --path vendor/bundle</span><br><span class="line">      - persist_to_workspace:</span><br><span class="line">          root: ~/project</span><br><span class="line">          paths:</span><br><span class="line">            - ios</span><br><span class="line">      - run: bundle exec fastlane test</span><br><span class="line">      - store_artifacts:</span><br><span class="line">          path: ~/project/output</span><br><span class="line">      - store_test_results:</span><br><span class="line">          path: ~/project/output/scan</span><br><span class="line"></span><br><span class="line">workflows:</span><br><span class="line">  version: 2</span><br><span class="line">  node-android-ios:</span><br><span class="line">    jobs:</span><br><span class="line">      - build</span><br><span class="line">      - ios:</span><br><span class="line">          requires:</span><br><span class="line">            - build</span><br><span class="line">      - beta-deploy-ios:</span><br><span class="line">          filters:</span><br><span class="line">            branches:</span><br><span class="line">              only:</span><br><span class="line">                - beta</span><br><span class="line">          requires:</span><br><span class="line">            - ios</span><br></pre></td></tr></table></figure></li></ul><p><code>CircleCI</code>에서 Code Signing, Fastlane Match를 이용하기 위해서는 다소 많은 <strong>초기 작업</strong>이 필요하다. 다음 문서를 따라 하면 일련의 초기화, key setting 작업을 완료할 수 있다. <a href="https://circleci.com/docs/2.0/ios-codesigning/" rel="external nofollow noopener noreferrer" target="_blank">Setting Up Code Signing for iOS Projects - CircleCI</a></p><ul><li><p>Github에 프로젝트 모두 올리기<br><a href="https://github.com/new" rel="external nofollow noopener noreferrer" target="_blank">Github Repository</a>를 새로 하나 생성한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># DevOpsForRN/ 디렉토리에서 진행한다.</span></span><br><span class="line">$ git init</span><br><span class="line">$ git remote add origin https://github.com/philographer/DevOpsForRN.git <span class="comment"># 자신의 repo 주소로 변경하기</span></span><br><span class="line">$ git add --all</span><br><span class="line">$ git commit -m <span class="string">"first commit"</span></span><br><span class="line">$ git push -u origin master</span><br></pre></td></tr></table></figure></li><li><p>CircleCI의 Project를 생성한다.</p></li><li><a href="https://circleci.com/dashboard" rel="external nofollow noopener noreferrer" target="_blank">CircleCI - Dashboard</a> 접속</li><li><strong>MacOS 빌드는 유료이므로, 무료 플랜을 선택한다.</strong></li><li>좌측 <strong>Settings</strong> -&gt; <strong>MacOS Plan</strong> -&gt; <strong>Trial Plan</strong> Click</li><li>좌측 <strong>Project</strong> 탭 클릭 -&gt; <strong>Add Project</strong> 클릭</li><li>방금 만든 Github Repo의 오른쪽에 <strong>Setup Project</strong> 버튼을 클릭</li><li>OS는 <strong>macOS</strong> 선택</li><li><strong>Start Build</strong> 버튼 선택</li><li>Work-Flow 탭으로 이동되는데, 자세히 보려면 빌드 이름을 누르면 된다.</li><li><p>다음과 같이 보이면 성공이다.<br><img src="https://github.com/philographer/DevOpsForRN/blob/master/images/circleci_ios_build.png?raw=true" alt="circleci_ios_build.png"></p></li><li><p>CircleCI의 <strong>Project Setting</strong> -&gt; <strong>Environment Variables</strong> -&gt; <strong>Add Variable</strong> 을 클릭하고, 다음의 환경변수들을 추가한다.<br><code>MATCH_PASSWORD</code>: 아까 만든 match pass phrase 입력<br><code>FASTLANE_USER</code>: Apple ID 입력 (ex. <a href="mailto:`yoohoogun114@naver.com" rel="external nofollow noopener noreferrer" target="_blank">`yoohoogun114@naver.com</a><code>)</code>FASTLANE_PASSWORD`:  Apple PW 입력<br><img src="https://github.com/philographer/DevOpsForRN/blob/master/images/circleci_ios_env.png?raw=true" alt="circleci_ios_env.png"></p></li><li><p>CircleCI의 <strong>Project Setting</strong> -&gt; <strong>Checkout SSH Keys</strong> -&gt; <strong>Add Deploy Key</strong> 버튼 또는 <strong>Create and add … user key</strong> 버튼을 클릭한다.<br>그렇다면 후에 CI에서 debug 해야 할 ssh-key를 자동으로 vm에 미리 넣어준다. 따라서 미리 지정해둔 계정에서는 ci vm에 접근할 수 있다.<br><img src="https://github.com/philographer/DevOpsForRN/blob/master/images/circleci_ssh.png?raw=true" alt="circleci_ssh.png"></p></li></ul><h2 id="Trigger-Script-작성"><a href="#Trigger-Script-작성" class="headerlink" title="Trigger Script 작성"></a>Trigger Script 작성</h2><ul><li><code>DevOpsForRN/package.json</code> 파일을 다음과 같이 수정한다</li><li><code>scripts</code>에 <code>native-test</code>  추가</li><li><p><code>scripts</code>에 <code>beta</code>  추가</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"DevOpsForRN"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"0.0.1"</span>,</span><br><span class="line">  <span class="attr">"private"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"start"</span>: <span class="string">"node node_modules/react-native/local-cli/cli.js start"</span>,</span><br><span class="line">    <span class="attr">"test"</span>: <span class="string">"jest"</span>,</span><br><span class="line">    "native-test": "tools/run_native_test.sh", # 추가</span><br><span class="line">    "beta": "tools/run_beta_deploy.sh", # 변경</span><br><span class="line">  &#125;,</span><br><span class="line">  "dependencies": &#123;</span><br><span class="line">    "react": "16.2.0",</span><br><span class="line">    "react-native": "0.52.1",</span><br><span class="line">    "react-native-fabric": "^0.5.1"</span><br><span class="line">  &#125;,</span><br><span class="line">  "devDependencies": &#123;</span><br><span class="line">    "babel-jest": "22.1.0",</span><br><span class="line">    "babel-preset-react-native": "4.0.0",</span><br><span class="line">    "jest": "22.1.4",</span><br><span class="line">    "react-test-renderer": "16.2.0"</span><br><span class="line">  &#125;,</span><br><span class="line">  "jest": &#123;</span><br><span class="line">    "preset": "react-native"</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Shell Script 작성하기</p></li><li><code>DevOpsForRN/tools</code> 디렉토리를 생성한다</li><li><p><code>DevOpsForRN/tools/run_beta_deploy.sh</code> 파일을 생성하고, 다음의 내용을 작성한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> ios</span><br><span class="line">fastlane increase_build_number_and_push_to_beta</span><br></pre></td></tr></table></figure></li><li><p><code>DevOpsForRN/tools/run_native_test.sh</code> 파일을 생성하고, 다음의 내용을 작성한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> ios</span><br><span class="line">fastlane <span class="built_in">test</span></span><br></pre></td></tr></table></figure></li><li><p>작성한 후, 권한을 부여한다</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ chmod +x run_beta_deploy.sh</span><br><span class="line">$ chmod +x run_beta_deploy.sh</span><br></pre></td></tr></table></figure></li></ul><h1 id="Xcode-Signing-설정"><a href="#Xcode-Signing-설정" class="headerlink" title="Xcode Signing 설정"></a>Xcode Signing 설정</h1><ul><li>fastlane에서 사용할 인증서를 선택한다.<br><img src="https://github.com/philographer/DevOpsForRN/blob/master/images/xcode_sign.png?raw=true" alt="xcode_sign.png"></li></ul><h1 id="TestFlight에-사용자-초대"><a href="#TestFlight에-사용자-초대" class="headerlink" title="TestFlight에 사용자 초대"></a>TestFlight에 사용자 초대</h1><ul><li><a href="https://itunesconnect.apple.com/" rel="external nofollow noopener noreferrer" target="_blank">iTunes Connect</a> 에 접속</li><li>나의 앱 -&gt; 자신이 이전에 만들었던 앱 클릭</li><li>TestFlight 탭 클릭</li><li>테스터 및 그룹 -&gt; Itunes Connect 사용자 클릭</li><li><ul><li>버튼 누르고, 사용자 초대</li></ul></li><li>초대한 사용자의 이메일에서 초대 수락<br><img src="https://github.com/philographer/DevOpsForRN/blob/master/images/itunes_invite.png?raw=true" alt="itunes_invite"></li></ul><h1 id="암호화"><a href="#암호화" class="headerlink" title="암호화"></a>암호화</h1><ul><li>앱 내 추가 기능</li><li>암호화 탭의 지침에 따른다.<br><img src="https://github.com/philographer/DevOpsForRN/blob/master/images/ios_encrypt.png?raw=true" alt="ios_encrypt"></li></ul><h1 id="작성한-내용-검증하기"><a href="#작성한-내용-검증하기" class="headerlink" title="작성한 내용 검증하기"></a>작성한 내용 검증하기</h1><p>다음의 스크립트를 실행했을 때, Circle CI에서 work-flow가 올바르게 실행되나 지켜본다.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># DevOps/ 디렉토리에서</span></span><br><span class="line">$ npm run beta</span><br></pre></td></tr></table></figure></p><ul><li><a href="https://circleci.com/dashboard" rel="external nofollow noopener noreferrer" target="_blank">CircleCI Dashboard</a> 접속</li><li>다음과 같이 JS Test -&gt; IOS Native Test -&gt; TestFlight Deploy가 성공했는지 확인<br><img src="https://github.com/philographer/DevOpsForRN/blob/master/images/circleci_ios_success.png?raw=true" alt="circleci_ios_success.png"></li></ul><h1 id="Next"><a href="#Next" class="headerlink" title="Next"></a>Next</h1><ul><li><a href="https://philographer.github.io/2018/02/15/circleci-rn3/">Fastlane, CircleCI를 이용하여 React Native DevOps 도입기 (3)</a></li><li><a href="https://philographer.github.io/2018/02/15/circleci-rn4/">Fastlane, CircleCI를 이용하여 React Native DevOps 도입기 (4)</a></li></ul><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://docs.fastlane.tools/actions/match/#is-this-secure" rel="external nofollow noopener noreferrer" target="_blank">match is-this-secure? - fastlane docs</a><br><a href="https://github.com/CircleCI-Public/circleci-demo-react-native" rel="external nofollow noopener noreferrer" target="_blank">GitHub - CircleCI-Public/circleci-demo-react-native: A demo React Native project that’s building on CircleCI 2.0 with Workflows.</a><br><a href="https://medium.com/react-native-training/fastlane-for-react-native-ios-android-app-devops-8ca85bee614e" rel="external nofollow noopener noreferrer" target="_blank">fastlane for React Native iOS &amp; Android app DevOps – React Native Training – Medium</a><br><a href="https://github.com/CircleCI-Public/circleci-demo-workflows/blob/workspace-forwarding/.circleci/config.yml" rel="external nofollow noopener noreferrer" target="_blank">circleci-demo-workflows/config.yml at workspace-forwarding · CircleCI-Public/circleci-demo-workflows · GitHub</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;React-Native-프로젝트에서-Fastlane을-사용하기-IOS편&quot;&gt;&lt;a href=&quot;#React-Native-프로젝트에서-Fastlane을-사용하기-IOS편&quot; class=&quot;headerlink&quot; title=&quot;React Native 프
      
    
    </summary>
    
      <category term="DevOps" scheme="https://philographer.github.io/categories/devops/"/>
    
    
      <category term="DevOps" scheme="https://philographer.github.io/tags/devops/"/>
    
  </entry>
  
  <entry>
    <title>Fastlane, CircleCI를 이용하여 React Native DevOps 도입기 (1)</title>
    <link href="https://philographer.github.io/2018/02/15/circleci-rn1/"/>
    <id>https://philographer.github.io/2018/02/15/circleci-rn1/</id>
    <published>2018-02-15T10:38:23.000Z</published>
    <updated>2018-03-08T05:00:57.705Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-개요"><a href="#1-개요" class="headerlink" title="1. 개요"></a>1. 개요</h1><p><img src="https://sdtimes.com/wp-content/uploads/2017/05/screen_shot_2017-05-25_at_12.16.16_pm.png" alt="DevOps"></p><blockquote><p>사내 프로젝트를 진행하면서 <a href="https://facebook.github.io/react-native/" rel="external nofollow noopener noreferrer" target="_blank">React Native</a> 앱을 개발하게 되었는데, 앱이 점점 덩치가 커지더니 코드 라인 수가 몇만 라인을 돌파할 즈음 <strong>CI/CD</strong> 프로세스 없이는 도저히 프로젝트 진행이 불가능하다고 느껴졌다. -(너무 늦게 도입했다는 생각이..)-<br>예를 들자면 다음의 경우에 개발자의 <strong>Context Switching</strong>이 많이 일어나고 <strong>개발자의 생산성</strong>이 떨어지는 문제가 있었다.</p></blockquote><ol><li>클라이언트가 <strong>“중간 배포 버전을 보고 싶다”</strong> 라고 하면 중간 배포 버전을 만들기 위해 Production Build를 하고, 배포 서버에 APK를 올리거나 TestFlight에 업로드 해야할 경우 코딩을 진행할 수 없음.</li><li><strong>라이브러리가 업데이트</strong> 되었을 때 build가 깨질 경우 어느 라이브러리가 문제인지 디버그해야 함.</li><li>코드를 수정했는데, 메인 페이지가 <strong>rendering</strong>이 제대로 되지 않을 경우 앱 내로 진입할 수 없음. 디버그해야 함.</li><li>최종 수정 버전을 <strong>Android Play Store</strong>, <strong>IOS APP Store</strong>에 업로드 해야하는 경우, 코딩을 할 수 없음.</li><li>Reat Native의 경우 IOS, Android Project가 각각 나오기 때문에, 테스트를 따로 진행해야 함.</li></ol><p>위의 문제들은 모두 <strong>CI(Continuous Integration)</strong>, <strong>CD(Continuous Deploy)</strong> Process를 잘 정립하면 해결되는 문제라고 판단하고 다음의 Flow를 설계해보았다.</p><h1 id="2-What-to-Make"><a href="#2-What-to-Make" class="headerlink" title="2. What to Make"></a>2. What to Make</h1><p><img src="https://raw.githubusercontent.com/philographer/DevOpsForRN/master/images/ci-cd-flow.png" alt="flow"><br>따라서 결론적으로 만들고 싶은 프로세스는 다음과 같았다.</p><ol><li>개발자가 각 용도에 맞는 branch에 코드를 커밋한다</li><li>Github은 web hook을 이용하여 CI/CD Tool에 이를 알린다.</li><li>CI/CD 툴은 Android, IOS를 각각 테스트하며 테스트 배포앱을 결과물로 제공한다</li><li>Slack에는 테스트 결과, 테스트 배포 앱 링크를 제공한다.</li></ol><p>이러한 flow에 알맞는 CI / CD, Automation 기술 스택들을 선정하기 위해 여러 가지 후보군을 선정해 보았다.</p><h1 id="3-Jenkins-Vs-Travis-Vs-CircleCI"><a href="#3-Jenkins-Vs-Travis-Vs-CircleCI" class="headerlink" title="3. Jenkins Vs Travis Vs CircleCI"></a>3. Jenkins Vs Travis Vs CircleCI</h1><p><img src="https://github.com/philographer/DevOpsForRN/blob/master/images/circle_vs_others.png?raw=true" alt="circle_vs_others"></p><p>초창기에는 이전에 사용해 보았던 <a href="https://jenkins.io/" rel="external nofollow noopener noreferrer" target="_blank">Jenkins</a>를 고려하였으나 <strong>자체 보유하고 있는 서버</strong>에 올리거나 <strong>클라우드</strong>에 올려야 하기 때문에 <strong>서버 관리 비용(돈+노력)</strong>이 필요하고 <strong>Jenkins</strong>의 <strong>복잡한 Configuration</strong> 때문에 생기는 <strong>높은 Learning Curved</strong>가 필요하며 결정적인 이유로 <strong>MacOS</strong>에서 <strong>Xcode Build</strong>를 해야하기 때문에 <strong>MacOS</strong>가 필요하는 등 여러가지 이유로 선택지에서 제외하였다.</p><p>그다음 선택지는 <strong>Travis</strong> 였는데 <strong>CircleCI</strong> 와 많은 고민을 거쳤다. 사실 두 가지 모두 성숙한 서비스이기 때문에 무엇을 선택해도 크게 다르지 않다는 생각을 가지고 있었다. 따라서 이미 사용해봤던 <strong>Travis</strong>를 도입하려던 찰나 <strong>FaceBook의 React Native</strong> 프로젝트인 <a href="https://circleci.com/gh/facebook/react-native" rel="external nofollow noopener noreferrer" target="_blank">facebook/react-native</a> 는 <strong>어떤 CI Tool을 사용하고 있나 궁금해졌다.</strong> 확인해 본 결과 FaceBook이 사용하고 있는 Tool은 <strong>CircleCI</strong> 였다.<br>그렇다면 왜 <strong>CircleCI</strong>를 사용했을까? <strong>React Naitve</strong>의 프로젝트 커밋 히스토리를 찾아보니 이전에는 <strong>Travis</strong>와 <strong>CircleCI</strong>를 둘다 사용했었고,  점차 <strong>Travis</strong> -&gt; <strong>CircleCI</strong>로 Migration하는 커밋들이 늘어났다. 이유는 <strong>빌드 속도</strong> 때문으로 보인다.<br>CI Tool들은 직접 컨택을 하지 않는 이상 과금이 총 빌드 시간과 관련이 있다. 따라서 빌드시간이 적으면 적을수록 과금 정책이 싼 plan을 선택할 수 있기 때문에 <strong>빌드 속도, 시간</strong>은 무척 중요하다. -물론 개발자가 오랜 빌드를 기다리기 싫은 이유도 있고-</p><p>관련 커밋:  <a href="https://github.com/facebook/react-native/pull/16354" rel="external nofollow noopener noreferrer" target="_blank">Migrate Travis over to Circle by grabbou · Pull Request #16354 · facebook/react-native · GitHub</a></p><h1 id="4-CI-CD-Tool-로서의-선택-CircleCI"><a href="#4-CI-CD-Tool-로서의-선택-CircleCI" class="headerlink" title="4. CI/CD Tool 로서의 선택: CircleCI"></a>4. CI/CD Tool 로서의 선택: CircleCI</h1><p><img src="https://github.com/philographer/DevOpsForRN/blob/master/images/circle.png?raw=true" alt="circle"><br>따라서 우리도 <strong>React Native</strong>의 프로젝트처럼 과거의 문제를 답습하지 않기 위하여 히스토리를 뒤져보다가 <strong>CircieCI</strong>를 선택하였고 <a href="https://circleci.com/docs/2.0/" rel="external nofollow noopener noreferrer" target="_blank">2.0 Docs - CircleCI</a>부터 차례대로 진행하였다. 프로젝트를 진행하였을 때는 <strong>MacOS</strong>가 <strong>CircleCI 1.0</strong>만 가능했었는데 <strong>2018년 1월</strong>부터 <strong>CircleCI 2.0</strong>도 지원하기 때문에 아티클을 쓰는 겸사겸사 아래에서 1.0 -&gt; 2.0 Migration을 진행해보기로 한다. </p><h1 id="5-Fastlane-Vs-Appium-VS-Bitrise"><a href="#5-Fastlane-Vs-Appium-VS-Bitrise" class="headerlink" title="5. Fastlane Vs Appium VS Bitrise"></a>5. Fastlane Vs Appium VS Bitrise</h1><p><img src="https://github.com/philographer/DevOpsForRN/blob/master/images/fastlane_vs_others.png?raw=true" alt="fastlane_vs_others"><br>사실 세 가지 툴들은 동일한 카테고리에 있는 경쟁대상은 아니다.<br><a href="https://fastlane.tools/" rel="external nofollow noopener noreferrer" target="_blank">Fastlane</a>은 <strong>App Automation</strong> Tool을 담당하는 오픈소스이고 무료<br><a href="http://appium.io/" rel="external nofollow noopener noreferrer" target="_blank">Appium</a>은 <strong>App Test</strong>의 목적으로 사용은 오픈소스이며 무료<br><a href="http://bitrise.io/" rel="external nofollow noopener noreferrer" target="_blank">Bitrise</a>은 <strong>CI/CD Tool</strong> 서비스이며 유료</p><p>우리가 만들려고 하는 CI/CD Architecture에서 위의 3가지 툴들에게 기대하는 근본적인 역할은 다음 세 가지다.</p><ol><li>기능이 풍부하고 쉬우며 <strong>관리</strong>를 줄일 수 있는 좋은 툴이라면 얼마든지 비용을 지급할 수 있다. 다만 많은 기능을 쓰지 않는다면 <strong>스타트업</strong>은 비싼 플랜이나, <strong>정기적인 과금</strong>을 지출하기에는 까다로움이 있다. 따라서 웬만하면 <strong>무료</strong>여야 한다. -&gt; <strong>Fastlane</strong>, <strong>Appium</strong></li><li><strong>CI</strong> 위에서 테스트와 배포에 도움을 주어야 한다. -&gt; <strong>Fastlane</strong>, <strong>Appium</strong>, <strong>Bitrise</strong>(자체 CI Tool)</li><li>생태계가 성숙 돼 있고 건강하며, 활성화가 아직도 진행 중어야 한다. 이는 곧 레퍼런스가 풍부함을 의미한다. -&gt; <strong>Fastlane</strong> (Star 수가 가장 많고, 검색결과가 많음)</li></ol><p>세가지 모두가 비교대상인  <code>대체재</code> 라기보다는, 어느정도의 역할을 상대방이 보완해 줄 수 있는 <code>보완재</code>의 성격을 가지고 있다. <strong>Bitrise</strong> 같은 경우에는 <strong>Fastlane</strong> 과 궁합이 좋다는 외국 커뮤니티의 글이나 <strong>fastlane</strong> 진영에 글들이 많아서 잠깐 고려하기도 했으나 <strong>CircleCI</strong>가 <strong>Bitrise</strong>를 대체할 수 있으니, 이미 <strong>CircleCI</strong>를 선택하려고 마음을 먹었다면 1,2,3번의 조건을 모두 만족하는 <strong>Fastlane</strong> 진영으로 마음을 굳혔다.</p><blockquote><p>Britise는 <code>Mobile</code>을 타겟으로 나온 서비스이기 때문에 <strong>CircleCI</strong> 보다는 목적이 더 명확하다고 할 수 있다. 하지만 우리 팀은 앱만 만드는 것이 아니기 때문에 보다 범용적인 CI Tool인 <strong>CircleCI</strong>, <strong>Fastlane</strong>를 선택하지만 <code>Mobile first</code> 전략을 취하고 있는 스타트업이라면 <strong>Bitrise</strong>도 충분히 고려할 만하다.</p></blockquote><h1 id="6-Automation-Tool-로서의-선택-Fastlane"><a href="#6-Automation-Tool-로서의-선택-Fastlane" class="headerlink" title="6. Automation Tool 로서의 선택: Fastlane"></a>6. Automation Tool 로서의 선택: Fastlane</h1><p><img src="https://github.com/philographer/DevOpsForRN/blob/master/images/fastlane.png?raw=true" alt="fastlane"><br><a href="https://fastlane.tools/" rel="external nofollow noopener noreferrer" target="_blank">fastlane</a>이란 툴은 Application의 Automation에 필요한 기능을 담고 있는 툴이다. 예를 들자면, <code>$ fastlane beta</code> 라는 명령어를 친면</p><ol><li>Build Number를 증가시키고</li><li>앱을 빌드하고</li><li>TestFlight에 업로드하고</li><li>Slack에 메시지를 보낸다.</li></ol><p>이런 일련의 과정들을 간단한 CLI 명령어 한줄로 대신 수행해주며 아래와 같은 간단한 <code>ruby</code> 문법으로 행동을 정의할 수 있다.<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">lane <span class="symbol">:beta</span> <span class="keyword">do</span></span><br><span class="line">increment_build_number</span><br><span class="line">build_app</span><br><span class="line">upload_to_testflight</span><br><span class="line">slack</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><h1 id="Next"><a href="#Next" class="headerlink" title="Next"></a>Next</h1><ul><li><a href="https://philographer.github.io/2018/02/15/circleci-rn2/">Fastlane, CircleCI를 이용하여 React Native DevOps 도입기 (2)</a></li><li><a href="https://philographer.github.io/2018/02/15/circleci-rn3/">Fastlane, CircleCI를 이용하여 React Native DevOps 도입기 (3)</a></li><li><a href="https://philographer.github.io/2018/02/15/circleci-rn4/">Fastlane, CircleCI를 이용하여 React Native DevOps 도입기 (4)</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-개요&quot;&gt;&lt;a href=&quot;#1-개요&quot; class=&quot;headerlink&quot; title=&quot;1. 개요&quot;&gt;&lt;/a&gt;1. 개요&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://sdtimes.com/wp-content/uploads/2017/05/scr
      
    
    </summary>
    
      <category term="DevOps" scheme="https://philographer.github.io/categories/devops/"/>
    
    
      <category term="DevOps" scheme="https://philographer.github.io/tags/devops/"/>
    
  </entry>
  
  <entry>
    <title>초보자를 위한 AWS 뿌시기 AUSG 세미나 후기</title>
    <link href="https://philographer.github.io/2018/01/30/ausg-seminar/"/>
    <id>https://philographer.github.io/2018/01/30/ausg-seminar/</id>
    <published>2018-01-30T03:37:50.000Z</published>
    <updated>2018-03-08T05:00:57.696Z</updated>
    
    <content type="html"><![CDATA[<img src="/2018/01/30/ausg-seminar/poster2.jpeg" title="ausg_poster2"><h2 id="개요"><a href="#개요" class="headerlink" title="개요"></a>개요</h2><p>세미나 또는 단순 PPT 발표 등은 여러 번 해보았지만 <strong>핸즈온랩</strong>은 저번 유니톤 세미나 이후로 두 번째였다. 일주일의 갭을 두고 2번의 발표가 있어서 회사일과 개인 일정은 많이 제쳐두고 핸즈온 실습에 대해서 <a href="https://awskrug.github.io/ausg/" rel="external nofollow noopener noreferrer" target="_blank">AUSG</a> 친구들과 함께 리허설도 많이 해보고 피드백도 여러 방면으로 주고받았다.</p><p>저번 세미나는 <strong>대학생</strong>들을 위한 AWS 강의였기 때문에 그렇게 떨리거나 하지 않았지만, 이번에는 <strong>현업 직장인</strong>분들도 많이 오셔서 준비한 내용이 변변치 않다면 많은 폐를 끼칠 것 같아서 <strong>조금 더 오랜 시간을 잡고 준비했다. </strong></p><p><code>C9</code>과 <code>Elastic Beanstalk</code> 이란 서비스를 잡고 세미나를 준비했었는데 <code>c9</code>의 경우에는 이전 <a href="https://likelion.net/" rel="external nofollow noopener noreferrer" target="_blank">멋쟁이사자처럼</a> 이라는 동아리에서 활동할 때 많이 다루어 봤기 때문에 큰 문제는 없었다. 그런데 <code>Elastic Beanstalk</code>의 경우 POC(poof of concept)  정도는 진행 해 보았지만 <code>Production Level</code> 까지는 다루지 않아봤기 때문에 운영레벨에서의 후기까지는 들려주기 힘들다고 생각했다. 그래서 더 열심히 준비했다.</p><p>아래 내용은 핸즈온랩을 준비했던 과정, 세미나를 진행하면서 느꼈던 느낌과 후에 돌아보면서 잘한 점 잘못 했던 점을 짚고 넘어가는 형식이다.<br>나중에도 세미나에서 발표할 자리가 있다면 조금 더 나은 세미나를 준비하고 싶은 개인적인 욕심에서 주절주절 기록해두면 좋겠다는 생각에 글을 써본다.</p><h2 id="발표-준비"><a href="#발표-준비" class="headerlink" title="발표 준비"></a>발표 준비</h2><p>우선 실습서의 내용은 이전 세미나에서 진행했던 틀을 그대로 잡고 만들기 시작했다.<br><a href="https://github.com/awskrug/unithon-serverless-2018" rel="external nofollow noopener noreferrer" target="_blank">awskrug/unithon-serverless-2018: 대학생 연합 해커톤 유니톤 2018 serverless 세미나</a><br>이전에 만들었었던 세미나 자료인데 원본은 <a href="https://github.com/awslabs" rel="external nofollow noopener noreferrer" target="_blank">AWSLABS</a>에서 만든 것이었고, <code>AWS KRUG: AWS 한국 사용자 모임</code> 번역을 해주셨던 자료였다. 그 자료를 내가 AWS Console이 한글화가 진행됨에 따라 약간의 번역과 최신내용으로 업데이트한 자료였다. 이 자료를 발판으로 이번 <code>C9, Elastic Beanstalk</code> 자료도 차근차근 만들기 시작했다. 나는 발표를 시작하기에 앞서 항상 <strong>목차</strong>부터 짠다. <del>(큰 그림을 그리는 사람)</del></p><ol><li>Cloud 9 시작하기<br>이 책터는 목차는 단순히 <code>C9</code>의 기능인 private ec2 인스턴스를 띄우고 그 환경에서 c9으로 작업하는 활동을 하기로 구성했다. 쉬워서 금방 끝날 것으로 생각했다.</li><li>Cloud9 &amp; EC2 접속<br>두 번째는 <code>C9</code>의 신기한 기능인데 이미 만들어져 있는 <code>EC2</code>인스턴스에 <code>C9</code>으로 접속할 수 있는 기능을 실습해보는 챕터로 구성했다. <code>C9</code>의 경우에는 기본적으로 python, java, node등 기본적인 개발환경이 구성되어 있는데 <code>EC2</code> 인스턴스에 접속하면 어떻게 될까? 가 나도 궁금했다. 직접 실행해보니 첫 접속때 <code>EC2</code>에 기본적인 개발환경을 세팅할 수 있는것을 볼 수 있었다. 생각보다 금방 끝날 것이라고 생각했는데 <code>EC2</code> 인스턴스가 바로 뜨는것도 아니고, 접속해서 <code>SSH</code> 키도 밀어넣는 작업도 필요해서 시간을 좀 길게 할당했다.</li><li>C9 친구와 작업하기<br>AWS에 C9이 인수가 되기 전에는, 그냥 상대방 이메일만 알면 co-work(동시편집)이 가능했는데 AWS로 인수되면서 여러 보안 문제 때문에 <code>IAM</code>을 설정해 주어야만 동시 작업이 가능했다. <code>IAM</code>이라는 기능이 보안상 상당히 중요하지만, AWS 초보자에게는 쉽게 간과하고 넘어갈 수 있는 부분이기 때문에 자세히 진행하려고 노력했다.</li><li>Elastic Beanstalk<br>내가 <code>Production Level</code>에서 사용해보지 않은 사람으로서 내가 발표해도 될까? 라는 걱정이 문득 들었다. 하지만 Elastic Beanstalk은 AWS의 초보자에게 무척이나 핵심적인 서비스라고 생각이 들었기 때문에 내 세미나에 주제로 선택했다. <code>Elastic Beanstalk</code>은 어느 정도 관리의 손을 덜어주는 유용한 서비스이기 때문에 <code>EC2</code>, <code>ELB</code>, <code>Security Group</code>, <code>Auto Scaling Group</code> 를 전혀 몰라도 대시보드에서 쉽게 <strong>Scale-Out</strong> 설정이 가능하고 <strong>쉬운 배포</strong> 에 강점이 있기 때문에 꼭 진행해야 한다고 생각했다. 나도 많이 써본 기능은 아니지만 공식 문서를 천천히 읽고 기존 운영 경험을 토대로 <strong>장단점</strong>을 설명하면 그래도 유용하지 않을까 생각했다. 거기에 직접 사용해보지는 않았어도 조금 빨리 배운 선배로서 시간낭비를 줄일 수 있는 꿀팁이 있을 거라고 생각해서 목차에 넣었다.</li><li>Elastic BeanStalk With C9<br>마지막 주제는 앞에서 했던 것들과 Elastic Beastalk를 <code>EB Cli</code>를 이용해서 내 컴퓨터에 전혀 개발환경이 세팅되지 않았어도 인터넷이 연결된 브라우져만 있다면 <strong>개발과 배포</strong> 가 가능하다는 것을 보여주고 싶어서 준비했다. 그리고 앞의 내용을 통째로 묶으면서 간단한 아키텍쳐에 대해서 이해할 수 있겠다는 생각해서 이런 구성으로 준비했다.</li></ol><p>이렇게 발표 주제를 5가지로 세분화하고 세부 내용을 구성하면서 <a href="https://aws.amazon.com/ko/getting-started/tutorials/" rel="external nofollow noopener noreferrer" target="_blank">Amazon Web Services(AWS) 10분 자습서</a>, AWS 공식 문서를 많이 뒤져보게 되었다. 원래 예전에는 어떤 기술에 대해서 배우려면 구글링부터 시작해 보고는 했는데 결국에는 공식 문서를 보게 되었다. 따라서 정도를 걷기 위해서 처음 시작을 공식문서로 잡고 전체 내용은 천천히 읽었다.<br><img src="/2018/01/30/ausg-seminar/image4.jpg" title="image4"></p><h2 id="세미나-당일"><a href="#세미나-당일" class="headerlink" title="세미나 당일"></a>세미나 당일</h2><p>현업 직장을 대상으로 한 기술 세미나는 처음이어서 많이 떨릴 줄 알았는데 날씨가 워낙 추워서 손이 잠깐 얼었던 것 빼고는 막힘없이 진행했다. <del>(너무 막힘없이 진행해서 사람들이 못 따라오지는 않았을까)</del> 처음에는 초심자를 배려하는 마음에서 조금 느린 템포로 자세하게 진행했으나, 서포팅을 하는 친구에게 다들 잘 따라하고 있다고 빠르게 나가도 되겠다는 피듭백을 들어서 쉬는시간 이후로는 조금 빠르게 진행했다. 원래 2번 챕터는 시간일 많이 걸려서 빼놓고 나중에 진행하던지, 아니면 진행하지 않던지로 생각하고 있었는데 생각보다 잘 따라오셔서 모든 모듈을 마칠 수 있었다. 끝부분은 시간이 모자르지만 욕심이 있어서 다 진행하고 세미나를 끝냈다.<br><img src="/2018/01/30/ausg-seminar/image2.jpg" title="image2"></p><h2 id="후기-amp-회고"><a href="#후기-amp-회고" class="headerlink" title="후기 &amp; 회고"></a>후기 &amp; 회고</h2><p>저번 세미나보다는 분명히 나아진 점이 많았다. 말하는 도중 문득 생각나는 팁들은 모두 쏟아냈고, 생각보다 긴장도 하지 않았다. 조금 독특한 점은, 내가 준비한 세션을 엄청 집중해서 들어주시는 느낌? 이게 사람이 적어서 집중도가, 아니면 유료 세미나인지는 모르겠지만 확실한 건 저번보다 내가 나아졌고 더 긍정적인 피드백을 많이 들었다는 것이다. 저번에 잘 하고, 이번에 잘 하고가 중요한 게 아니라 한번, 그다음으로 여러 번 할 때마다 점점 나아진다는 게 중요한 게 아닐까 :)<br><img src="/2018/01/30/ausg-seminar/party.jpg" title="party"></p><p>MeetUp: <a href="https://www.meetup.com/awskrug/events/246821056/?eventId=246821056" rel="external nofollow noopener noreferrer" target="_blank">AUSG 초보자를 위한 AWS 뿌시기 2회 Meetup</a><br>SlideShare Link: <a href="https://www.slideshare.net/awskr/ausg-aws-2" rel="external nofollow noopener noreferrer" target="_blank">AUSG 초보자를 위한 AWS 뿌시기 세미나 2회 - 팀플 과제를 여행하는 히치하이커를 위한 안내서</a><br>실습서 Github Repo: <a href="https://github.com/awskrug/ausg-seminar-2018/tree/master/teamplay" rel="external nofollow noopener noreferrer" target="_blank">ausg-seminar-2018/teamplay</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/2018/01/30/ausg-seminar/poster2.jpeg&quot; title=&quot;ausg_poster2&quot;&gt;
&lt;h2 id=&quot;개요&quot;&gt;&lt;a href=&quot;#개요&quot; class=&quot;headerlink&quot; title=&quot;개요&quot;&gt;&lt;/a&gt;개요&lt;/h2&gt;&lt;p
      
    
    </summary>
    
      <category term="Conference" scheme="https://philographer.github.io/categories/conference/"/>
    
      <category term="Dev" scheme="https://philographer.github.io/categories/conference/dev/"/>
    
    
  </entry>
  
  <entry>
    <title>제6회 유니톤 네트워킹데이 세미나 스피커 후기</title>
    <link href="https://philographer.github.io/2018/01/21/unithon-seminar/"/>
    <id>https://philographer.github.io/2018/01/21/unithon-seminar/</id>
    <published>2018-01-21T03:57:00.000Z</published>
    <updated>2018-03-08T05:00:57.718Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>매번 블로그에 글을 써야지 써야지. 입으로만 썼는데 생각난 김에 후딱 하나를 적어야 겠다는 생각이 들었다.</p></blockquote><h2 id="작년-2017년"><a href="#작년-2017년" class="headerlink" title="작년 (2017년)"></a>작년 (2017년)</h2><p>아마 작년에는 이맘때쯤에 <a href="http://www.swmaestro.kr/web/web/main.do" rel="external nofollow noopener noreferrer" target="_blank">SW Maestro</a> 과정에 참여하고 있기도 했고, 동시에 Nexters 활동도 마무리하는 시간이어서 무척 바빴던 것으로 기억한다. 그러던 중, 하고 있던 개발에서 잠깐 뛰쳐나와서 다른 토이프로젝트를 진행하면 어떨까 문득 생각이 들었다. 그래서 같은 과정에 있던 <a href="https://www.linkedin.com/in/jspiner/" rel="external nofollow noopener noreferrer" target="_blank">전성민</a>이라는 친구와 제 4회 <a href="https://www.facebook.com/unithonWithU" rel="external nofollow noopener noreferrer" target="_blank">유니톤</a> 에 참여를 하게 되었다.</p><p>그 당시에, <code>돈톡</code> 이라는 <code>node.js, mongoDB, 안드로이드 농협 핀테크 오픈 API, [Dialogflow](https://dialogflow.com/) (당시에는 api.ai)</code>를 가지고 핀테크 챗봇이라는 애플리케이션을 만들었었는데 나름 운이 좋아서 최우수상을 받게 되었다. 2박 3일 동안 개발이라 무척 힘들었던 기억이 새록새록 난다.</p><h2 id="이번-년-2018년"><a href="#이번-년-2018년" class="headerlink" title="이번 년 (2018년)"></a>이번 년 (2018년)</h2><p>이번 년에는 작년과는 다르게, 유니톤에 <a href="https://awskrug.github.io/ausg/" rel="external nofollow noopener noreferrer" target="_blank">AWS 대학생 그룹</a>의 소속으로, 스피커(연사)로 초청받아서 발표를 하게 되었다. <em>분명 작년까지만 해도, 내가 저 자리에 앉아서 다른 사람의 AWS 관련 발표를 들었었는데 내가 저 자리에 서게 된다니 굉장히 감회가 새로웠다.</em> 세미나는 작년에 직장인들을 대상으로 했던 핸즈온 랩 세미나를 조금 업데이트시키고, AWS console이 한글화가 진행되었으므로 한글화를 하고 스크린샷을 새로 찍어서 가독성을 높여서 프로젝트를 만들었다. <a href="https://github.com/awskrug/unithon-serverless-2018" rel="external nofollow noopener noreferrer" target="_blank">GitHub - awskrug/unithon-serverless-2018: 대학생 연합 해커톤 유니톤 2018 serverless 세미나</a></p><p>원래 4시간짜리 과정인데 이걸 압축해서 2시간 만에 하려니 시간도 무척 모자랐기 때문에 끝부분은 거의 진행하지 못 하고 내가 하는 걸 따라보게 했다. <code>핸즈온 랩, 라이브 코딩</code>이란 정말 어려운 것 같다. 연습이 많이 부족하기도 했고 중간중간 프로젝터가 꺼지거나 하는 등 예상치 못한 사고가 있기 때문에 세미나는 어려운 것 같다.</p><p>세미나가 길어지니, 흥미가 떨어져서 따라오지 못 하는 사람들은 뒷자리에서 딴짓을 하는 게 보였다. -(다 흥미 유발을 못 했던 내 잘못인 것 같다.)- <em>다음에는 중간중간 놓치지 않도록 더 흥미를 이끌 수 있고 쉬운 콘텐츠를 준비해야겠다는 반성을 하게 되었다.</em></p><img src="/2018/01/21/unithon-seminar/poster1.jpg" title="unithon_poster1"><img src="/2018/01/21/unithon-seminar/poster2.jpg" title="unithon_poster2"><img src="/2018/01/21/unithon-seminar/pic1.jpg" title="pic1"><img src="/2018/01/21/unithon-seminar/pic2.jpg" title="pic2">]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;매번 블로그에 글을 써야지 써야지. 입으로만 썼는데 생각난 김에 후딱 하나를 적어야 겠다는 생각이 들었다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;작년-2017년&quot;&gt;&lt;a href=&quot;#작년-2017년&quot; class=&quot;h
      
    
    </summary>
    
      <category term="Conference" scheme="https://philographer.github.io/categories/conference/"/>
    
      <category term="Dev" scheme="https://philographer.github.io/categories/conference/dev/"/>
    
    
      <category term="Conference" scheme="https://philographer.github.io/tags/conference/"/>
    
      <category term="Dev" scheme="https://philographer.github.io/tags/dev/"/>
    
  </entry>
  
  <entry>
    <title>PlayNode 2017 행사</title>
    <link href="https://philographer.github.io/2017/11/28/playnode2017/"/>
    <id>https://philographer.github.io/2017/11/28/playnode2017/</id>
    <published>2017-11-28T13:58:23.000Z</published>
    <updated>2018-03-08T05:00:57.711Z</updated>
    
    <content type="html"><![CDATA[<img src="/2017/11/28/playnode2017/playnode.jpg" title="행사사진"><h1 id="171109-Play-Node"><a href="#171109-Play-Node" class="headerlink" title="171109 Play.Node"></a>171109 Play.Node</h1><h2 id="GraphQL-In-Action-REST와-이별할-때-생각해야-하는-것들"><a href="#GraphQL-In-Action-REST와-이별할-때-생각해야-하는-것들" class="headerlink" title="GraphQL In Action: REST와 이별할 때 생각해야 하는 것들"></a>GraphQL In Action: REST와 이별할 때 생각해야 하는 것들</h2><ul><li>고통의 근원: 이게 RESTful한가? 계속 질문하게 됨. Path, method, url 설계 등등….</li><li>특징<ul><li>scheme를 정의하여  validation이 편함</li><li>상속: union, interface keyworld</li><li>recursive query: fragment 사용</li></ul></li></ul><h2 id="Tool"><a href="#Tool" class="headerlink" title="Tool"></a>Tool</h2><ul><li>GUI Client<ul><li><a href="https://insomnia.rest/" rel="external nofollow noopener noreferrer" target="_blank">Insomnia REST Client</a></li><li><a href="https://github.com/graphql/graphiql" rel="external nofollow noopener noreferrer" target="_blank">GitHub - graphql/graphiql</a></li></ul></li><li>BaaS<ul><li><a href="https://www.graph.cool/" rel="external nofollow noopener noreferrer" target="_blank">Graphcool - GraphQL Backend Development Framework</a></li></ul></li><li>구현체<ul><li><a href="https://github.com/apollographql/apollo" rel="external nofollow noopener noreferrer" target="_blank">GitHub - apollographql/apollo</a></li><li><a href="https://github.com/apollographql/apollo" rel="external nofollow noopener noreferrer" target="_blank">GitHub - relay</a></li></ul></li><li>같이쓰면 좋은<ul><li><a href="https://github.com/facebook/dataloader" rel="external nofollow noopener noreferrer" target="_blank">GitHub - facebook/dataloader</a> -&gt; 캐싱</li></ul></li></ul><h2 id="lambda-js와-함께-하는-간단한-API-Server-만들기"><a href="#lambda-js와-함께-하는-간단한-API-Server-만들기" class="headerlink" title="lambda.js와 함께 하는 간단한 API Server 만들기"></a>lambda.js와 함께 하는 간단한 API Server 만들기</h2><ul><li><a href="https://github.com/ramda/ramda" rel="external nofollow noopener noreferrer" target="_blank">GitHub - ramda/ramda: Practical functional Javascript</a></li><li>순수함수<ul><li>side effect가 없는 함수: 외부 변수에의해 조작이 불가능한</li></ul></li><li>일급함수<ul><li>…</li></ul></li><li>함수를 파고들어갈때<ul><li>R.isNil</li><li>R.compose</li><li>R.last</li><li>R.curry</li><li>R.allPass</li></ul></li><li>알면 좋은 것<ul><li><a href="https://github.com/ramda/ramda/wiki/Cookbook" rel="external nofollow noopener noreferrer" target="_blank">Cookbook · ramda/ramda Wiki · GitHub</a></li><li><a href="http://ramdajs.com/repl/" rel="external nofollow noopener noreferrer" target="_blank">Try Lambda</a></li></ul></li></ul><h2 id="Node-js-API-서버-성능-개선기"><a href="#Node-js-API-서버-성능-개선기" class="headerlink" title="Node.js API 서버 성능 개선기"></a>Node.js API 서버 성능 개선기</h2><ul><li>테스트 준비<ul><li>서버 하나의 한계 파악</li><li>병목구간 확인</li><li>코드 개선 후 비교</li></ul></li><li>테스트 툴<ul><li>로컬 성능 확인<ul><li><a href="https://github.com/shoreditch-ops/artillery" rel="external nofollow noopener noreferrer" target="_blank">GitHub - shoreditch-ops/artillery</a></li><li>npm script pre, post keyword</li><li>npx autocannon</li></ul></li><li>서비스<ul><li>Newrelic<ul><li>테스트 시작 끝을 알려고 배포 플래그 api이용함</li></ul></li><li>Nsolid</li><li>RisingStack</li><li>AWS<ul><li>ECS Cluster</li><li>Vagrant로 Virtual Box가 아닌 AWS EC2를 띄움</li><li><a href="https://www.joinc.co.kr/w/Site/Tip/Rsync" rel="external nofollow noopener noreferrer" target="_blank">Rsync</a></li><li>Ansible</li></ul></li></ul></li></ul></li><li><p>성능 개선</p><ul><li>클러스터 인스턴스 변경</li><li>컨테이너 CPU, 메모리 조정</li><li>DB Pool 사이즈 조정</li></ul></li><li><p>v8 major update(node v6 -&gt; node v8)</p><ul><li>turbofan + ignition</li><li>엄청난 성능향상…</li></ul></li><li>node inspect option (프로파일러)<ul><li>chrome devtools 사용가능</li></ul></li><li>v8 tick profiler<ul><li><code>node -prof</code></li><li>summary</li></ul></li><li>Heap Dump -&gt; 메모리 누수 추적<ul><li>크롬 디버거 -&gt; Memory -&gt; Heap Dump</li><li>Heap Dump를 테스트 이전, 테스트 이부</li></ul></li></ul><h2 id="협력적-멀티태스킹"><a href="#협력적-멀티태스킹" class="headerlink" title="협력적 멀티태스킹"></a>협력적 멀티태스킹</h2><ul><li>Async await 잘 써라<ul><li>Promise를 래핑함, 성능은 잘 나오지 않더라도 메모리 관리등…</li></ul></li></ul><h2 id="클라우드-시대의-node-js가-좋은-이유"><a href="#클라우드-시대의-node-js가-좋은-이유" class="headerlink" title="클라우드 시대의 node.js가 좋은 이유"></a>클라우드 시대의 node.js가 좋은 이유</h2><ul><li>vs JAVA: Memory 차지를 많이함 -&gt; 가지고있는 리소스가 적을때.</li><li><a href="https://github.com/fzaninotto/uptime" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/fzaninotto/uptime</a></li><li>ELK Stack</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/2017/11/28/playnode2017/playnode.jpg&quot; title=&quot;행사사진&quot;&gt;
&lt;h1 id=&quot;171109-Play-Node&quot;&gt;&lt;a href=&quot;#171109-Play-Node&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="Conference" scheme="https://philographer.github.io/categories/conference/"/>
    
      <category term="Dev" scheme="https://philographer.github.io/categories/conference/dev/"/>
    
    
  </entry>
  
  <entry>
    <title>휴학 회고 (2016.08-2017.08)</title>
    <link href="https://philographer.github.io/2017/11/12/absence/"/>
    <id>https://philographer.github.io/2017/11/12/absence/</id>
    <published>2017-11-12T03:57:39.000Z</published>
    <updated>2018-03-08T05:00:57.695Z</updated>
    
    <content type="html"><![CDATA[<img src="/2017/11/12/absence/absence.jpg" title="휴학"><h2 id="글을-쓰며"><a href="#글을-쓰며" class="headerlink" title="글을 쓰며"></a>글을 쓰며</h2><p>휴학을 하기 전에 작성했던 글을 다시 되돌아보았다. <strong>어떤 마음가짐으로 휴학을 하게 되었고 다시 복학하기 전까지 나는 무엇이 달라졌을까.</strong> 복학 전 마음이 뒤숭숭한 지금, 일 년 동안 나는 무엇을 했고 어떻게 지내왔는지를 한번 되돌아보는 시간을 가지면 좋겠다는 생각에 글을 쓰려고 키보드를 잡았다. 그런데 일에 치이고, 시간이 없다는 핑계로 “소프트웨어 마에스트로”가 끝나자마자 작성하려고 했으나 밀리고 밀려서 8월 중순이 돼서야 적게 된다. 그래도 지금이라도 적는 게 어디인가. 사실 블로그 아티클은 누군가 보여주려고 쓰는 것이지만, 이 글만은 내가 나중에 일기장에서 꺼내보는 느낌으로 적어본다.</p><h2 id="휴학-전-amp-휴학-후의-심경"><a href="#휴학-전-amp-휴학-후의-심경" class="headerlink" title="휴학 전 &amp; 휴학 후의 심경"></a>휴학 전 &amp; 휴학 후의 심경</h2><ul><li><a href="http://dev-timero.tistory.com/178" rel="external nofollow noopener noreferrer" target="_blank">160923 휴학. - Dev.Timero의 학습일기</a><br>이 글은 물리적 시간의 제약으로 고통받던 내가, 유일하게 잠시 미룰 수 있는 학교를 쉬면서 적은 심경이 담겨있는 글이다. 선택과 집중을 하기 위해 휴학을 선택했었는데 휴학이 끝날 무렵 다시 되돌아보면 그렇게 집중하지도 못했던 것 같다. SubJob과 SW Maestro를 병행하기는 참 어려웠다. 물리적 시간을 나누어 두 가지 일을 동시에 하기란 무척 어려웠다.<br>글을 보면 3000만 원 이상 벌고 그 이상의 경험도 한다고 했는데 그 두 가지 관점에서 봤을 때는 성공적인 휴학이었다. <del>(그런데 왜 내 통장에 3000만 원이 없지?, 반절은 썼구나…)</del></li><li><a href="http://dev-timero.tistory.com/179" rel="external nofollow noopener noreferrer" target="_blank">1년뒤 나의 개발 기술 및 스펙 - Dev.Timero의 학습일기</a><br>C+도하고, 웹 스택에, Ruby에, Python에, Go까지 적혀있다. <del>(난 정말 욕심이 많다)</del>. 결과적으로 말하면 C 계열은 손도 못 대보았고, Go는 SW Maestro 프로젝트에 도입하려다가 Open CV의 커넥터의 퀄리티가 별로여서 실패했다. 하지만 결론적으로 Web Stack은 더욱 견고히 다지게 되었고, Typescript, Angular에 React까지 만져볼 기회가 있었다. Python과 Django 또한 SW Maestro에서 영상처리를 하는데 좋은 경험을 하게 되었다. 그런데 Django 는 손에 안 익어서 별로였다. (<del>너무 무겁다</del>)</li></ul><h2 id="Team-Mondrian-스타트업-근무-2016-08-현재-2017-08-21"><a href="#Team-Mondrian-스타트업-근무-2016-08-현재-2017-08-21" class="headerlink" title="Team Mondrian (스타트업 근무, 2016-08 ~ 현재(2017-08-21))"></a>Team Mondrian (스타트업 근무, 2016-08 ~ 현재(2017-08-21))</h2><p>아마도 1년 동안 가장 많이 노력과 시간을 쏟아부은 일은 스타트업에서 근무한 일 아닐까. <a href="http://teammondrian.com" rel="external nofollow noopener noreferrer" target="_blank">Team Mondrian</a>을 짧게 소개하자면 스타트업 팀이다. 팀이라고 쓴 이유는 말 그대로 프로젝트팀의 느낌이랄까. “기존의 회사에 근무하는 느낌”이라기보다는 “프로젝트를 진행하는 팀원들이 모인 회사 느낌”이다. 원격 근무로 “Slack, Hangout”등으로 회의하며 아이디어 회의 등이나 이슈를 해결하는 자리는 Offline 미팅을 가진다.<br>어쨌든 일 년 동안 가장 성과가 있었고 내가 배운 것도 많은 회사였다. 주로 Javascript를 이용한 Web Backend, Frontend (Web Full Stack)을 다루었다.<br>서울대학교 융합과학기술원 연구 프로젝트 “Being” 과 Inbody사와 Co-work했던 “Inbody-Wear App”을 개발했었는데 Ionic2, React-native, node.Js, express.Js, AWS를 다루었기 때문에 웹, 앱, 서버 모두 넘나들면서 Full Stack을 했었다. 얇고 넓은 지식을 쌓게 되었다. 사실 얇고 넓은 지식에 대해서는 휴학 전에 경계하는 느낌이었다. “모두 알지만 모두 모른다”는 느낌일 수 있겠지만 막상 여러 가지 일을 하면서 Production Level을 찍고, 운영 및 버그 픽스를 해보면서 느껴본 결과는 얇고 넓은 일을 하면 통찰력을 얻을 수 있는 것 같다. 아직도 느끼는 것이지만 <strong>Generalist</strong>로 진로를 잡을 것이냐 <strong>Speciallist</strong> 로 진로를 잡을 것이냐를 결정하는 일은 참 어려운 일이다. 사실 지금 스타트업에서의 경험은 <strong>Generalist</strong>이기도 하고 학생 때의 경험은 <strong>Special</strong>보다 <strong>General</strong>이 더 낫다고 생각한다. <strong>General</strong>이 좀 더 넓은 통찰력을 기를 수 있는데, 이 기회는 지금이 아니면 기르기 힘든 핵심 가치관이기 때문이다.</p><h2 id="Work-amp-Life-Balance"><a href="#Work-amp-Life-Balance" class="headerlink" title="Work &amp; Life Balance"></a>Work &amp; Life Balance</h2><p>스타트업에 근무하면서 얻은 좋은 경험은 Work &amp; Life의 Balance였다. 내가 근무한 스타트업은 한국 회사에서 찾아보기 힘든 “완전한 형태의 원격 근무“의 형태를 띠고 있으며 내가 원한다면 당장 미국으로 떠나서 일해도 괜찮다. 하지만 내가 <a href="http://terms.naver.com/entry.nhn?docId=3580286&amp;cid=59088&amp;categoryId=59096" rel="external nofollow noopener noreferrer" target="_blank">디지털 노마드</a>를 하지 않는 이유는 강원도 여행과 일본 여행 중 디지털 노마드가 된다면 어떤 느낌일까? 라는 생각으로 노트북을 짊어지고 갔으나 결과는 참혹했다. 다른 사람에게는 다를지도 모르겠지만 적어도 나에게는 Work와 Life가 정확히 구분되어야 한다는 것을 느꼈다.</p><h2 id="Nexters-8기-마무리-개발자와-디자이너를-위한-IT-연합동아리-2016-01-2017-03"><a href="#Nexters-8기-마무리-개발자와-디자이너를-위한-IT-연합동아리-2016-01-2017-03" class="headerlink" title="Nexters 8기 마무리(개발자와 디자이너를 위한 IT 연합동아리, 2016-01 ~ 2017-03)"></a>Nexters 8기 마무리(개발자와 디자이너를 위한 IT 연합동아리, 2016-01 ~ 2017-03)</h2><p>이담누나, 현철형, 수민이 + 영수영과 함께 <a href="https://play.google.com/store/apps/details?id=com.ourincheon.wazap&amp;hl=ko" rel="external nofollow noopener noreferrer" target="_blank">Wazap-와서잡아/공모전/팀빌딩</a> 을 런칭하였고, 이담누나, 현철형, 수민이와 함께했던 넥스터즈에서의 2번째 앱 출시인 <a href="https://play.google.com/store/apps/details?id=com.miss_k&amp;hl=ko" rel="external nofollow noopener noreferrer" target="_blank">“미세몬”</a>을 런칭했다. (<del>물론 지금은 AWS 비용상 서버가 내려가있다.</del>). 동아리에서 이런 퀄리티에 앱을 낼 수 있는 사람들이 있다는 점에서 무척 동아리에 고마웠다. 아주 훌륭하고 뛰어난 디자이너&amp;개발자가 많아서 귀감이 되었던 동아리였다. 그뿐만 아니라 <a href="http://teamnexters.com/" rel="external nofollow noopener noreferrer" target="_blank">NEXTERS</a>의 일원으로 제3회 유니톤에서 최우수상도 받게 되었다. 이런 좋은 동아리인 Nexters가 앞으로도 번창해서 많은 개발자와 디자이너에게 귀감이 되었으면 좋겠다.</p><h2 id="SW-Maestro-과학기술-정통부-산하-SW-인재양성-프로그램-2016-06-2017-06"><a href="#SW-Maestro-과학기술-정통부-산하-SW-인재양성-프로그램-2016-06-2017-06" class="headerlink" title="SW Maestro (과학기술 정통부 산하 SW 인재양성 프로그램, 2016-06 ~ 2017-06)"></a>SW Maestro (과학기술 정통부 산하 SW 인재양성 프로그램, 2016-06 ~ 2017-06)</h2><ul><li><p>1차 프로젝트<br>소프트웨어 마에스트로에서 <a href="https://www.openstack.org/" rel="external nofollow noopener noreferrer" target="_blank">OpenStack</a>에 <a href="https://kubernetes.io/" rel="external nofollow noopener noreferrer" target="_blank">Kubernetes</a>관련 Plugin을 개발하는 프로젝트를 진행했었다. (2016-09-01 기준으로 이러한 Feature는 Blueprint에도 없었던 개념이지만 현재는 관련 플러그인이 개발 및 안정화가 되고있는 것으로 보인다.) 생소한 개념인 인프라, 플랫폼 레벨의 OpenStack은 여러 가지 마이크로서비스 아키텍처를 지향하며 세상에서 가장 활발히 성장하고 있는 클라우드 오픈소스이다. 처음 다가갈땐 Network, Infra에 대해서는 무척 생소하였지만 큰 프로젝트를 공개된 소스를 통하여 뜯어보면서 대규모 프로젝트의 구조, Automation에 대하여 배운 프로젝트였다. 여기서 배운 지식이었던 BuildServer의 개념과 Automation은 지금까지도 유용하게 써먹고 있다. </p></li><li><p>2차 프로젝트<br>2차 프로젝트는 짧게 말하면 <strong>“풋살경기 자동 촬영 시스템과 그 영상을 통한 하이라이트 편집”</strong> 이었다. 난생처음으로 H/W와 연계한 프로젝트였고 나는 영상처리와 Server 분야를 맡게 되었다. 쉽게 말하면 공을 따라다니면서 자동으로 풋살경기 영상을 촬영해주고, 그 영상을 서버에 업로드하면 자동으로 하이라이트 부분만 편집하여 알맞은 음악과 트랜지션 효과를 넣어주고 영상을 잘라서 편집해주는 S/W를 개발하였다. 전체적으로는 완성이었지만 세부 트랜지션 효과와 실제 경기 영상을 많이 촬영해 보지 못한 점이 아쉬움으로 남는 프로젝트였다.</p></li></ul><h2 id="경디공-4기-경인지역-경상-amp-디자인-amp-공학-연합-동아리-2017-03-2018-03"><a href="#경디공-4기-경인지역-경상-amp-디자인-amp-공학-연합-동아리-2017-03-2018-03" class="headerlink" title="경디공 4기(경인지역 경상&amp;디자인&amp;공학 연합 동아리, 2017-03 ~ 2018-03)"></a>경디공 4기(경인지역 경상&amp;디자인&amp;공학 연합 동아리, 2017-03 ~ 2018-03)</h2><p>Nexters 활동이 끝나고, 서울로 가기 지친 나에게 <a href="https://www.facebook.com/mdtconv/?fref=ts" rel="external nofollow noopener noreferrer" target="_blank">경디공</a>의 모집글을 학교 게시판에서 보게 되었다. 경디공은 인천에서 활동하는 경상&amp;디자인&amp;공학의 줄임말인 동아리로, 매주 스터디와 반분기 프로젝트를 진행하며 공모전에도 참여하는 경인중심 대학생 연합 동아리이다. 사실 이런 연합동아리들은 서울 중심으로 포진해 있어서 인천에 살고있는 나는 너무나도 왔다갔다 체력을 많이 뺏기기에, 오히려 인천에 있다면 체력소모가 덜하지 않을까 생각하며 동아리에 지원했다. 주로 인하대, 인천대와 서울권 학교, 경기도권 학교에 재학 중인 대학생들이 활동하고 있으면서 다분야 &amp; 다각도에서 보기 좋아하는 나에게 안성맞춤인 동아리였다. 개발자가 아닌 홍보부로 활동하면서 지친 나에게 쉬면서 다 전공의 사람들과 교류하며 시선을 옅볼 수 있는 활동을 진행하고 있다.</p><h2 id="AWSKRUG-Suporters-1기-아마존-웹서비스-유져그룹-서포터즈-2017-07-2018-03"><a href="#AWSKRUG-Suporters-1기-아마존-웹서비스-유져그룹-서포터즈-2017-07-2018-03" class="headerlink" title="AWSKRUG Suporters 1기 (아마존 웹서비스 유져그룹 서포터즈, 2017-07 ~ 2018-03)"></a>AWSKRUG Suporters 1기 (아마존 웹서비스 유져그룹 서포터즈, 2017-07 ~ 2018-03)</h2><p>AWS! 가장 내가 좋아하는 클라우드 서비스를 제공하는 회사이다. 관심 있는 회사에서 관심 있는 활동을 하다니. 너무너무 지원하고 싶었다. AWS내 에반젤리스트, 테크니컬 어시스트님들이 함께 강의해주기 때문에 무척이나 유익해 보인다! 아직 시작한 지 얼마 되지 않아서 프로젝트나 그런 것들에 대해서는 진행사항이 없지만 1기 활동으로서 내년에는 인천지역에서 AWS 관련 모임이나 대학생 할동을 할 수 있을 것으로 생각된다. 열심히 활동하면서 후기들을 써 내려가 보고싶다.</p><h2 id="취미"><a href="#취미" class="headerlink" title="취미"></a>취미</h2><p>라즈베리파이, 라떼판다와 같은 OpenSource H/W 가 요새들어 눈에 보인다.<br>Backend, frontend의 기술을 익히고 보니, 실제로 상품성이나 실용성 있는 아이디어는 결국 H/W가 있어야 한다는 것을 느꼈다. 라즈베리파이로 입문하려고 책과 하드웨어를 10만원 이내로 구입하려고 계획중이다.</p><h2 id="앞으로-하고-싶은-TodoList"><a href="#앞으로-하고-싶은-TodoList" class="headerlink" title="앞으로 하고 싶은 TodoList"></a>앞으로 하고 싶은 TodoList</h2><ul><li>GoLang으로 백엔드 및 시스템레벨 자동화 프로젝트</li><li>Jenkins 도입과 빌드서비스들</li></ul><h2 id="Career-path"><a href="#Career-path" class="headerlink" title="Career path"></a>Career path</h2><ul><li>오픈소스 프로젝트 기여</li><li>알고리즘 풀이</li><li>SW Membership, BOB,  또는 한이음 프로젝트</li></ul><h2 id="마무리하며"><a href="#마무리하며" class="headerlink" title="마무리하며"></a>마무리하며</h2><p>인생의 선택 기준은 지금 할 수 있는일 t1, 나중에라도 할 수 있는 일 t2일때 t1을 선택한다. 그래서 내가 지금 <strong>“돈되지 않는 일”</strong>과 <strong>“오로지 학생때만 할 수 있는 일”</strong>을 좋아하는 것 같다. 앞으로의 선택 기준과 인생의 가치관인 <strong>“학생으로서의 Generalist”</strong> 를 유지하면서 <strong>앞으로는 무엇을 하는게 Best인가?</strong>를 항상 고민하며 학생 생활을 마무리해야겠다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/2017/11/12/absence/absence.jpg&quot; title=&quot;휴학&quot;&gt;
&lt;h2 id=&quot;글을-쓰며&quot;&gt;&lt;a href=&quot;#글을-쓰며&quot; class=&quot;headerlink&quot; title=&quot;글을 쓰며&quot;&gt;&lt;/a&gt;글을 쓰며&lt;/h2&gt;&lt;p&gt;휴학을
      
    
    </summary>
    
      <category term="Retrospect" scheme="https://philographer.github.io/categories/retrospect/"/>
    
      <category term="Personal" scheme="https://philographer.github.io/categories/retrospect/personal/"/>
    
    
  </entry>
  
  <entry>
    <title>Github Webhook</title>
    <link href="https://philographer.github.io/2017/02/16/webhook/"/>
    <id>https://philographer.github.io/2017/02/16/webhook/</id>
    <published>2017-02-15T20:29:14.000Z</published>
    <updated>2018-03-08T05:00:57.724Z</updated>
    
    <content type="html"><![CDATA[<h1 id="개요"><a href="#개요" class="headerlink" title="개요"></a>개요</h1><p>프로젝트를 진행하면서 빠르게 <code>api</code> 서버를 배포해야 할 일들이 많다.<br>예를 들자면 해커톤에 참여할 때라던지, 당장 나의 <code>api</code>를 클라이언트 프로그래머가 사용해야 할 경우가 종종 있다.<br>API 서버를 테스트로 배포할 때는 주로 다음의 과정을 거친다.</p><ol><li>localhost에서 작업을 하고 Postman를 테스트를 거친다</li><li>Github Repository에 Push한다</li><li>현재 돌고있는 코드를 stop 한다.</li><li>서버(AWS, 물리)에 접속하여 Git pull을 받는다.</li><li>다시 코드를 start 한다.</li></ol><p>상당히 번거로운 작업이 아닐 수 없다. 그래서 나는 이런 경우 주로  <code>ec2</code>에 git을 설치하고, 서버에 직접 repository를 만든 다음 ec2의 repo push하면 post receive hook을 사용하여 빠른 배포를 진행했다. 다음의 링크와 같은 방법이다. <a href="http://cuppster.com/2011/05/12/diy-node-js-server-on-amazon-ec2/" rel="external nofollow noopener noreferrer" target="_blank">DIY node.js server on Amazon EC2</a></p><p>하지만 이런 방법에는 큰 단점이 있다. 바로 server에 git을 직접 bare로 설치하는 방법이기 때문에 나중에 github으로 프로젝트를 관리하기 어려워진다는 점이다. 최근 AWS직원분들과 이야기를 나눌 기회가 있었는데  <code>Github Webhook</code>에 대해서 말씀해 주셔서 알아보게 되었다.</p><p>여담으로, 처음에 “어떻게 빠른 배포를 진행할까?”에 대해서 생각하면서 <code>Jenkins</code>, <code>Travis</code>같은 빌드툴을 이용하고 그 다음 자동 배포 로직을 돌리면 어떨까 생각했는데 생각보다 빌드툴을 셋팅하기도 오래 걸렸기 때문에 간단한 테스트에는 적합하지 않았다.  <code>AWS Code Deploy</code>에서 테스트 프로젝트를 돌려보니 <code>Blue Green</code> 배포 방식이고 router를 재연결하는 방식이기 때문에 코드가 빨리 배포되지는 않아서 매우 짜증이 났다.<br>그래서 결국에 제일 간단한 방법인 <code>Github Webhook</code>을 선택하였다.</p><p><br></p><h1 id="Webhook-이란"><a href="#Webhook-이란" class="headerlink" title="Webhook 이란?"></a>Webhook 이란?</h1><p><br><br><img src="/2017/02/16/webhook/arrhook.gif" title="Web Hook"><br><code>Webhook</code>에 대해 알아보기 전에 우선 <code>hook</code>이 무엇인지 알아보자면,<br><code>hook</code>이란 각종 소프트웨어 구성요소 간에 발생하는 함수 호출, 메시지, 이벤트를 중간에서 가로채는 행위를 말한다.<br><code>Webhook</code>은 <a href="https://developer.github.com/webhooks/" rel="external nofollow noopener noreferrer" target="_blank">Webhooks | GitHub Developer Guide</a>에 매우 잘 나와 있고, 링크를 요약하자면 git repository에 이벤트가 발생했을 때 이를 미리 설정한 URL에 HTTP POST  Method로 보내주는 것을 말한다. 주로 이슈 트래커, CI Build, Update Backup Mirror, deploy에서 사용한다고 한다. 이 글에서는 <code>deploy</code>관점에서 <code>webhook</code>을 적용한다.<br><br></p><h1 id="Prerequisite"><a href="#Prerequisite" class="headerlink" title="Prerequisite"></a>Prerequisite</h1><ol><li>Apt-get upgrade</li><li>Apt-get update</li><li>Install Node.js <a href="https://nodejs.org/ko/download/package-manager/#debian-ubuntu-linux" rel="external nofollow noopener noreferrer" target="_blank">Debian-ubuntu-Node.js | Node.js</a></li><li>Install Pm2 <a href="https://github.com/Unitech/pm2" rel="external nofollow noopener noreferrer" target="_blank">pm2: Production process manager for Node.js</a></li><li>Install Nginx <a href="https://www.digitalocean.com/community/tutorials/how-to-install-nginx-on-ubuntu-16-04" rel="external nofollow noopener noreferrer" target="_blank">How To Install Nginx on Ubuntu 16.04 | DigitalOcean</a> or <a href="https://www.nginx.com/resources/wiki/start/topics/tutorials/install/#official-debian-ubuntu-packages" rel="external nofollow noopener noreferrer" target="_blank">Nginx Install</a><br><br></li></ol><h1 id="1-Ssh-key-Setting-On-Server"><a href="#1-Ssh-key-Setting-On-Server" class="headerlink" title="1. Ssh key Setting (On Server)"></a>1. Ssh key Setting (On Server)</h1><ol><li>서버에서 <a href="https://help.github.com/articles/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent/#generating-a-new-ssh-key" rel="external nofollow noopener noreferrer" target="_blank">Generating a new SSH key and adding it to the ssh-agent</a>를 참조하여 ssh 키를 만든다.</li><li>다음링크에서 만들었던 서버의 공개 키를 등록한다. (기본값으로 설정했다면 vi ~/.ssh/id_rsa.pub 에서 볼 수 있다.) <a href="https://github.com/settings/ssh" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/settings/ssh</a></li><li>공개키(id_rsa.pub)에 있는 내용을 서버의 ~/.ssh/authorized_keys 파일의 끝에 copy and paste한다.<br><br></li></ol><h1 id="2-Github-Repository-Setting"><a href="#2-Github-Repository-Setting" class="headerlink" title="2. Github Repository Setting"></a>2. Github Repository Setting</h1><p><br><br><img src="/2017/02/16/webhook/setting.png" title="Github Setting"><br>우선 Github의 Repository에서 Settings 탭을 보면 Add Webhook 버튼이 있다.<br>친절히 <a href="https://developer.github.com/webhooks/" rel="external nofollow noopener noreferrer" target="_blank">가이드</a>도 적혀있으니 시간이 있다면 참조해보자.<br><br></p><h1 id="3-Secret-Setting"><a href="#3-Secret-Setting" class="headerlink" title="3. Secret Setting"></a>3. Secret Setting</h1><p><br><br>Add Webhook을 누르면 다음과 같은 화면을 볼 수 있다.<br><img src="/2017/02/16/webhook/webhook.png" title="Secret Setting"></p><ol><li>Payload URL에는 원하는 도메인의 Post Request가 날아갈 EndPoint를 적어준다. 내 경우는 추후에 NGINX Proxy를 이용해서 /hook 로 날린 요청을 받기 때문에 저렇게 설정했다.</li><li>Content type은 json이나 form을 선택할 수 있다. 필자는 node에서 json으로 처리하는게 편하기 때문에 json을 선택했다.</li><li>Secret은 보안상 필요한 부분이다. 생략해도 되지만 설정하기를 권장한다. 자신이 원하는 값을 적으면 된다.</li></ol><p>Secret을 생략할 수 있지만 사실 매우 중요한 부분이다. SECRET을 설정하지 않는다면 서버에서는 어떤 Post Request에도 Shell Script나 커맨드 또는 Logic을 무조건 실행하므로 보안상 배우 취약할 수 있다.<br><br></p><h1 id="4-NGINX-Setting"><a href="#4-NGINX-Setting" class="headerlink" title="4. NGINX Setting"></a>4. NGINX Setting</h1><p>Nginx 설정을 진행한다.<br><code>$ vi /etc/nginx/sites-available/default</code></p><script src="https://gist.github.com/yoohoogun114/17fcf2aadc048447544e84a200f9b1bf.js"></script><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location /hook &#123; <span class="comment">// 이 부분이 포인트</span></span><br><span class="line">                proxy_pass http:<span class="comment">//127.0.0.1:3100/; //3100 포트로 proxy</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>설정 파일을 잠깐 살펴보면 /hook 으로 endpoint에 접속하면 3100번 포트로 proxy한다.<br><br></p><h1 id="5-Hook-Script"><a href="#5-Hook-Script" class="headerlink" title="5. Hook Script"></a>5. Hook Script</h1><p>Github에 Push되었을 때 실행될 스크립트를 작성한다<br><code>$ mkdir ~/hook</code><br><code>$ vi ~/hook/hook.sh</code></p><script src="https://gist.github.com/yoohoogun114/f20e95eb38c7ab4f7982037d5deef84c.js"></script><ol><li>futsal-node라고 적혀진 부분을 자신의 node server 디렉토리로 바꾼다.</li><li>futsal이라고 적혀진 부분을 추후 pm2 에서 실행할 이름으로 미리 정해둔다.</li></ol><p>코드를 설명하자면 Github Repository에 코드가 Push되었을때, 서버 디렉토리로 이동 후 Code를  Pull 받은 다음  pm2로 실행중인 기존의 서버를 재시작한다는 내용이다.</p><p>그 다음으로 Hook 폴더 내에서  <code>$ npm init</code>을 한 후, start script를 작성한다. 추후에 pm2에 의해 nom start script가 실행된다.<br><code>$ vi ~/hook/package.json</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"hook"</span>,</span><br><span class="line">  <span class="string">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">  <span class="string">"description"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="string">"main"</span>: <span class="string">"hook.js"</span>,</span><br><span class="line">  <span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"test"</span>: <span class="string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span>,</span><br><span class="line">    <span class="string">"start"</span>: <span class="string">"nodejs ./hook.js"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"author"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="string">"license"</span>: <span class="string">"ISC"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br></p><h1 id="6-Node-js-Server-Script"><a href="#6-Node-js-Server-Script" class="headerlink" title="6. Node.js Server Script"></a>6. Node.js Server Script</h1><p>Github에 Push 되었을때 이를 인지할 수 있는 작은 서버스크립트가 필요하다.<br><code>$ vi ~/hook/hook.js</code></p><script src="https://gist.github.com/yoohoogun114/a0730fa7f706391ba6dbadda70f302c1.js"></script><p>코드를 설명하자면 Post Request가 왔을 때 클라이언트가 헤더에 x-hub-signature 값을 보내주는데, 이 값을 Server가 가지고 있는 토큰을 기반으로 Body를 암호화한 값과 같은지 보고 맞다면 아까 만들어둔 hook.sh를 실행한다는 내용이다.</p><p>여기서 중요한 점은 보안상의 이유로 위에서 진행했던 Secret Setting에 설정했던 키와 똑같은 키를 하드코딩된 변수가 아닌 환경변수(process.env[‘SCRET_TOKEN’]) 에서 불러와서 쓴다는 점이다.</p><p>SCRET_TOKEN 환경변수는 다음과 같이 설정한다.<br><code>$ echo export SECRET_TOKEN=아까설정했던Secret &gt;&gt; ~/.bash_profile</code><br><br></p><h1 id="7-Pm2-Setting"><a href="#7-Pm2-Setting" class="headerlink" title="7. Pm2 Setting"></a>7. Pm2 Setting</h1><p><code>$ pm2 start npm --name=&quot;hook&quot; -- start</code><br>이제 Background에서 Node.js 서버가 돌고있으면서 Post Request가 오기를 기다리고 있다.</p><p>Github Repo에 Push를 하면 Github이 우리 서버 URL(~~~/hook) 로 Post Request를 날리고, Nginx에서 이것을 3100 port로 proxy한다. 그러면 우리의 hook.js 서버에 도달하고 만약 SECRET이 일치한다면 hook.sh를 실행하고 불일치하면 실행하지 않는다.</p><ul><li>npm start 커맨드를  pm2에서는 다음과 같이 실행한다.<ul><li>pm2 start npm —name “{app_name}” — run {script_name}</li><li>(run is optional)<br><br></li></ul></li></ul><h1 id="마치면서"><a href="#마치면서" class="headerlink" title="마치면서"></a>마치면서</h1><p>빠르게 배포하기 위해서 Github Webhook에 대해서 알아봤다. Bash Script, SSH, PM2, Node.js 에 대해서 미리 어느 정도 알고 있다면 그렇게 어렵지는 않을 것이다. 까먹지 않고 있으면 빠른 배포가 필요한 상황에서 매우 유용할 것 같다.<br><br></p><h1 id="참고자료"><a href="#참고자료" class="headerlink" title="참고자료"></a>참고자료</h1><ol><li><a href="https://gist.github.com/oodavid/1809044" rel="external nofollow noopener noreferrer" target="_blank">Deploy your site with git · GitHub</a> </li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;개요&quot;&gt;&lt;a href=&quot;#개요&quot; class=&quot;headerlink&quot; title=&quot;개요&quot;&gt;&lt;/a&gt;개요&lt;/h1&gt;&lt;p&gt;프로젝트를 진행하면서 빠르게 &lt;code&gt;api&lt;/code&gt; 서버를 배포해야 할 일들이 많다.&lt;br&gt;예를 들자면 해커톤에 참여할
      
    
    </summary>
    
      <category term="DevOps" scheme="https://philographer.github.io/categories/devops/"/>
    
    
      <category term="vcs" scheme="https://philographer.github.io/tags/vcs/"/>
    
  </entry>
  
  <entry>
    <title>4회 Unithon 후기</title>
    <link href="https://philographer.github.io/2017/02/07/4th-unithon/"/>
    <id>https://philographer.github.io/2017/02/07/4th-unithon/</id>
    <published>2017-02-07T05:07:49.000Z</published>
    <updated>2018-03-08T05:00:57.635Z</updated>
    
    <content type="html"><![CDATA[<h1 id="개요"><a href="#개요" class="headerlink" title="개요"></a>개요</h1><p>어떠한 활동이던, 경험은 해놓았지만 적어놓지 않으면 서서히 기억 속에서 사라져 버린다. 프로그래밍에 대해서 경험한 것은 블로그에 쓰면 나중에 다시 뒤돌아볼 때 좋은 동기부여가 되지 않을까 싶어서 ‘후기를 적어보자!’ 라는 생각이 들어서 포스팅을 적게 되었다.</p><h1 id="Unithon-유니톤-이란"><a href="#Unithon-유니톤-이란" class="headerlink" title="Unithon(유니톤) 이란?"></a>Unithon(유니톤) 이란?</h1><img src="/2017/02/07/4th-unithon/unithon.jpeg" title="유니톤 포스터"><p>유니톤은 Nexters, REAL, YAPP, insiders등 4개의 대학생 IT 연합동아리가 중심이 되어 기획하고 주관하는 해커톤이다. 외부 인원에 대해서는 소속이있거나, 팀을 미리 이룬 팀만 참가가 가능하다.</p><h1 id="1일차"><a href="#1일차" class="headerlink" title="1일차"></a>1일차</h1><p>나는 Nexters의 소속으로 해커톤에 참가했는데, 우연히도 현재 Software Maestro 7기 과정에서 같이 아는 동생과 만나게 되었다. 사실 Software Maestro도 적지 않은 인원이 연수를 받는 터라, 그 동생과는 안면만 있는 정도라 해커톤에서 거의 처음 본 사이였지만 팀에 무언가 연이 있는 사람이 있다는 생각에 빠르게 친해지는 데 큰 도움이 되었다.</p><p>팀이 구성되고 서버 개발자 2, 안드로이드 개발자 2, 디자이너 1, 기획자 1로 포지션을 나누었다. 아이디어를 선정하는 과정은 브레인스토밍을 통해 아이디어의 목록을 만들고, 각 아이디어에 점수를 부여하여 투표하는 과정을 거쳤다.</p><img src="/2017/02/07/4th-unithon/idea.png" title="아이디어 투표"><p>최종적으로 나온 아이디어는 핀테크 챗봇이었다. 주제가 나오고 나서, 모두가 아이디어에 살을 붙이기 시작했다. 생활 밀착형 핀테크 챗봇을 만들기로 했다.</p><p>꽤 아이디어를 모으는 과정과 아이디어가 선정되기까지의 과정이 빠르게 진행되었다. 사실 처음 만난 사이라 서먹하기는 했지만, 해커톤은 ‘속도전’이다. 해커톤에서 아이디어가 매우 빨리 결정 된 것은 크나큰 장점이었다.</p><h1 id="프로젝트-컨셉"><a href="#프로젝트-컨셉" class="headerlink" title="프로젝트 컨셉"></a>프로젝트 컨셉</h1><ol><li>대학생의 공과금은 절대 자동이체를 안 한다 =&gt; 알림을 준다</li><li>작은 돈 받기 힘들다. 최대한 정중히 이메일은 보내준다. (일수)</li><li>캐릭터화 되어있는 돈(봇)이 말을 한다. (심사임당: 50,000원 임당, 다보탑: 나는 바보인가보다보탑, 세종대왕: 얼른 돈을 보내야 하느니라. 등등) </li></ol><p>협업 툴로는 단순히 Trello를 사용하기로 하였고 버전 관리는 Github으로 만들기로 하였다.<br><img src="/2017/02/07/4th-unithon/trello1.png" title="Trello의 흔적1"></p><img src="/2017/02/07/4th-unithon/trello2.png" title="Trello의 흔적2"><p>빠르게 Github organization을 만들고 초대를 돌렸다. 그 후 Server와 Android 프로젝트 Repository를 만들고 개발을 진행하였다. 첫날은 대부분 프로젝트 셋팅이 대부분이어서 개발환경만 마련하고 집으로 돌아갔다. 나는 집이 멀기에 소프트웨어 마에스트로 센터에서 하루 자기로 하였다. 센터에 돌아와서 간단히 로그인, 회원가입, 이메일 전송까지 완성하고 잠들었다. 3시즈음 잠든 것 같다.</p><h1 id="2일차"><a href="#2일차" class="headerlink" title="2일차"></a>2일차</h1><p>아침에 꽤 일찍(8시?) 쯤 일어나서 센터에서 샤워한 후 정신을 가다듬고 선정릉역 디캠프로 걸어갔다. 아침에 갑자기 배가 고파서 국밥을 하나 사 먹고 가려다가 간단히 편의점에서 김밥을 하나 사서 해커톤 장소에 도착했다. Naver API를 사용해서 Oauth2.0 로그인을 하는 부분을 작업했다. 또한 빚에 대해서 독촉하는 이메일 기능도 작업하였다. <br><br>같이 작업하는 친구가 Node, Typescript, Mongo 에 대해서 작업에 익숙하지 않은 터라 조금씩 알려주면서 진행했는데 워낙 베이스가 튼튼한 친구라 간단히 알려줘도 잘 응용했다. <br><br>주로 2일차에 인증, API Endpoint 구조를 나누고 API 문서를 작성하는데에 시간을 썼다.<br><a href="https://docs.google.com/spreadsheets/d/18Tm5INdGUnsjgFw3ARQ2bbZm9RElfN09UL82Rx3NPcQ/edit?usp=sharing" rel="external nofollow noopener noreferrer" target="_blank">UNITHON Hack API v0.1 - Google 스프레드시트</a></p><h1 id="3일차"><a href="#3일차" class="headerlink" title="3일차"></a>3일차</h1><p>3일차는 안드로이드와 API를 연결하고, 챗봇의 정확성을 높이기 위해 전처리, 후처리하는 과정과 최적화에 힘을 쏟았다. 아침이 되니 체력이 방전돼서 한 1-2시간 즈음 엎드려서 잠든 것 같다. 기획자님이 결과물을 잘 포장해서 발표해 주셨는데 너무 잘 발표하셔서 딱 듣자마자 ‘아! 수상권이다.’라는 생각이 들었다. 발표 후 심사위원님들이 돌아다니시며 시연을 보여드리고 수상이 진행되었다.<br><img src="/2017/02/07/4th-unithon/result.png" title="결과물"></p><h1 id="결과"><a href="#결과" class="headerlink" title="결과"></a>결과</h1><img src="/2017/02/07/4th-unithon/prize.jpg" title="수상"><p>사실 결과물에 비해 상이 너무 과분해서 다른 팀들에게 죄송했다.</p><p><br><br>수상에 대해서 왜 수상했는지를 생각해보았다.</p><ol><li>기획자님이 발표를 매우 매우 잘해주셨다.</li><li>챗봇을 짧은 기간에 만들었다 (api.ai를 사용해서 빠른 자연어처리)</li><li>상황에 맞는 최적화를 잘 진행했다. (시연 때 미리 정확한 채팅과 API를 뽑아놓았다.)</li><li>기획 -&gt; 디자인 -&gt; 결과물을 뽑아내는 속도와 주기가 매우 빨랐다.</li><li>시연 때 심사위원의 입맛에 맞추어 잘 진행했다.</li><li>기획이 매우 좋았다.(생활 밀착형 핀테크)</li></ol><h1 id="마치면서"><a href="#마치면서" class="headerlink" title="마치면서"></a>마치면서</h1><p>작년 해커톤보다 개인적으로 꽤 많이 성장했다고 느꼈다. 작년까지는 그냥 어느정도 Web Frontend에 대해서 이해한 채로 해커톤에 나가서 어려운 점이 많았었는데 이제는 Server파트도 어느정도 이해하고 있으니 구현의 속도가 매우 빨라졌다는 것을 느꼈다. 이제는 일 년에 해커톤을 한두 번 정도 나가서 이전 해커톤의 나에 비해서 얼마나 성장했는가 느껴보는 기회를 매년 가져야겠다는 생각이 들었다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;개요&quot;&gt;&lt;a href=&quot;#개요&quot; class=&quot;headerlink&quot; title=&quot;개요&quot;&gt;&lt;/a&gt;개요&lt;/h1&gt;&lt;p&gt;어떠한 활동이던, 경험은 해놓았지만 적어놓지 않으면 서서히 기억 속에서 사라져 버린다. 프로그래밍에 대해서 경험한 것은 블로그
      
    
    </summary>
    
      <category term="Retrospect" scheme="https://philographer.github.io/categories/retrospect/"/>
    
      <category term="Competition" scheme="https://philographer.github.io/categories/retrospect/competition/"/>
    
    
      <category term="retrospect" scheme="https://philographer.github.io/tags/retrospect/"/>
    
  </entry>
  
  <entry>
    <title>travis-ci</title>
    <link href="https://philographer.github.io/2017/02/02/Travis-CI/"/>
    <id>https://philographer.github.io/2017/02/02/Travis-CI/</id>
    <published>2017-02-01T16:10:36.000Z</published>
    <updated>2018-03-08T05:00:57.690Z</updated>
    
    <content type="html"><![CDATA[<h1 id="들어가면서"><a href="#들어가면서" class="headerlink" title="들어가면서"></a>들어가면서</h1><p>사실 CI Tool은 그동안 쓸 일이 많지 않았다. 그마저도 직접 쓴 적은 없고, Openstack 관련해서 Software maestro에서 1차 팀 프로젝트를 진행할 때 옆에서 팀원이 Jenkins를 사용하는 것을 본 것이 전부이다. 현재 맡은 업무가 프론트쪽에 가까워서 시스템 쪽으로 따로 공부할 일도 없지만, 오픈소스 프로젝트들을 보면 무조건 CI를 사용하고 있고, Test coverage system 또한 갖추어 놓았다. 어차피 이번 해커톤에 나가서 Auto Deployment 때문에라도 공부할 거 빨리 공부하는 게 좋다고 생각해서 포스팅을 작성한다.</p><h1 id="CI-란"><a href="#CI-란" class="headerlink" title="CI 란?"></a>CI 란?</h1><img src="/2017/02/02/Travis-CI/ci.jpg" title="CI"><p>우선 CI란 Continuos Intergration의 줄임말이다.</p><h1 id="Travis-란"><a href="#Travis-란" class="headerlink" title="Travis 란?"></a>Travis 란?</h1><img src="/2017/02/02/Travis-CI/travisLogo.jpg" title="CI"><h2 id="Getting-started"><a href="#Getting-started" class="headerlink" title="Getting started"></a>Getting started</h2><p>모든 개발 Document에는 Getting started가 있다. 천천히 따라해보자.<br> <a href="https://docs.travis-ci.com/user/getting-started/" rel="external nofollow noopener noreferrer" target="_blank">Travis CI Getting started</a><br>문서를 읽다 보니 링크를 하나 더 발견했다. <a href="https://docs.travis-ci.com/user/for-beginners" rel="external nofollow noopener noreferrer" target="_blank">Travis CI for Complete Beginners</a> <del>완전 초보자를 위한 문서</del><br>위 문서를 번역하면 다음과 같다.</p><ol><li>Test용 PHP Repository 를 Folk한다</li><li><a href="https://travis-ci.org/auth" rel="external nofollow noopener noreferrer" target="_blank">https://travis-ci.org/auth</a>에서 github계정으로 회원가입을 하고 Travis에게 권한을 준다.</li><li><a href="https://travis-ci.org/profile" rel="external nofollow noopener noreferrer" target="_blank">https://travis-ci.org/profile/yoohoogun114</a>에서 아까 folk한 repo를 선택한다.</li><li>자신이 Folk한 Repo를 clone한다. ($ git clone 자신의리포주소)</li><li>Clone한 폴더에서 <code>vi .travis.yml</code>  로 <code>.travis.yml</code> 파일의 내용을 본다.<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">language:</span> <span class="string">php</span></span><br><span class="line"><span class="attr">php:</span></span><br><span class="line"><span class="bullet">-</span> <span class="number">5.5</span></span><br><span class="line"><span class="bullet">-</span> <span class="number">5.4</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">hhvm</span></span><br><span class="line"><span class="attr">script:</span> <span class="string">phpunit</span> <span class="string">Test.php</span></span><br></pre></td></tr></table></figure></li></ol><p>PHP 5.5버전, 5.4버전, <a href="http://hhvm.com/" rel="external nofollow noopener noreferrer" target="_blank">HHVM</a>(테스트 오픈소스) 이 적혀있고, 마지막 라인에는 Unit Test 파일이 적혀있다.<br><br></p><p><code>vi NewUser.txt</code> 라는 명령어로 텍스트 파일을 만들고 자신의 이름을 적은 후 저장한다.</p><p>그다음으로 다음 명령어를 실행하여 커밋하고, 푸시한다.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git add -A</span><br><span class="line">$ git commit -m <span class="string">'Testing Travis CI'</span></span><br><span class="line">$ git push</span><br></pre></td></tr></table></figure></p><p><a href="https://travis-ci.org/" rel="external nofollow noopener noreferrer" target="_blank">build status</a> 그러면 여기서 빌드 상태를 볼 수 있고, 빌드가 완료(성공, 실패)하면 메일이 날아간다.</p><img src="/2017/02/02/Travis-CI/travis1.png" title="실패한 빌드"><p>처음 빌드는 무조건 실패한다.</p><p>왜냐하면, 테스트 코드가 무조건 실패하도록 적혀있기 때문이다. <del>우리에게 시작하자마자 실패를 안겨주는 Travis 팀</del></p><p><code>vi Test.php</code> 로 테스트 코드를 수정해보자. 테스트 라인을 <code>$this-&gt;assertEquals(1+1,2);</code>  이렇게 고치면 된다. 아래는 완성된 코드</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">PHPUnit_Framework_TestCase</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">testOnePlusOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">$this</span>-&gt;assertEquals(<span class="number">1</span>+<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>assertEquals, $this 이런 문법은 php 문법이기에, 이 포스팅에서는 중요하지 않다. 단지 ‘php에서는 저렇게 테스트코드를 작성하는구나!’ 라는 정도로 넘어가면 된다.</p><p>똑똑한 우리는 무조건 성공하는 테스트 코드를 작성하였다. 다시 commit을하자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git add -A</span><br><span class="line">$ git commit -m <span class="string">'Testing Travis CI: fixing the build'</span></span><br><span class="line">$ git push</span><br></pre></td></tr></table></figure><p><a href="https://travis-ci.org/" rel="external nofollow noopener noreferrer" target="_blank">build status</a> 다시 빌드 상태를 보면 다음과 같이 성공한다. <del>우리는 반드시 이긴다.</del></p><img src="/2017/02/02/Travis-CI/travis2.png" title="성공한 빌드"><h1 id="마치면서"><a href="#마치면서" class="headerlink" title="마치면서"></a>마치면서</h1><p>우리는 CI가 무엇인지, Travis가 무엇인지, Travis가 우리에게 무엇을 해줄 수 있는지 알아보았다. 이제는 자신이 필요한 언어로, Travis를 어떻게 상용하는지 알아보자.<br>글쓴이는 주력 언어가 Javascript이므로 <a href="https://docs.travis-ci.com/user/languages/javascript-with-nodejs/" rel="external nofollow noopener noreferrer" target="_blank">Javascript-Travis</a>를 참조하도록 하겠다. 다음 포스팅은 Javascript Travis로 이어진다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;들어가면서&quot;&gt;&lt;a href=&quot;#들어가면서&quot; class=&quot;headerlink&quot; title=&quot;들어가면서&quot;&gt;&lt;/a&gt;들어가면서&lt;/h1&gt;&lt;p&gt;사실 CI Tool은 그동안 쓸 일이 많지 않았다. 그마저도 직접 쓴 적은 없고, Openstack 관련
      
    
    </summary>
    
      <category term="DevOps" scheme="https://philographer.github.io/categories/devops/"/>
    
    
      <category term="devops" scheme="https://philographer.github.io/tags/devops/"/>
    
  </entry>
  
  <entry>
    <title>Node, Express, Typescript, Mongo project boilerplate</title>
    <link href="https://philographer.github.io/2017/01/30/Node-Express-Typescript-Mongo-project-boilerplate/"/>
    <id>https://philographer.github.io/2017/01/30/Node-Express-Typescript-Mongo-project-boilerplate/</id>
    <published>2017-01-30T14:31:17.000Z</published>
    <updated>2018-03-08T05:00:57.682Z</updated>
    
    <content type="html"><![CDATA[<h1 id="개요"><a href="#개요" class="headerlink" title="개요"></a>개요</h1><p>작년 제2회 유니톤(대학생 연합 해커톤)에 나가면서, 절실히 느꼈던 것은 미리 준비해 갈 수 있는 것들에 대해서 준비하지 않아서 애를 많이 먹었다. 예를 들어 프로젝트의 boilerplate, 프로젝트 디렉토리 설정, linter설정, db connect, server config, aws설정을 미리 해갈 수 있었다면 좀 더 빨리 기능구현을 할 수 있지 않을까 생각했다.<br><br></p><h1 id="Boilerplate란"><a href="#Boilerplate란" class="headerlink" title="Boilerplate란?"></a>Boilerplate란?</h1><img src="/2017/01/30/Node-Express-Typescript-Mongo-project-boilerplate/boilerplate.jpg" title="Boilerplate"><p><br><br><a href="http://whatis.techtarget.com/definition/boilerplate" rel="external nofollow noopener noreferrer" target="_blank">Boilerplate</a>는 변경 없이 재 사용할 수 있는 물품을 말한다. 이 용어는 철강쪽에서 유래된 단어로, 보일러 플레이트는 증기 보일러 내에 사용되는 커다란 압연 강판을 말한다. 이처럼, 오랜 기간동안 사용되었으며 튼튼하거나 반복적으로 재사용하기 충분한 정도로 만들어진 물품을 말한다. </p><u>소프트웨어에서는, 일종의 기본설정이 되어있고 디렉토리설정이 되어있는 재사용 가능한 템플릿 이라고 볼 수 있다.</u><p>가장 유명한 boilerplate는 아마도 <a href="https://html5boilerplate.com/" rel="external nofollow noopener noreferrer" target="_blank">HTML5 Boilerplate: The web’s most popular front-end template</a>가 아닐까.<br><br></p><h1 id="Node-js란"><a href="#Node-js란" class="headerlink" title="Node.js란?"></a>Node.js란?</h1><img src="/2017/01/30/Node-Express-Typescript-Mongo-project-boilerplate/node.png" title="Node.js"><p><br><br><a href="https://nodejs.org/kr" rel="external nofollow noopener noreferrer" target="_blank">Node.js</a>는 <a href="https://developers.google.com/v8/" rel="external nofollow noopener noreferrer" target="_blank">크롬 V8 Javascript Engine</a>위에서 동작하는 <a href="http://stackoverflow.com/questions/30838412/what-is-javascript-runtime" rel="external nofollow noopener noreferrer" target="_blank">Javascript runtime</a>이고  <a href="http://jasonim.me/dev/146" rel="external nofollow noopener noreferrer" target="_blank">이벤트-드리븐 방식</a>, <a href="http://ozt88.tistory.com/20" rel="external nofollow noopener noreferrer" target="_blank">non-blocking I/O</a>를 사용하므로 가볍고 효율적이다. node의 생태계중 하나인 <a href="https://www.npmjs.com/" rel="external nofollow noopener noreferrer" target="_blank">NPM</a>은 세계에서 가장 큰 오픈소스 생태계 중 하나이다.</p><u>무슨 소리인지 하나도 모르겠다. 라고 생각하는 독자가 있다면 단어 하나하나에 걸려있는 링크를 참조하며 이해하도록 하자. 개발자가 되려면 모르는 것을 검색하고 스스로 학습하는 습관을 들여야 한다.</u><p>Node에 대한 기본 지식이 없다면 간단히 Mooc에서 기본 개념정도는 알아두고 시작하는 것이 좋다고 생각한다. 추천하는 Mooc는 역시 codeschool의 <a href="https://www.codeschool.com/courses/real-time-web-with-node-js" rel="external nofollow noopener noreferrer" target="_blank">Node.js Tutorial | Code School</a> , <a href="https://www.codeschool.com/courses/building-blocks-of-express-js" rel="external nofollow noopener noreferrer" target="_blank">Express.js Tutorial | Code School</a>를 참조하는 것이 좋다. codeschool은 유료기는 하지만 충분이 가격 대비 품질이 보증되는 Mooc이므로 무조건 추천한다.<br><br></p><h1 id="Typescript란"><a href="#Typescript란" class="headerlink" title="Typescript란?"></a>Typescript란?</h1><img src="/2017/01/30/Node-Express-Typescript-Mongo-project-boilerplate/typescript.jpg" title="Typescript"><p><br><br><a href="https://www.typescriptlang.org/" rel="external nofollow noopener noreferrer" target="_blank">Typescript</a>는 순수한 자바스크립트로 컴파일되는 자바스크립트 superset이다. 컴파일 타임에서 타입을 체크하는 언어이고, Microsoft가 주요 Maintainer이며 <a href="https://angular.io/" rel="external nofollow noopener noreferrer" target="_blank">Angular</a> , <a href="http://ionicframework.com/" rel="external nofollow noopener noreferrer" target="_blank">Ionic Framework</a> , <a href="http://aurelia.io/" rel="external nofollow noopener noreferrer" target="_blank">Aurelia</a>, <a href="https://dojotoolkit.org/" rel="external nofollow noopener noreferrer" target="_blank">DoJo</a>등 많은 오픈소스에서 이미 채택되어 사용중이다.<br>쉽게 말하면 타입이 있는 자바스크립트이다. 타입스크립트는 3가지 특징을 가지고있다.</p><ol><li><p>Type checking<br>자바스크립트에서 type은 <a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Data_structures" rel="external nofollow noopener noreferrer" target="_blank">동적타이핑</a>이며 이는 코딩할 때에 많은 이슈를 불러왔다. 예를들어 함수의 인자로 type을 검사하지 않기 때문에 String에서 Number관련 내장 함수를 사용하여 오류가 나는등 여러 이슈가 있다.<br>유연함이 생산성을 늘리는 것은 맞지만 도리어 해가 될때도 있다.  자바스크립트를 한번이라도 써본 사람이라면 타입이 있었으면 하는 바람을 가지고 있을 것이다. 이를 해결해 준것이 Typescript이다.</p></li><li><p>Compile<br>typescript로 작성한 파일에 컴파일 명령어를 치면 ecma5로 작성된 js를 자동으로 생성해준다. 그러므로 대부분의 브라우져에서 그대로 사용할 수 있다.</p></li><li><p>Objective Oriented Programming<br>마지막으로 OOP이다. typescript는 es6처럼 class를 가지고 있고 이는 그동안 자바스크립트가 가지고 있던 난해한 prototype으로 설계하는 방식에서 벗어나 다른 프로그래밍 언어와 비슷한 OOP를 적용할 수 있게 되었다는 점이다.<br><br></p></li></ol><h1 id="Mongo-DB란"><a href="#Mongo-DB란" class="headerlink" title="Mongo DB란?"></a>Mongo DB란?</h1><img src="/2017/01/30/Node-Express-Typescript-Mongo-project-boilerplate/mongo.png" title="Mongo"><p><br><br><a href="https://www.mongodb.com/" rel="external nofollow noopener noreferrer" target="_blank">MongoDB</a>는 대표적인 NoSQL으로 알려져있다. Scheme에 제약된 조건이 없으며 row수가 많은 데이터를 보관, 검색이 간편하고 scale-out에 장점을 가지고 있는 DB로 알려져있다.<br>사실 필자도 사이드 프로젝트를 하면서 Codeschool 강의를 참조하고, CRUD정도 작성해 본 것이 전부이기 때문에 다음 포스팅에서 자세히 작성하겠다.<br><br></p><h1 id="Getting-Started"><a href="#Getting-Started" class="headerlink" title="Getting Started"></a>Getting Started</h1><p>자 이제 기본 개념들을 알았으니 한번 사용해보자.<br>물론, 이 블로그 아티클을 보는 사람의 컴퓨터에 <a href="https://nodejs.org/ko/" rel="external nofollow noopener noreferrer" target="_blank">Node.js</a> 환경이 구축되어 있다는 것을 가정한다.  만약 Node.js가 구축되지 않은 환경이라면 <a href="https://nodejs.org/ko/download/package-manager/" rel="external nofollow noopener noreferrer" target="_blank">Node.js 설치</a> 링크를 참조하고 난 후 진행한다.  Node.js 환경이 구축되어 있다면 NPM이 설치되어 있을 것이다.<br><br></p><h3 id="1-NPM이-설치되어-있는지-확인"><a href="#1-NPM이-설치되어-있는지-확인" class="headerlink" title="1. NPM이 설치되어 있는지 확인"></a>1. NPM이 설치되어 있는지 확인</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm -v</span><br><span class="line">4.0.5</span><br></pre></td></tr></table></figure><h3 id="2-npm을-이용해-typescript-tslint-를-global로-설치한다"><a href="#2-npm을-이용해-typescript-tslint-를-global로-설치한다" class="headerlink" title="2. npm을 이용해 typescript, tslint  를 global로 설치한다."></a>2. npm을 이용해 typescript, tslint  를 global로 설치한다.</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g tslint typescript</span><br></pre></td></tr></table></figure><p><a href="https://palantir.github.io/tslint/" rel="external nofollow noopener noreferrer" target="_blank">TSLint</a> 란 typescript 전용 linter이다. <a href="https://subicura.com/2016/07/11/coding-convention.html" rel="external nofollow noopener noreferrer" target="_blank">linter</a>는 여러명이서 협업을 진행할때 코딩 스타일, 코딩 컨벤션을 지정해 주는 툴이고 보면 된다.  유명한 linter에 관한 짤은 다음 그림을 참조하자.<br> <img src="/2017/01/30/Node-Express-Typescript-Mongo-project-boilerplate/civil_war.jpg" title="전쟁"></p><p>이 프로젝트에서 쓰지 않지만 <strong>typings</strong>와 <strong>tsd</strong>에 대해서 궁금한 사람들이 혹시 있을까봐 적는다.<br><a href="https://github.com/typings/typings" rel="external nofollow noopener noreferrer" target="_blank">typings</a>란 기존  자바스크립트 라이브러리들의 타입 정보만을 선언한 파일을 내려받을 수 있도록 도와주는 tool이다. <dev>적다 보니 이제 안 쓴단다.</dev><br>이전엔 <a href="https://github.com/DefinitelyTyped/tsd" rel="external nofollow noopener noreferrer" target="_blank">TSD</a>라는 typings와 비슷한 definition manager가 있었으나 Deprecated 되고 typings로 옮겨졌다.<del><strong>그리고 typings 마저도 이제 안 쓴다.</strong></del></p><p>사실 필자도 설치하는 방법, 설정들을 정리하면서 @types/package들과 typings둘의 차이점에 대해서 몹시 궁금해졌다. 아무거나 적당히 사용하면 되는게 아닌가? 했지만 블로그에 글을 실으려면 정확한 정보를 제공해야 하기 때문에 구글링을 해 보았다.</p><p>구글 검색어: typings vs @type <del>(외국도 한국처럼 vs를 참 좋아한다. 2가지 비교하고 싶으면 compare보다 vs를 치는게 훨씬 잘 나오는듯)</del><br>역시나 갓버플로우 형님들이 깔끔한 답변을 넣어줬다.<br><a href="http://stackoverflow.com/questions/37548066/typescript-typings-in-npm-types-org-packages" rel="external nofollow noopener noreferrer" target="_blank">TypeScript typings in NPM @types org packages - Stack Overflow</a><br>3줄요약</p><ul><li>typescript 2.0넘으면 typings가 필요없다.</li><li>Microsoft에서 npm에 developer team을 갈아넣어서 maintain 할 것이다.</li><li>npm에서 설정만 하면 다 해줌.<br><br></li></ul><blockquote><p>결론적으로는 <code>$ npm install @types/express</code>  로 라이브러리를 설치하고<code>import * as express from &quot;express”;</code>  이렇게 사용한다.</p></blockquote><h2 id="3-Express-generator를-이용해-프로젝트-기본-Scaffolding을-한다"><a href="#3-Express-generator를-이용해-프로젝트-기본-Scaffolding을-한다" class="headerlink" title="3. Express generator를 이용해 프로젝트 기본 Scaffolding을 한다."></a>3. Express generator를 이용해 프로젝트 기본 Scaffolding을 한다.</h2><p>필자는 Webstorm을 주로 사용하고, Webstorm에서 node project를 만들때는<br>Webstorm의 file탭-new탭-project를 클리하면 다음 화면이 나오고, 원하는 generator 버전, template 엔진을 선택한다.<br><img src="/2017/01/30/Node-Express-Typescript-Mongo-project-boilerplate/webstorm.png" title="express-generator"><br><br></p><p>Webstorm을 깔기 싫은 독자는 커맨드라인을 이용한다. <a href="https://github.com/expressjs/generator" rel="external nofollow noopener noreferrer" target="_blank">GitHub - expressjs/generator: Express’ application generator</a>을 사용한다.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g express-generator</span><br><span class="line">$ express --view=jade 만들프로젝트경로 &amp;&amp; <span class="built_in">cd</span> 만들프로젝트경로</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure></p><p>API 서버를 만들것이기에 Template엔진은 default로 설정되어있는 jade를 우선 깔고 나중에 필요없는 코드를 삭제한다.</p><h2 id="4-프로젝트를-만들었으니-접속"><a href="#4-프로젝트를-만들었으니-접속" class="headerlink" title="4.  프로젝트를 만들었으니 접속"></a>4.  프로젝트를 만들었으니 접속</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm start</span><br></pre></td></tr></table></figure><p>그다음 <a href="http://localhost:3000/" rel="external nofollow noopener noreferrer" target="_blank">http://localhost:3000/</a> 에 접속하면  Express의 Wellcome to Express 화면을 볼 수 있다. 다음 화면을 볼 수 있으면 여기까지 잘 설치된 것이다.<br><img src="/2017/01/30/Node-Express-Typescript-Mongo-project-boilerplate/express.png" title="express"></p><h2 id="5-Typescript-컴파일-설정을-한다"><a href="#5-Typescript-컴파일-설정을-한다" class="headerlink" title="5. Typescript 컴파일 설정을 한다"></a>5. Typescript 컴파일 설정을 한다</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ tsc --init</span><br><span class="line">message TS6071: Successfully created a tsconfig.json file.</span><br></pre></td></tr></table></figure><p>위 커맨드로 tsconfig.json 파일이 생성되고 열어보면 다음과 같다.</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"compilerOptions"</span>: &#123;</span><br><span class="line">        <span class="attr">"module"</span>: <span class="string">"commonjs"</span>,</span><br><span class="line">        <span class="attr">"target"</span>: <span class="string">"es5"</span>,</span><br><span class="line">        <span class="attr">"noImplicitAny"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">"sourceMap"</span>: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://www.commonjs.org/" rel="external nofollow noopener noreferrer" target="_blank">CommonJS</a> 는 브라우저 뿐만 아니라 서버사이드 애플리케이션이나 데스크톱 애플리케이션에서 사용되기 위한 javascript 명세이다. ts를 es5의 js로 컴파일 한다는 설정이다.</p><h2 id="6-js파일들을-ts로-모두-바꾸자"><a href="#6-js파일들을-ts로-모두-바꾸자" class="headerlink" title="6. js파일들을 ts로 모두 바꾸자"></a>6. js파일들을 ts로 모두 바꾸자</h2><ul><li>Project/app.js =&gt; app.ts</li><li>Project/bin/www =&gt; <a href="http://www.ts" rel="external nofollow noopener noreferrer" target="_blank">www.ts</a></li><li>Project/router/index.js =&gt; index.ts</li></ul><h2 id="7-Tslint-Config"><a href="#7-Tslint-Config" class="headerlink" title="7. Tslint Config"></a>7. Tslint Config</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tslint —init</span><br></pre></td></tr></table></figure><p>위 커맨드를 입력하면 tslint.json파일이 생성되고, 이 파일에는 json구조로 규칙이 저장되어있다. 규칙을 수정하고 싶으면 tslint를 설정하는 규칙은 <a href="https://palantir.github.io/tslint/rules/" rel="external nofollow noopener noreferrer" target="_blank">Tslint Rules</a>을 참조하여 수정하면 된다.<br>간단히 설명하자면 대부분 첫번째 인자로의 true, false는 규칙 적용 여부, 그 뒤의 string은 옵션이다.<br>필자는 string이나 path에서 double quote(“)가 아닌 single quote(‘)를 사용하므로 이를 수정한다.<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">~~~</span><br><span class="line">&#123;</span><br><span class="line">“quotemark”: [</span><br><span class="line">            true,</span><br><span class="line">            “single” //기존 “double”</span><br><span class="line">        ],</span><br><span class="line">&#125;</span><br><span class="line">~~~</span><br></pre></td></tr></table></figure></p><p>Webstorm에서는 다음과 같이 설정하면 빨간 밑줄을 띄워주고, 대체로 editor나 IDE단에서 linter정도는 지원해 주므로 밑줄또는 경고등을 띄워준다.<br><img src="/2017/01/30/Node-Express-Typescript-Mongo-project-boilerplate/linter.png" title="tslint"></p><p>커맨드라인에서 linter를 적용하고 싶으면 다음을 입력하면 된다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tslint -c path/to/tslint.json ‘path/to/project/**/*.ts’</span><br></pre></td></tr></table></figure><p>linter를 적용하고 나면 여러 경고를 만날 수 있는데, 이 경고에 따라 수정하면 된다.</p><p>대체로 처음 설정후 만나는 linter의 경고에서는 변수가 아닌 값들을 var가 아닌 const나 let으로 강제하는 것들이 대부분이다. </p><h2 id="8-export"><a href="#8-export" class="headerlink" title="8. export"></a>8. export</h2><p>app.js의 마지막줄 module.export를 export default로 바꿈, routes/index.ts,routes/users.ts도 module.export를 export default로 바꾼다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> app; <span class="comment">// module.exports = app;</span></span><br></pre></td></tr></table></figure></p><h2 id="9-livereload"><a href="#9-livereload" class="headerlink" title="9. livereload"></a>9. livereload</h2><p>node는 기본적으로 코드를 변경하고 난 후에 서버를 재시작해야 그 코드가 반영된다. 매번 ctr + c, 서버 재시작하기 귀찮음을 많이 느껴보았으므로 livereload 기능은 써보니 엄청나게 편하다! 이를 설정하는 방법은 다음과 같다.</p><ul><li>npm install nodemon –save-dev</li><li>npm install concurrently –save-dev<br>concurrently는 여러 명령어를 한번에 실행시키는 node module이다.</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">…</span><br><span class="line">"scripts": &#123;</span><br><span class="line">    "start": "npm run build:live",</span><br><span class="line">    <span class="string">"concurrently \"tsc -w\" \"nodemon ./bin/www.js --config nodemon.json\""</span></span><br><span class="line">  &#125;,</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 스크립트를 넣음으로써 동작은 다음과 같다.</p><pre><code>1. npm start를 입력하면 typescript 컴파일러에 의해 코드의 변경을 감지하면 자동으로 컴파일을 진행(typescript =&gt; javascript)2. nodemon은 컴파일된 javascript 파일의 변화를 감지하고 재시작한다</code></pre><p>위의 방법이 싫으신 분은 ts-node사용하는 방법도 있다.<br><a href="https://basarat.gitbooks.io/typescript/content/docs/quick/nodejs.html" rel="external nofollow noopener noreferrer" target="_blank">Bonus: Live compile + run</a></p><h2 id="10-역시-소스코드-수정후-잘-돌아가는지-검사"><a href="#10-역시-소스코드-수정후-잘-돌아가는지-검사" class="headerlink" title="10. 역시 소스코드 수정후 잘 돌아가는지 검사"></a>10. 역시 소스코드 수정후 잘 돌아가는지 검사</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ npm strt</span><br><span class="line"></span><br><span class="line">yuhogyun-ui-MacBook-Pro:boilerplate yuhogyun$ npm start</span><br><span class="line"></span><br><span class="line">&gt; boilerplate@0.0.0 start /Users/yuhogyun/boilerplate</span><br><span class="line">&gt; npm run build:live</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt; boilerplate@0.0.0 build:live /Users/yuhogyun/boilerplate</span><br><span class="line">&gt; concurrently <span class="string">"tsc -w"</span> <span class="string">"nodemon ./bin/www.js --config nodemon.json"</span></span><br><span class="line"></span><br><span class="line">[1] [nodemon] 1.11.0</span><br><span class="line">[1] [nodemon] to restart at any time, enter `rs`</span><br><span class="line">[1] [nodemon] watching: *.*</span><br><span class="line">[1] [nodemon] starting `node ./bin/www.js`</span><br></pre></td></tr></table></figure><h2 id="11-Mongodb-Mongoose-설치-및-코드작성"><a href="#11-Mongodb-Mongoose-설치-및-코드작성" class="headerlink" title="11. Mongodb, Mongoose 설치 및 코드작성"></a>11. Mongodb, Mongoose 설치 및 코드작성</h2><p>우선 <a href="https://www.mongodb.com/download-center?jmp=nav#community" rel="external nofollow noopener noreferrer" target="_blank">MongoDB Download Center | MongoDB</a>  이 링크에서 몽고디비를 설치한다. 그다음 몽고디비 서버를 켠다<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mongod</span><br></pre></td></tr></table></figure></p><p><a href="https://github.com/Automattic/mongoose" rel="external nofollow noopener noreferrer" target="_blank">mongoose</a> 는 Mongo를 node에서 사용하기 위한 object model이라고 보면 된다.<br>typescript에서 mongoose를 이용하려면 <a href="https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/mongoose" rel="external nofollow noopener noreferrer" target="_blank">DefinitelyTyped/mongoose</a>를 따라해보자.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/** Mongoose Config **/</span></span><br><span class="line"><span class="keyword">var</span> mongoose = <span class="built_in">require</span>(<span class="string">'mongoose'</span>);</span><br><span class="line">mongoose.Promise = global.Promise;</span><br><span class="line">mongoose.connect(<span class="string">'mongodb://localhost/boilerplate'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123;Document, model, Model, Schema&#125; <span class="keyword">from</span> <span class="string">'mongoose'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> UserSchema: Schema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">  username: &#123;</span><br><span class="line">    type: <span class="built_in">String</span>,</span><br><span class="line">    required: <span class="literal">true</span>,</span><br><span class="line">    unique: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  age: <span class="built_in">Number</span>,</span><br><span class="line">  friends: [<span class="built_in">String</span>],</span><br><span class="line">  data: [Schema.Types.Mixed]</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">interface IUser extends Document &#123;</span><br><span class="line">  username: string;</span><br><span class="line">  age: number;</span><br><span class="line">  friends: string[];</span><br><span class="line">  data: any[];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> UserModel: Model&lt;IUser&gt; = model&lt;IUser&gt;(<span class="string">'User'</span>, UserSchema);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> user = <span class="keyword">new</span> UserModel(&#123;user.username: <span class="string">'Jane'</span>&#125;);</span><br><span class="line">user.username;     <span class="comment">// IUser properties are available</span></span><br><span class="line">user.save();       <span class="comment">// mongoose Document methods are available</span></span><br><span class="line"></span><br><span class="line">UserModel.findOne(&#123;&#125;, (err: any, <span class="attr">user</span>: IUser) =&gt; &#123;</span><br><span class="line">  user.username;   <span class="comment">// IUser properties are available</span></span><br><span class="line">  user.save();     <span class="comment">// mongoose Document methods are available</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p><br></p><h1 id="Reference-Demo-Project"><a href="#Reference-Demo-Project" class="headerlink" title="Reference Demo Project"></a>Reference Demo Project</h1><p>블로그 글을 쓰며 개인용으로도 쓸겸 typescript node mongo express로 기본 CRUD API 서버를 만들어보았다.<br>위의 긴 과정을 생략하고 싶은 독자들은 다음 링크를 참조하자.<br><a href="https://github.com/yoohoogun114/node-express-mongo-typescript" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/yoohoogun114/node-express-mongo-typescript</a><br><br></p><h1 id="글을-마치며"><a href="#글을-마치며" class="headerlink" title="글을 마치며"></a>글을 마치며</h1><p>Typescript가 트렌드가 될지 안 될지는 모르겠지만, 우선 javascript에서 타입 부여가 가능하다는 것은 매우 큰 장점이다. Typescript 말고도 관련 오픈소스 프로젝트들을 둘러보았는데 아주 활발한 것 같아서 아마 미래는 밝은 듯 하다. 또한 그동안 MEAN스택에서 빠져있던 mongo를 채우니 이제 드디어 완성인 것 같은 느낌이다.<br><br></p><h1 id="참고자료"><a href="#참고자료" class="headerlink" title="참고자료"></a>참고자료</h1><p><a href="https://basarat.gitbooks.io/typescript/content/docs/quick/nodejs.html" rel="external nofollow noopener noreferrer" target="_blank">TypeScript with NodeJS</a><br><a href="https://github.com/remy/nodemon/pull/871" rel="external nofollow noopener noreferrer" target="_blank">Include TypeScript files by default by arosequist · Pull Request #871 · remy/nodemon · GitHub</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;개요&quot;&gt;&lt;a href=&quot;#개요&quot; class=&quot;headerlink&quot; title=&quot;개요&quot;&gt;&lt;/a&gt;개요&lt;/h1&gt;&lt;p&gt;작년 제2회 유니톤(대학생 연합 해커톤)에 나가면서, 절실히 느꼈던 것은 미리 준비해 갈 수 있는 것들에 대해서 준비하지 않아
      
    
    </summary>
    
      <category term="Javascript" scheme="https://philographer.github.io/categories/javascript/"/>
    
    
      <category term="typescript" scheme="https://philographer.github.io/tags/typescript/"/>
    
  </entry>
  
</feed>
